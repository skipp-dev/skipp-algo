"""Shared US equity market calendar helpers.

Provides NYSE holiday detection, trading-day checks, and next/previous
trading-day resolution.  Used by ``terminal_poller`` and
``open_prep.run_open_prep`` — keeps the ~80-line holiday logic in a single
canonical location.
"""

from __future__ import annotations

import logging
from datetime import date, timedelta
from functools import lru_cache

logger = logging.getLogger(__name__)


# ── Low-level date helpers ──────────────────────────────────────


def nth_weekday_of_month(year: int, month: int, weekday: int, n: int) -> date:
    """Return the *n*-th occurrence of *weekday* in *month* of *year*.

    *weekday*: 0 = Monday … 6 = Sunday (``date.weekday()`` convention).
    """
    first = date(year, month, 1)
    offset = (weekday - first.weekday()) % 7
    return first + timedelta(days=offset + (n - 1) * 7)


def last_weekday_of_month(year: int, month: int, weekday: int) -> date:
    """Return the last occurrence of *weekday* in *month* of *year*."""
    if month == 12:
        last = date(year + 1, 1, 1) - timedelta(days=1)
    else:
        last = date(year, month + 1, 1) - timedelta(days=1)
    offset = (last.weekday() - weekday) % 7
    return last - timedelta(days=offset)


def observed_fixed_holiday(year: int, month: int, day: int) -> date:
    """Return the *observed* date for a fixed-date holiday.

    Saturday → observed Friday, Sunday → observed Monday.
    """
    holiday = date(year, month, day)
    if holiday.weekday() == 5:  # Saturday -> observed Friday
        return holiday - timedelta(days=1)
    if holiday.weekday() == 6:  # Sunday -> observed Monday
        return holiday + timedelta(days=1)
    return holiday


def easter_sunday(year: int) -> date:
    """Gregorian Easter Sunday (Meeus/Jones/Butcher algorithm)."""
    a = year % 19
    b = year // 100
    c = year % 100
    d = b // 4
    e = b % 4
    f = (b + 8) // 25
    g = (b - f + 1) // 3
    h = (19 * a + b - d - g + 15) % 30
    i = c // 4
    k = c % 4
    el = (32 + 2 * e + 2 * i - h - k) % 7
    m = (a + 11 * h + 22 * el) // 451
    month = (h + el - 7 * m + 114) // 31
    day = ((h + el - 7 * m + 114) % 31) + 1
    return date(year, month, day)


# ── Holiday set & trading-day checks ───────────────────────────


@lru_cache(maxsize=16)
def us_equity_market_holidays(year: int) -> frozenset[date]:
    """NYSE full-day holiday set (core schedule, excludes special closures)."""
    good_friday = easter_sunday(year) - timedelta(days=2)
    return frozenset({
        observed_fixed_holiday(year, 1, 1),      # New Year's Day
        nth_weekday_of_month(year, 1, 0, 3),     # Martin Luther King Jr. Day
        nth_weekday_of_month(year, 2, 0, 3),     # Presidents Day
        good_friday,
        last_weekday_of_month(year, 5, 0),       # Memorial Day
        observed_fixed_holiday(year, 6, 19),      # Juneteenth
        observed_fixed_holiday(year, 7, 4),       # Independence Day
        nth_weekday_of_month(year, 9, 0, 1),     # Labor Day
        nth_weekday_of_month(year, 11, 3, 4),    # Thanksgiving
        observed_fixed_holiday(year, 12, 25),     # Christmas Day
    })


def is_us_equity_trading_day(d: date) -> bool:
    """Return ``True`` if *d* is a regular NYSE trading day."""
    if d.weekday() >= 5:
        return False
    if d in us_equity_market_holidays(d.year):
        return False
    # Cross-year edge case: when Jan 1 falls on Saturday, NYSE observes the
    # closure on Friday Dec 31 of the previous year.  That observed date is
    # generated by us_equity_market_holidays(d.year + 1), not d.year.
    return not (d.month == 12 and d in us_equity_market_holidays(d.year + 1))


# ── Next / previous trading day ────────────────────────────────


def next_trading_day(ref: date) -> date:
    """Return the next US equity trading day after *ref*."""
    d = ref + timedelta(days=1)
    for _ in range(14):
        if is_us_equity_trading_day(d):
            return d
        d += timedelta(days=1)
    return d


def prev_trading_day(ref: date) -> date:
    """Return the most recent US equity trading day before *ref*."""
    cur = ref - timedelta(days=1)
    for _ in range(14):
        if is_us_equity_trading_day(cur):
            return cur
        cur -= timedelta(days=1)
    # Defensive fallback — can only trigger if the holiday calendar is
    # severely wrong (>14 consecutive non-trading days).
    logger.warning(
        "prev_trading_day: exhausted 14-day lookback from %s, returning %s "
        "(may not be a trading day)",
        ref,
        cur,
    )
    return cur
