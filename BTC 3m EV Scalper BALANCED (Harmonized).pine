//@version=5
strategy("BTC 3m EV Scalper BALANCED (Harmonized)", overlay=true,
     initial_capital=5000, pyramiding=0,
     default_qty_type=strategy.fixed,
     commission_type=strategy.commission.percent,
     commission_value=0.01,
     slippage=0)

// =====================
// INPUTS
// =====================
fastEMA = input.int(23, "Fast EMA")
slowEMA = input.int(55, "Slow EMA")
rsiLen  = input.int(15, "RSI Length")
atrLen  = input.int(14, "ATR Length")

volMult = input.float(1.16, "Volatility Filter Multiplier", step=0.01)
riskPct = input.float(0.5,  "Risk % per trade", step=0.1)
rr      = input.float(1.7,  "Reward/Risk Ratio", step=0.1)

// Sweep / breakout
lookback     = input.int(10, "Sweep Lookback")
pullbackBars = input.int(3,  "Pullback Bars")

// HTF modes
useHtf       = input.bool(true, "Use HTF Filter")
htfTf        = input.timeframe("60", "HTF Timeframe")
htfEmaLen    = input.int(50, "HTF EMA Length")
htfMode      = input.string("EMA", "HTF Mode",
               options=["OFF","EMA","EMA+Slope","Price+FastSlope","RiskOff"])

// Sizing realism
cashBufferPct = input.float(0.98, "Max Notional as % of Equity", step=0.01)
roundQty      = input.bool(true, "Round qty to step")
qtyStep       = input.float(0.00001, "Qty step (e.g. 0.00001)", step=0.00001)

// Trade management
tp1_R         = input.float(0.8, "TP1 at R multiple (partial)", step=0.1)
tp1_pct       = input.float(60,  "TP1 % size", minval=1, maxval=99)

beStartR      = input.float(0.6, "Break-even start (R)", step=0.1)
trailStartR   = input.float(0.9, "Trail start (R)", step=0.1)
trailATRmult  = input.float(1.0, "Trail ATR mult", step=0.1)

timeStopBars  = input.int(30, "Time-stop bars (Soft)", minval=1)
progressR     = input.float(1.0, "Min progress by time-stop (R)", step=0.1)
hardMaxBars   = input.int(120, "Hard max bars (Force close)", minval=1)

// =====================
// INDICATORS
// =====================
emaFast = ta.ema(close, fastEMA)
emaSlow = ta.ema(close, slowEMA)
rsi     = ta.rsi(close, rsiLen)
atr     = ta.atr(atrLen)

atrAvg  = ta.sma(atr, 49)
highVol = atr > atrAvg * volMult

trendLong  = emaFast > emaSlow
trendShort = emaFast < emaSlow
emaFastSlope = emaFast - emaFast[1]

// =====================
// HTF FILTER
// =====================
htfClose = request.security(syminfo.tickerid, htfTf, close,                    lookahead=barmerge.lookahead_off)
htfEma   = request.security(syminfo.tickerid, htfTf, ta.ema(close, htfEmaLen), lookahead=barmerge.lookahead_off)
htfEmaSlope = htfEma - htfEma[1]
htfBull  = htfClose > htfEma
htfBear  = htfClose < htfEma

allowL = true
allowS = true

if useHtf
    if htfMode == "OFF"
        allowL := true
        allowS := true
    else if htfMode == "EMA"
        allowL := htfBull
        allowS := htfBear
    else if htfMode == "EMA+Slope"
        allowL := htfBull and htfEmaSlope > 0
        allowS := htfBear and htfEmaSlope < 0
    else if htfMode == "Price+FastSlope"
        allowL := close > htfEma and emaFastSlope > 0
        allowS := close < htfEma and emaFastSlope < 0
    else // RiskOff
        allowL := htfBull
        allowS := htfBear

// =====================
// LIQUIDITY SWEEP + CONTROLLED BREAKOUT
// =====================
sweepLow  = low  < ta.lowest(low[1],  lookback)
sweepHigh = high > ta.highest(high[1], lookback)

pullbackLong  = ta.lowest(low,  pullbackBars) < emaFast
pullbackShort = ta.highest(high, pullbackBars) > emaFast

breakHigh = close > ta.highest(high, 6)[1]
breakLow  = close < ta.lowest(low,  6)[1]

longBreakout  = trendLong  and pullbackLong  and breakHigh and rsi > 50 and highVol
shortBreakout = trendShort and pullbackShort and breakLow  and rsi < 50 and highVol

longSweep  = trendLong  and sweepLow  and rsi > 45 and highVol
shortSweep = trendShort and sweepHigh and rsi < 55 and highVol

longCond  = (longSweep  or longBreakout)  and allowL
shortCond = (shortSweep or shortBreakout) and allowS

// =====================
// RISK MGMT + REALISTIC SIZING
// =====================
stopDist   = atr * 1.16
targetDist = stopDist * rr

riskAmount = strategy.equity * (riskPct / 100.0)
qtyRisk    = stopDist > 0 ? (riskAmount / stopDist) : na

maxNotional = strategy.equity * cashBufferPct
qtyCash     = close > 0 ? (maxNotional / close) : na

qtyEffRaw = math.min(qtyRisk, qtyCash)

f_round_step(x, step) =>
    step > 0 ? (math.floor(x / step) * step) : x

qtyEff = na(qtyEffRaw) ? na : (roundQty ? f_round_step(qtyEffRaw, qtyStep) : qtyEffRaw)
qtyEff := (qtyEff <= 0) ? na : qtyEff

// =====================
// ENTRY + STORE SIGNAL-CLOSE BASE LEVELS
// =====================
var float baseClose = na
var float baseStopDist = na
var float baseTargetDist = na
var int   entryBar = na

// RiskOff flatten
if useHtf and htfMode == "RiskOff"
    if strategy.position_size > 0 and htfBear
        strategy.close("LONG", comment="RiskOff HTF flip")
    if strategy.position_size < 0 and htfBull
        strategy.close("SHORT", comment="RiskOff HTF flip")

if strategy.position_size == 0
    if longCond and not na(qtyEff)
        baseClose      := close
        baseStopDist   := stopDist
        baseTargetDist := targetDist
        entryBar       := bar_index
        strategy.entry("LONG", strategy.long, qty=qtyEff)

    if shortCond and not na(qtyEff)
        baseClose      := close
        baseStopDist   := stopDist
        baseTargetDist := targetDist
        entryBar       := bar_index
        strategy.entry("SHORT", strategy.short, qty=qtyEff)

// =====================
// EXIT / TRADE MANAGEMENT
// =====================
inLong  = strategy.position_size > 0
inShort = strategy.position_size < 0

var float highSinceEntry = na
var float lowSinceEntry  = na

if strategy.position_size == 0
    highSinceEntry := na
    lowSinceEntry  := na
else
    highSinceEntry := na(highSinceEntry) ? high : math.max(highSinceEntry, high)
    lowSinceEntry  := na(lowSinceEntry)  ? low  : math.min(lowSinceEntry,  low)

if (inLong or inShort) and not na(baseClose) and not na(baseStopDist)
    ep = strategy.position_avg_price
    oneR = baseStopDist

    longSL = baseClose - baseStopDist
    longTP = baseClose + baseTargetDist
    shortSL = baseClose + baseStopDist
    shortTP = baseClose - baseTargetDist

    longTP1  = baseClose + oneR * tp1_R
    shortTP1 = baseClose - oneR * tp1_R

    beLong  = ep
    beShort = ep

    trailDist = atr * trailATRmult

    longStopDyn  = longSL
    shortStopDyn = shortSL

    if inLong and highSinceEntry >= ep + oneR * beStartR
        longStopDyn := math.max(longStopDyn, beLong)
    if inShort and lowSinceEntry <= ep - oneR * beStartR
        shortStopDyn := math.min(shortStopDyn, beShort)

    if inLong and highSinceEntry >= ep + oneR * trailStartR
        longStopDyn := math.max(longStopDyn, highSinceEntry - trailDist)
    if inShort and lowSinceEntry <= ep - oneR * trailStartR
        shortStopDyn := math.min(shortStopDyn, lowSinceEntry + trailDist)

    barsInTrade = na(entryBar) ? 0 : (bar_index - entryBar)
    
    if barsInTrade >= hardMaxBars
        if inLong
            strategy.close("LONG", comment="Hard TimeStop")
        if inShort
            strategy.close("SHORT", comment="Hard TimeStop")
    else if barsInTrade >= timeStopBars
        if inLong
            madeProgress = highSinceEntry >= ep + oneR * progressR
            if not madeProgress
                strategy.close("LONG", comment="Soft TimeStop no progress")
        if inShort
            madeProgress = lowSinceEntry <= ep - oneR * progressR
            if not madeProgress
                strategy.close("SHORT", comment="Soft TimeStop no progress")

    if inLong
        if tp1_pct > 0
            strategy.exit("TP1 LONG", "LONG", limit=longTP1, qty_percent=tp1_pct)
        strategy.exit("TP/SL LONG", "LONG", stop=longStopDyn, limit=longTP)
    if inShort
        if tp1_pct > 0
            strategy.exit("TP1 SHORT", "SHORT", limit=shortTP1, qty_percent=tp1_pct)
        strategy.exit("TP/SL SHORT", "SHORT", stop=shortStopDyn, limit=shortTP)

// =====================
// VISUALS
// =====================
plot(emaFast, color=color.orange)
plot(emaSlow, color=color.blue)

plotshape(longCond and strategy.position_size == 0,  style=shape.triangleup,   location=location.belowbar, size=size.tiny, color=color.new(color.green, 0))
plotshape(shortCond and strategy.position_size == 0, style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(color.red, 0))