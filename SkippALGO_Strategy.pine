// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6
// SkippALGO Strategy v6.3.13
// - Synchronized with Main Indicator v6.3.13
// - New "Option C" Score Engine (Fail-open features, Risk-gated)
// - Target Profiles (Fixed, KReturn, KATR, TPorSL)
// - Ensemble Score (Algo + Pullback + Regime)
// - 2D Binning (Score x Volatility)
// - Platt Scaling (SGD Probability Calibration)
// - v6.3.13: Parity hardening (gates + dynamic TP/SL + structure tag wiring)
strategy("SkippALGO Strategy v6.3.13", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_labels_count=500, max_lines_count=500)

//====================
// Inputs â€” Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Hybrid", "Signal engine", options=["Hybrid","Breakout","Trend+Pullback","Loose"])
allowNeuralReversals = input.bool(true, "Allow Neural Reversals (ChoCH)", tooltip="Injects early reversal signals (Bearish/Bullish ChoCH) into the Engine logic. Uncheck to restrict entries to standard Engine triggers (Trend/Breakout) only.")

useForecastGateEntry = input.bool(true, "Entry gate: require forecast edge (3-way)")
entryFcTF    = input.string("F3", "Entry horizon", options=["F1","F2","F3","F4","F5","F6","F7"])
minDirProb   = input.float(0.42, "Min dir prob (Up/Down)", minval=0.34, maxval=0.95, step=0.01)
minEdgePP    = input.float(0.10, "Min edge (pp) vs mid", minval=0.00, maxval=0.50, step=0.01)
requireRelOk = input.bool(false, "Entry gate: require bin reliability ok/strong")
requirePathTargetEntry = input.bool(true, "Entry gate: require PathTPvsSL target")
useChopAbstain = input.bool(true, "Chop abstain when Flat high")
flatAbstainThr = input.float(0.55, "Chop abstain: Flat prob â‰¥", minval=0.34, maxval=0.80, step=0.01)

requireSET   = input.bool(true, "Entry gate: require SET (CRSI confluence)")

pbLookback = input.int(12, "Pullback lookback", minval=2)
pbMinATR   = input.float(0.20, "Pullback min depth (ATR)", minval=0.0, step=0.05)
pbMaxATR   = input.float(1.50, "Pullback max depth (ATR)", minval=0.1, step=0.05)

useVolConfirm = input.bool(false, "Volume confirmation")
volLen   = input.int(20, "Volume SMA len", minval=2)
volMult  = input.float(1.20, "Volume mult", minval=0.1, step=0.05)

useAtrRisk = input.bool(true, "ATR Risk Model (Stops/TP/Trail)")
stopATR  = input.float(2.00, "Stop ATR (Initial)", minval=0.1, step=0.10, tooltip="Initial Hard Stop. Wide to survive entry noise.")
tpATR    = input.float(5.00, "Take Profit ATR (Initial)", minval=0.1, step=0.10)
useInfiniteTP = input.bool(false, "Infinite TP (Trailing Stop Only)", tooltip="Disables fixed Take Profit targets. Exits only via Stop Loss or Trailing Stop to capture large spikes.")
useDynamicSlProfile = input.bool(true, "Dynamic SL Profile", tooltip="Adaptive stop profile: optional early widening to reduce noise stopouts, then tightening as R grows.")
dynamicSlWidenUntilR = input.float(0.30, "Dynamic SL widen until R", minval=0.0, step=0.05, tooltip="Early phase where widening may be applied. 0 disables widening phase.")
dynamicSlMaxWidenATR = input.float(0.30, "Dynamic SL max widen ATR", minval=0.0, step=0.05, tooltip="Maximum additional ATR added to stop distance during early widening phase.")
dynamicSlTightenStartR = input.float(1.00, "Dynamic SL tighten starts at R", minval=0.0, step=0.10, tooltip="From this R onward, stop distance tightens progressively.")
dynamicSlTightenATRPerR = input.float(0.25, "Dynamic SL tighten ATR per +1R", minval=0.0, step=0.05, tooltip="ATR reduction in stop distance per extra +1R after tighten start.")
dynamicSlMaxTightenATR = input.float(1.50, "Dynamic SL max tighten ATR", minval=0.0, step=0.10, tooltip="Maximum ATR reduction applied to stop distance by dynamic tightening.")
dynamicSlRequireTrend = input.bool(true, "Dynamic SL requires trend context", tooltip="Long: requires bullish trend context. Short: requires bearish trend context.")
dynamicSlRequireConf = input.bool(false, "Dynamic SL requires confidence", tooltip="If enabled, dynamic SL adjustments only run when confidence is above threshold.")
dynamicSlMinConf = input.float(0.55, "Dynamic SL min confidence", minval=0.0, maxval=1.0, step=0.01)
useDynamicTpExpansion = input.bool(true, "Dynamic TP Expansion", tooltip="When enabled, TP can move farther as unrealized profit (R) grows. Outward-only (never tightens TP).")
dynamicTpKickInR = input.float(1.00, "Dynamic TP starts at R", minval=0.0, step=0.10, tooltip="TP expansion starts after this unrealized R multiple is reached.")
dynamicTpAddATRPerR = input.float(0.50, "Dynamic TP add ATR per +1R", minval=0.0, step=0.05, tooltip="Additional TP ATR multiplier added per extra +1R after kick-in.")
dynamicTpMaxAddATR = input.float(2.50, "Dynamic TP max extra ATR", minval=0.0, step=0.10, tooltip="Caps total additional TP distance added by dynamic expansion.")
dynamicTpRequireTrend = input.bool(true, "Dynamic TP requires trend context", tooltip="Long: requires bullish trend context. Short: requires bearish trend context.")
dynamicTpRequireConf = input.bool(false, "Dynamic TP requires confidence", tooltip="If enabled, TP expansion only runs when confidence is above the threshold.")
dynamicTpMinConf = input.float(0.55, "Dynamic TP min confidence", minval=0.0, maxval=1.0, step=0.01)
trailATR = input.float(2.50, "Trail ATR", minval=0.1, step=0.10)
trailAfterR = input.float(1.50, "Trail activates after R", minval=0.0, step=0.10)

// Engulfing Exits (Optional)
useEngulfExit = input.bool(false, "Engulfing Exit Trigger", tooltip="Enable context-aware exits on prominent engulfing candles.")
engulfExitMode = input.string("Tighten Risk", "Engulfing Exit Mode", options=["Tighten Risk", "Contextual Exit"], tooltip="Tighten Risk: Moves Stop Loss tighter when engulfing occurs. Contextual Exit: Triggers normal exit signal if Big 3 (USI, Momentum, Liquidity) confirm reversal.")
engulfTightenMult = input.float(0.5, "Engulf Tighten (ATR)", minval=0.1, step=0.1, tooltip="Amount to tighten stop relative to current price or entry. Moves stop closer.")

// Dynamic Risk Decay
useRiskDecay = input.bool(true, "Dynamic Risk Decay (Linear Tightening)", tooltip="Interpolates Stop/TP from Initial to Sustained values over N bars.")
decayStopATR = input.float(1.00, "Sustained Stop ATR", minval=0.1)
decayTpATR   = input.float(3.00, "Sustained TP ATR", minval=0.1)
decayBars    = input.int(3, "Decay Duration (Bars)", minval=1, tooltip="Time to transition from Initial Risk to Sustained Risk. Note: if decayBars < exitGraceBars, stop reaches sustained before structural exits are allowed â€” this is intentional to tighten risk while giving the trade time to develop.")

exitGraceBars = input.int(5, "Exit Grace Period (Bars)", minval=0, tooltip="Prevents structural exits (trend flips) for the first N bars after entry to avoid immediate wicks/noise.")

swingL = input.int(5, "Breakout swing left", minval=1, maxval=20)
swingR = input.int(3, "Breakout swing right", minval=1, maxval=20)
swingMaxAgeBars = input.int(0, "Breakout swing max age (bars)", minval=0, maxval=2000, tooltip="0 disables expiry of old swings")
breakoutSource = input.string("Close", "Breakout Source", options=["Close", "Wick"], tooltip="Determines if a breakout requires a candle Close or just a Wick cross.")
structureLogic = input.string("Standard", "Structure Logic", options=["Standard", "SMC+Sweep"], tooltip="Standard: ChoCH = Trend Reversal (Break of Swing Low). SMC+Sweep: ChoCH includes Failed Breakouts (Reclaim of Level).")
chochScalpPreset = input.bool(false, "ChoCH Scalp Fast preset", tooltip="Preset values: breakoutSource=Wick, chochSignalMode=Ping (Fast), swingREff=max(swingR,1). Note: if Fast+Safer is also enabled, Fast+Safer takes precedence.")
chochScalpSaferPreset = input.bool(false, "ChoCH Fast+Safer preset", tooltip="Preset values: breakoutSource=Wick, chochSignalMode=Ping+Verify, swingREff=max(swingR,1). Safer than Fast due to additional verify confirmation.")

// Market Structure (BOS / ChoCH)
chochSignalMode  = input.string("Ping+Verify", "ChoCH signal mode", options=["Ping (Fast)", "Verify (Safer)", "Ping+Verify"], tooltip="Manual mode selector when no ChoCH preset is active. Preset override: Fast => Ping (Fast), Fast+Safer => Ping+Verify.")
showChochPing    = input.bool(true, "Show ChoCH Ping markers")
chochMinProb     = input.float(0.50, "ChoCH Min Confidence (Prob)", minval=0.34, maxval=0.95, step=0.01)
chochReqVol      = input.bool(true, "ChoCH Require Volume?")

enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)

// --- Cooldown mode (legacy Bars vs Minutes) ---
cooldownMode = input.string("Bars", "Cooldown mode", options=["Bars", "Minutes"])
cooldownMinutes = input.int(30, "Cooldown minutes", minval=1)
cooldownTriggers = input.string("ExitsOnly", "Cooldown triggers", options=["ExitsOnly", "AllSignals", "EntriesOnly"])
allowSameBarBuyAfterCover = input.bool(false, "Allow same-bar BUY after COVER", tooltip="When enabled, BUY can trigger on the same bar as a COVER. Disabled keeps one-bar delay after COVER.")
allowSameBarShortAfterExit = input.bool(false, "Allow same-bar SHORT after EXIT", tooltip="When enabled, SHORT can trigger on the same bar as an EXIT. Disabled keeps one-bar delay after EXIT.")

// --- Signal Enhancement Filters ---
grp_sigfilt = "Signal Filters"
// C1 â€“ Pre-signal momentum gate
usePreMomentum = input.bool(false, "Pre-signal momentum gate", group=grp_sigfilt, tooltip="Require RSI alignment with trade direction")
preMomRsiHi    = input.int(65, "Pre-signal RSI high (long)", minval=55, maxval=80, group=grp_sigfilt)
preMomRsiLo    = input.int(35, "Pre-signal RSI low (short)", minval=20, maxval=45, group=grp_sigfilt)
// Optional engulfing filter (3 opposite candles before engulfing candle)
useEngulfing3Filter = input.bool(false, "Engulfing filter (3 candles)", group=grp_sigfilt, tooltip="Require 3 opposite candles before engulfing candle for LONG/SHORT entries.")
engulfingRequireBodyDominance = input.bool(true, "Engulfing: body > prev body", group=grp_sigfilt, tooltip="Require engulfing candle body to be larger than previous candle body.")
showEngulfingBarColors = input.bool(false, "Engulfing: color bars", group=grp_sigfilt, tooltip="Color bullish engulfing bars yellow and bearish engulfing bars white.")
// C3 â€“ EMA acceleration filter
useEmaAccel    = input.bool(false, "EMA acceleration filter", group=grp_sigfilt, tooltip="Check that EMA gap is expanding")
// C4 â€“ VWAP alignment filter
useVwap        = input.bool(false, "VWAP alignment filter", group=grp_sigfilt, tooltip="Long above VWAP, short below (intraday only)")
// D1 â€“ Smooth trend regime
useSmoothTrend = input.bool(false, "Smooth trend regime", group=grp_sigfilt, tooltip="Replace discrete trend with continuous [-1,1]")
// D2 â€“ ADX trend strength
useAdx         = input.bool(false, "ADX trend strength filter", group=grp_sigfilt, tooltip="Require ADX above threshold for trending entries")
adxLen         = input.int(14, "ADX length", minval=5, maxval=50, group=grp_sigfilt)
adxThresh      = input.float(20.0, "ADX min threshold", minval=5.0, maxval=50.0, step=1.0, group=grp_sigfilt)

// D3 â€“ Regression Slope Oscillator Gates
useRegSlope    = input.bool(false, "Regression Slope filter", group=grp_sigfilt, tooltip="Require positive slope osc for Longs, negative for Shorts")
rsMaxRange     = input.int(100, "RegSlope Max Range", minval=10, group=grp_sigfilt)
rsMinRange     = input.int(10, "RegSlope Min Range", minval=5, group=grp_sigfilt)
rsStep         = input.int(5, "RegSlope Step", minval=1, group=grp_sigfilt)

// Volatility context (light overlay, default OFF)
atrRegimeBaselineLen = input.int(50, "ATR regime baseline len", minval=20, maxval=300, group=grp_sigfilt)
atrRegimeBaselineType = input.string("SMA", "ATR regime baseline", options=["SMA", "EMA"], group=grp_sigfilt)
atrCompressionThr = input.float(0.70, "ATR compression threshold", minval=0.30, maxval=0.95, step=0.05, group=grp_sigfilt)
atrExpansionThr = input.float(1.15, "ATR expansion threshold", minval=1.00, maxval=2.00, step=0.05, group=grp_sigfilt)
atrHighVolThr = input.float(1.40, "ATR high-vol threshold", minval=1.10, maxval=3.00, step=0.05, group=grp_sigfilt)
atrExhaustLookback = input.int(5, "ATR exhaustion lookback", minval=3, maxval=30, group=grp_sigfilt)
enableAtrPercentile = input.bool(false, "ATR percentile context", group=grp_sigfilt, tooltip="Compute ATR percentile rank for context (0..100).")
atrPercentileLookback = input.int(100, "ATR percentile lookback", minval=50, maxval=500, group=grp_sigfilt)

// VWT (Volume Weighted Trend) integration
useVwtTrendFilter = input.bool(false, "VWT trend/reversal filter", group=grp_sigfilt, tooltip="Entries only with VWT trend direction. Optional reversal window restricts entries to recent trend turns.")
vwtPreset = input.string("Auto", "VWT preset", options=["Auto", "Default", "Fast Response", "Smooth Trend", "Custom"], group=grp_sigfilt, tooltip="Auto maps by Entry preset: Intradayâ†’Fast Response, Swingâ†’Smooth Trend, Manual/Manuellâ†’Default.")
vwtLengthInput = input.int(34, "VWT VWMA length", minval=5, group=grp_sigfilt)
vwtAtrMultInput = input.float(1.5, "VWT ATR multiplier", minval=0.5, step=0.1, group=grp_sigfilt)
vwtReversalOnly = input.bool(true, "VWT entries only near reversal", group=grp_sigfilt, tooltip="If enabled, entries are allowed only for N bars after a VWT trend turn.")
vwtReversalWindowBars = input.int(3, "VWT reversal window (bars)", minval=0, maxval=50, group=grp_sigfilt)
showVwtTrendBackground = input.bool(false, "VWT trend background", group=grp_sigfilt, tooltip="Shows bullish/bearish VWT regime as chart background.")
vwtBgTransparency = input.int(90, "VWT background transparency", minval=0, maxval=100, group=grp_sigfilt)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting (weights are normalised at runtime; defaults sum to 1.10)
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

//====================
// Custom Logic: Regression Slope Oscillator
//====================
f_log_regression_single(src, length) =>
    if length < 2
        0.0
    else
        float sumX      = 0.0
        float sumY      = 0.0
        float sumXSqr   = 0.0
        float sumXY     = 0.0
        bool failed     = false
        for i = 0 to length - 1
            v = src[i]
            if na(v) or v <= 0
                failed := true
                break
            val = math.log(v)
            per = i + 1.0
            sumX += per
            sumY += val
            sumXSqr += per * per
            sumXY += val * per
        
        if failed
            float(na)
        else
            slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)
            slope * -1

f_calc_reg_slope_osc(src, minR, maxR, stepV) =>
    float slopeSum = 0.0
    int slopeCount = 0
    for i = minR to maxR by stepV
        res = f_log_regression_single(src, i)
        if not na(res)
            slopeSum += res
            slopeCount += 1
    slopeCount > 0 ? slopeSum / slopeCount : 0.0

//====================
// Constants â€” Avoid Magic Numbers
//====================
SEC_5M  = 5 * 60
SEC_15M = 15 * 60
SEC_30M = 30 * 60
SEC_1H  = 60 * 60
SEC_4H  = 4 * 60 * 60

// Volatility regime thresholds
VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

// Statistical constants
Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)
LOGIT_CLAMP     = 20.0    // Clamp for logit to limit extreme values
PRICE_EPS       = 0.0001  // Epsilon for price/ATR divisions

// Rolling buffer recalculation interval (prevent FP drift)
ROLL_RECALC_INTERVAL = 500

// Sideways/choppy market detection thresholds
SIDEWAYS_EMA_THRESH = 0.005   // Max EMA diff ratio for sideways
SIDEWAYS_ATR_THRESH = 0.015   // Max ATR norm for sideways

// Score / trend thresholds
SCORE_NEUTRAL_BAND  = 0.05    // MTF & outSym neutral dead-zone
TREND_SMOOTH_THRESH = 0.3     // Smooth trend strength threshold

// Calibration quality thresholds
HW_STRONG           = 0.05    // CI half-width: strong calibration
HW_OK               = 0.10    // CI half-width: acceptable calibration
ECE_GOOD            = 0.05    // ECE: well-calibrated
ECE_FAIR            = 0.10    // ECE: fair calibration
BRIER_EXCELLENT     = 0.18    // Brier score: A grade
BRIER_GOOD          = 0.22    // Brier score: B grade
BRIER_BASELINE      = 0.25    // Brier score: C grade (random)
BRIER_POOR          = 0.30    // Brier score: D grade

// Platt scaling stability bounds


penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showLongLabels   = input.bool(true, "Show Long labels (BUY / EXIT)")
showShortLabels  = input.bool(true, "Show Short labels (SHORT / COVER)")
showPreEntryLabels = input.bool(true, "Show PRE labels (PRE-BUY / PRE-SHORT)")
preWarnDistATR     = input.float(0.25, "PRE: proximity threshold (ATR)", minval=0.0, step=0.05, tooltip="Used for pre-warnings (Breakout / Trend+Pullback / Loose)")
preSetPulseOnly    = input.bool(true, "PRE: pulse-only SET", tooltip="When enabled, PRE labels require a fresh SET transition (pulse) instead of a steady SET state")
setPulseOnly     = input.bool(true, "SET: pulse only", tooltip="When enabled, SET prints only on the transition into a SET state")
showTable        = input.bool(true, "Show Outlook/Forecast table")

// Alerts
useAlertCalls       = input.bool(true, "Alerts: use alert() calls", tooltip="Strategy scripts ignore alertcondition(); use alert() instead (recommended ON)")
alertOnBarCloseOnly = input.bool(false,  "Alerts: bar close only")
strictMtfMargin = input.float(0.02, "Strict: MTF extra margin", minval=0.0, maxval=0.20, step=0.01, tooltip="Additional margin above/below SCORE_NEUTRAL_BAND required for strict BUY/SHORT confirmation.")
strictChochConfirmBars = input.int(1, "Strict: ChoCH confirm bars", minval=1, maxval=5, tooltip="For REV entries in strict mode, ChoCH must remain recent within this many bars on confirmation.")
useAdaptiveStrictMargin = input.bool(false, "Strict: adaptive MTF margin", tooltip="Adapts strictMtfMargin by ATR regime: stricter in high vol, looser in calm markets.")
strictAdaptiveRange = input.float(0.02, "Strict: adaptive range", minval=0.0, maxval=0.10, step=0.005, tooltip="Max additional/subtracted margin around strictMtfMargin based on ATR regime.")
strictAdaptiveLen = input.int(100, "Strict: adaptive ATR rank len", minval=20, maxval=500)
showStrictSignalMarkers = input.bool(true, "Show Strict confirmed markers")
strictMarkerStyle = input.string("Icon", "Strict marker style", options=["Icon", "Label", "Both"])

// Trading Session Time Window
useSessionFilter = input.bool(false, "Session Filter (Time Window)")
sessionWin       = input.session("1530-2200", "Trading Session (Exch Time)", tooltip="Only enters new trades inside this window. Does not force exits.")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

// v6.2.20: Opening window â€” bypass directional probability filter around market open
useRevOpenWindow  = input.bool(true, "Bypass pU/pD near market open", tooltip="Allow BUY/REV-BUY/SHORT/REV-SHORT to fire regardless of directional probability (pU/pD) during a window around the stock exchange open.")
rthOpenHour       = input.int(9,  "RTH open hour (exchange tz)", minval=0, maxval=23)
rthOpenMinute     = input.int(30, "RTH open minute", minval=0, maxval=59)
revOpenWindowLongMins = input.int(10, "Open window LONG Â± min", minval=1, maxval=120, tooltip="Long-side bypass window around RTH open.")
revOpenWindowShortMins = input.int(10, "Open window SHORT Â± min", minval=1, maxval=120, tooltip="Short-side bypass window around RTH open.")
revOpenWindowMode = input.string("All Entries", "Open window applies to", options=["All Entries", "Reversals Only"], tooltip="All Entries: bypass forecast gate + reversal pU/pD. Reversals Only: bypass only REV probability filter.")
revOpenWindowEngine = input.string("All", "Open window engine scope", options=["All", "Hybrid", "Breakout", "Trend+Pullback", "Loose"], tooltip="Limit open-window bypass to specific engines.")

//====================
// Automation Inputs (TradersPost / Webhooks)
//====================
grp_auto   = "Automation"
useJsonAlerts = input.bool(false, "Enable JSON Webhook Payloads", group=grp_auto, tooltip="Formats alerts as JSON for TradersPost or other bots. If disabled, sends human-readable text.")

//====================
// Inputs â€” Forecast Calibration Enhancements
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")
allowForecastOnNonFixed = input.bool(false, "Forecast: allow on non-fixed TFs", tooltip="If chart timeframe can't be resolved to seconds, allow forecast gating instead of disabling it")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])

atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)

//====================
// Inputs â€” Forecast 3-way (Up/Flat/Down)
//====================
grp_tri = "Forecast 3-way (Up/Flat/Down)"
use3Way = input.bool(true, "3-way probs: Up/Flat/Down", group=grp_tri)

deadbandFast = input.float(0.15, "Deadband Ã— ATR (Fast <=5m)", minval=0.0, step=0.01, group=grp_tri)
deadbandMid  = input.float(0.10, "Deadband Ã— ATR (Mid <=1h)",  minval=0.0, step=0.01, group=grp_tri)
deadbandSlow = input.float(0.07, "Deadband Ã— ATR (Slow >1h)",  minval=0.0, step=0.01, group=grp_tri)

flatPriorFast = input.float(0.42, "Warmup prior: Flat (Fast)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorMid  = input.float(0.30, "Warmup prior: Flat (Mid)",  step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorSlow = input.float(0.22, "Warmup prior: Flat (Slow)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)

tiltMaxFast = input.float(0.10, "Warmup tilt max (Fast)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxMid  = input.float(0.12, "Warmup tilt max (Mid)",  step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxSlow = input.float(0.15, "Warmup tilt max (Slow)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)

calibratorMode = input.string("Vector", "3-way calibrator", options=["Off","Temp","Vector"], group=grp_tri)
lrCal = input.float(0.01, "Calibrator LR", step=0.001, minval=0.0001, group=grp_tri)
tempMin = input.float(0.5, "Temp min", step=0.1, minval=0.1, group=grp_tri)
tempMax = input.float(5.0, "Temp max", step=0.1, minval=0.5, group=grp_tri)
vecAMin = input.float(0.25, "Vec A min", step=0.05, minval=0.05, group=grp_tri)
vecAMax = input.float(3.0, "Vec A max", step=0.05, minval=0.5, group=grp_tri)
vecBMin = input.float(-2.0, "Vec B min", step=0.1, group=grp_tri)
vecBMax = input.float(2.0, "Vec B max", step=0.1, group=grp_tri)
cal3AutoFallback = input.bool(true, "3-way auto fallback (weak bins)", group=grp_tri)
cal3MinSamples  = input.int(90, "3-way min samples for calibrator", minval=10, maxval=5000, group=grp_tri)
calRegStrength  = input.float(0.002, "Calibrator stabilize strength", minval=0.0, step=0.001, group=grp_tri)
useBullBearCal = input.bool(true, "Separate bull/bear calibrators", group=grp_tri)
countDecay = input.float(0.9995, "Count decay (1.0=none)", minval=0.80, maxval=1.0, step=0.0005, group=grp_tri)
kShrinkReg = input.int(20, "Regime shrinkage k", minval=0, maxval=1000, group=grp_tri)

//====================
// Liquidity Concepts (SMC)
//====================
grp_smc = "Liquidity Concepts (SMC)"
useLiqSweep     = input.bool(true, "Filter Reversals by Liquidity Sweep", group=grp_smc, tooltip="Only take Reversal entries if a Liquidity Sweep (stop hunt) occurred recently.")
liqSweepLookback= input.int(10, "Sweep Lookback (Bars)", minval=1, group=grp_smc)
// useLiqTargets   = input.bool(false, "Avg Entry Targets (Future)", group=grp_smc) // Reserved for Phase 2

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", minval=0.01, step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", minval=0.01, step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", minval=0.01, step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", minval=0.01, step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpPreset30m = input.string("Manual", "All-TF TP preset", options=["Manual", "Conservative", "Balanced", "Runner", "Super Runner"], group=grp_mid, tooltip="Applies to all timeframes. Manual=use profile Path TP/SL inputs. Conservative=TP x2.5 / SL x1.1. Balanced=TP x3.0 / SL x1.0. Runner=TP x3.8 / SL x0.85. Super Runner=TP x4.4 / SL x0.75.")
dynSlPreset30m = input.string("Manual", "All-TF Dynamic SL preset", options=["Manual", "Conservative", "Balanced", "Runner", "Super Runner"], group=grp_mid, tooltip="Applies to all timeframes. Manual=use input values. Conservative=Stop 1.00 / Trail 2.30. Balanced=Stop 0.90 / Trail 2.00. Runner=Stop 0.75 / Trail 1.70. Super Runner=Stop 0.65 / Trail 1.40.")
tpATRM    = input.float(0.80, "Path TP", minval=0.01, step=0.05, group=grp_mid)
slATRM    = input.float(1.00, "Path SL", minval=0.01, step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", minval=0.01, step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.00, "Path TP", minval=0.01, step=0.05, group=grp_slow)
slATRS    = input.float(1.00, "Path SL", minval=0.01, step=0.05, group=grp_slow)

// Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"], group="Policy")
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"], group="Policy")

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", minval=0.0, step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", minval=0.0, step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", minval=0.0, step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", minval=0.0, step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")
// B2 â€“ ROC factor in ensemble
wRoc      = input.float(0.0, "Weight: ROC factor", minval=0.0, step=0.1, group=grp_ens, tooltip="Rate of Change momentum (0=off)")
rocLen    = input.int(10, "ROC length", minval=2, maxval=50, group=grp_ens)
// B4 â€“ Volume in ensemble
wVol      = input.float(0.0, "Weight: Volume factor", minval=0.0, step=0.1, group=grp_ens, tooltip="Volume vs SMA ratio (0=off)")
volEnsLen = input.int(20, "Volume ensemble SMA len", minval=2, maxval=100, group=grp_ens)

// --- Phase 4: Online Calibration ---
grp_cal = "Calibration Settings (Phase 4)"
usePlatt = input.bool(true, "Use Platt Scaling (Online SGD)", group=grp_cal)
lrPlatt  = input.float(0.005, "Learning Rate (SGD)", minval=0.001, maxval=0.1, step=0.001, group=grp_cal)
// A2 â€“ SGD Momentum (Adam-lite)
useSgdMomentum = input.bool(false, "SGD momentum (Adam-lite)", group=grp_cal, tooltip="EMA of gradients for smoother convergence")
sgdBeta        = input.float(0.9, "SGD momentum beta", minval=0.5, maxval=0.99, step=0.01, group=grp_cal)

// Bins & Smoothing
predBinsN = input.int(4, "Pred bins (N) stable", minval=2, maxval=9, group="Engine")
predBins1 = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3, group="Engine")
dim2Bins  = 3 // Trend regime bins (bear/sideways/bull)

// Quantile binning (score dimension)
useQuantileBins = input.bool(true, "Use quantile bins (score)", group="Engine")
quantileWindow = input.int(500, "Quantile window (samples)", minval=100, maxval=5000, group="Engine")
quantileUpdate = input.int(25, "Quantile update interval (bars)", minval=10, maxval=1000, group="Engine")
quantileMinSamples = input.int(200, "Quantile min samples", minval=50, maxval=5000, group="Engine")
calibrateInBackground = input.bool(true, "Calibrate even if table hidden")

alphaN = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1, group="Engine")
alpha1 = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1, group="Engine")
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000, tooltip="Higher = pull bin probability closer to global TF average", group="Engine")

calMinSamples = input.int(30, "Min samples per bin (activate)", minval=5, maxval=1000, group="Engine")

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01, group="Signals")
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01, group="Signals")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7","ChartTF"], group="Maintenance")
resetNow   = input.bool(false, "Reset selected calibration NOW", group="Maintenance")


//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F3", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")

// Evidence / coverage gating
evidenceGate = input.bool(false, "Evidence gate (block weak bins)")
evidenceMinTotal = input.int(120, "Evidence min total samples", minval=1, maxval=10000)
abstainGate = input.bool(true, "Abstain on weak decisions")
abstainMinEdge = input.float(0.08, "Abstain min edge (pp)", minval=0.0, maxval=0.50, step=0.01)
abstainOverrideConf = input.float(0.85, "Abstain override: High Conf", minval=0.5, step=0.05, tooltip="If Confidence > this level, ignore sample size gates. Allows rare but high-quality signals.")

// Trade-gate thresholds (separate from calibration thresholds)
tradeMinBinSamples   = input.int(10, "Trade gate: min BIN samples", minval=0, maxval=200)
tradeMinTotalSamples = input.int(0,  "Trade gate: min TOTAL samples (0=off)", minval=0, maxval=20000)
rescueVolMult = input.float(1.5, "Rescue Mode: Min Volume (xSMA)", minval=1.0, maxval=50.0, step=0.1, tooltip="Volume ratio required to trigger Rescue Mode (bypasses gates).")
rescueImpulseATR = input.float(0.7, "Rescue Mode: Min Impulse (xATR)", minval=0.1, step=0.1, tooltip="Minimum candle body size (in ATR) to validate a Rescue Reversal.")
revMinProb       = input.float(0.50, "REV: Min dir prob", minval=0.20, maxval=0.80, step=0.01, tooltip="Minimum directional probability for REV-BUY / REV-SHORT (normal path). Raise to require stronger forecast conviction for reversals.")
revRecencyBars   = input.int(5, "Rev Recency (bars)", minval=1, maxval=20, tooltip="Max bars since ChoCH for a reversal signal to be considered recent enough.")


//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ConfErr/Drift)")

evalInBackground = input.bool(true, "Eval in background (when Eval section hidden)")

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"], tooltip="History+Live: counts confirmed historical + live outcomes, so Success rate is visible immediately (example: 62% (N=500)). LiveOnly: counts confirmed realtime outcomes only, so it starts at 0% (N=0) on history and grows during live bars (example: 66% (N=15)).")

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

evalBucketCount = use3Way ? evalBuckets * 3 : evalBuckets

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)
useEceGate      = input.bool(false, "Gate entries by ECE")
eceMax          = input.float(0.10, "Max ECE (gate)", minval=0.01, maxval=0.50, step=0.01)
useDriftGate    = input.bool(false, "Gate entries by drift")
driftMaxPP      = input.float(12.0, "Max drift (pp, gate)", minval=1.0, maxval=50.0, step=0.5)
useEvalPenalty  = input.bool(true, "Soft penalty on eval degrade")
eceWarn         = input.float(0.08, "ECE warn threshold", minval=0.01, maxval=0.50, step=0.01)
evalPenalty     = input.float(0.10, "Eval penalty (confidence)", minval=0.0, maxval=0.50, step=0.01)
// A5 â€“ ECE-triggered recalibration
useEceRecal     = input.bool(false, "ECE-triggered recal (boost LR)", tooltip="Temporarily boost Platt LR when ECE exceeds warn")
eceRecalBoost   = input.float(3.0, "ECE recal LR multiplier", minval=1.5, maxval=10.0, step=0.5)

//====================
// Inputs â€” Calibration Diagnostics (Debug Panel)
//====================


//====================
// Inputs â€” Calibration Export (Webhook)
//====================
grp_export = "ðŸ“¤ Calibration Export"
exportCalibration = input.bool(false, "Enable Calibration Export Alert", group=grp_export, tooltip="Fires alert with JSON calibration state")
exportInterval    = input.int(100, "Export Every N Bars", minval=10, maxval=1000, group=grp_export)
exportHorizon     = input.string("F1", "Export Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_export)

//====================
// Inputs â€” USI Quantum Pulse (visual overlay only â€” no signal influence)
//====================
useUsi          = input.bool(true, "Enable USI Quantum Pulse", group="âš¡ USI Quantum Pulse", tooltip="Multi-length RSI stacking overlay. Visual only â€” does not affect BUY/SHORT signals, MTF vote, confidence, or decision gate.")
usiLen1         = input.int(13, "Length 1 (slowest / Blue)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen2         = input.int(11, "Length 2 (Green)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen3         = input.int(7,  "Length 3 (Yellow)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen4         = input.int(5,  "Length 4 (Orange)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen5         = input.int(3,  "Length 5 (fastest / Red)", minval=1, group="âš¡ USI Quantum Pulse")
usiZeroLag      = input.bool(true, "Zero-Lag mode", group="âš¡ USI Quantum Pulse", tooltip="Error-corrected EMA on source before RSI. Gives 2-5 bar lead over standard RSI.")
usiMinStack     = input.int(4, "Min stacking for visual highlight", minval=2, maxval=5, group="âš¡ USI Quantum Pulse", tooltip="Lines in correct order (out of 4 pairs) for visual stacking highlight.")
usiTightFactor  = input.float(0.40, "USI Tight Spread Factor", minval=0.10, step=0.05, group="âš¡ USI Quantum Pulse") 
usiSpreadLookback = input.int(100, "Spread Lookback", minval=10, group="âš¡ USI Quantum Pulse")
hardenHold      = input.bool(true, "Hardened Hold (L5 > L4)", group="âš¡ USI Quantum Pulse")
usiAggressiveSameBarVerify = input.bool(false, "USI Aggressive: same-bar verify", group="âš¡ USI Quantum Pulse", tooltip="Uses the current bar cross for verification instead of waiting for [1] cross memory.")
usiAggressiveOneOfThree = input.bool(false, "USI Aggressive: verify 1-of-3", group="âš¡ USI Quantum Pulse", tooltip="Relaxes standard verify voting from 2-of-3 to 1-of-3 (tight-spread strict mode remains Hold+Continuation).")
usiAggressiveTightSpreadVotes = input.bool(false, "USI Aggressive: tight-spread votes", group="âš¡ USI Quantum Pulse", tooltip="When enabled, tight-spread mode also uses vote logic (2-of-3 or 1-of-3) instead of strict Hold+Continuation only.")
useUsiTrendOverride = input.bool(true, "USI blocks contrary entries", group="âš¡ USI Quantum Pulse", tooltip="When enabled, USI bearish state blocks long entries and bullish state blocks short entries. Disable to let scoring handle USI influence only (symmetric with useUsi).")

//====================
// Inputs â€” Score Engine (Option C)
//====================
grp_score = "Score Engine (Option C)"
lockPresetOverrides = input.bool(false, "Preserve current settings (lock preset overrides)", group=grp_score, tooltip="When enabled, Intraday/Swing preset auto-overrides are ignored and your current input values are kept.")
strategyParityCompat = input.bool(false, "Parity compatibility flag", group=grp_score, tooltip="No-op compatibility input used to keep Indicator/Strategy input-count parity checks stable.")
entryPreset = input.string("Manuell", "Entry preset", options=["Manuell", "Intraday", "Swing"], group=grp_score)
entryBehaviorProfile = input.string("Legacy (v6.3.9-like)", "Entry behavior profile", options=["Current (v6.3.12)", "Legacy (v6.3.9-like)", "Scalp Early (v6.3.12-fast)"], group=grp_score, tooltip="Current keeps the stricter v6.3.12 score/context/chop behavior. Legacy loosens entry strictness to approximate v6.3.9 timing. Scalp Early keeps v6.3.12 structure but lowers entry thresholds for earlier confirmations.")
useScoreEntries = input.bool(false, "Enable Score-Based Entries", group=grp_score, tooltip="Alternative entry logic based on accumulative evidence score.")
scoreThresholdLong = input.int(6, "Score Threshold (Long)", minval=1, group=grp_score)
scoreThresholdShort = input.int(6, "Score Threshold (Short)", minval=1, group=grp_score)
minDirProbLong = input.float(0.42, "Min dir prob (Long)", minval=0.20, maxval=0.95, step=0.01, group=grp_score)
minDirProbShort = input.float(0.42, "Min dir prob (Short)", minval=0.20, maxval=0.95, step=0.01, group=grp_score)
scoreMinPu = input.float(0.35, "Score min pU (Long)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
scoreMinPd = input.float(0.35, "Score min pD (Short)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
enforceGlobalProbFloor = input.bool(true, "Enforce score min pU/pD on all entries", group=grp_score, tooltip="When enabled, Score min pU (Long) and Score min pD (Short) are applied as hard floors to all entry paths (engine, score, and reversal).")
scoreMinConfLong = input.float(0.50, "Score min confidence (Long)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
scoreMinConfShort = input.float(0.50, "Score min confidence (Short)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
wUsi        = input.int(4, "Weight: USI Cross", minval=0, group=grp_score)
wLiquidity  = input.int(2, "Weight: Liquidity/Sweep", minval=0, group=grp_score)
wMomentum   = input.int(2, "Weight: Momentum", minval=0, group=grp_score)
wEngulfing  = input.int(2, "Weight: Engulfing", minval=0, group=grp_score)
wTrendContext = input.int(1, "Weight: Trend Context", minval=0, group=grp_score)
wChopPenalty = input.int(-3, "Penalty: Chop/Consolidation", maxval=0, group=grp_score, tooltip="Negative points applied during low volatility phases.")
usiTfGate       = input.timeframe("30", "Gate Timeframe", group="âš¡ USI Quantum Pulse")
usiEmaLen       = input.int(100, "Gate EMA Length", minval=1, group="âš¡ USI Quantum Pulse")

//====================
// Inputs â€” Exit Filters
//====================
grp_exit = "Exit Filters (Confidence)"
chochGraceBars = input.int(2, "ChoCH Exit Grace (bars)", minval=0, maxval=10, group=grp_exit, tooltip="Min bars after entry before ChoCH can trigger an exit. Prevents same-bar exit.")
exitConfChoCh = input.float(0.0, "Confirm ChoCh (Min Prob)", minval=0.0, maxval=1.0, step=0.05, group=grp_exit, tooltip="Only exit LONG positions on Bearish ChoCh if the reversal probability (pD) is above this level. Bullish ChoCh exits are not filtered.")
exitConfTP    = input.float(1.0, "Hold TP (Min Trend Conf)", minval=0.0, maxval=1.0, step=0.05, group=grp_exit, tooltip="Ignore TP levels allows winning trades to run if confidence remains above this level (1.0 = off).")

//====================
// Calibration storage â€” TfState UDT (replaces 100+ global arrays)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    float[] cntN
    float[] upN
    float[] dnN
    float[] cnt1
    float[] up1
    float[] dn1
    float[] cntN_bull
    float[] upN_bull
    float[] dnN_bull
    float[] cntN_bear
    float[] upN_bear
    float[] dnN_bear
    float[] cnt1_bull
    float[] up1_bull
    float[] dn1_bull
    float[] cnt1_bear
    float[] up1_bear
    float[] dn1_bear
    // Queues
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    int[]   qBias
    bool[]  qUseForecast  // forecast-eligible flag captured at enqueue time
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    float[] qPUpN
    float[] qPFlN
    float[] qPDnN
    float[] qPUp1
    float[] qPFl1
    float[] qPDn1
    float[] qZUpN
    float[] qZFlN
    float[] qZDnN
    float[] qZUp1
    float[] qZFl1
    float[] qZDn1
    // Stats
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    float[] tempN
    float[] temp1
    float[] vecAN
    float[] vecBN
    float[] vecA1
    float[] vecB1
    float[] tempN_bull
    float[] temp1_bull
    float[] vecAN_bull
    float[] vecBN_bull
    float[] vecA1_bull
    float[] vecB1_bull
    float[] tempN_bear
    float[] temp1_bear
    float[] vecAN_bear
    float[] vecBN_bear
    float[] vecA1_bear
    float[] vecB1_bear
    // Evaluation N
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    // Evaluation 1
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1
    // Raw (non-decayed) counts for CI/coverage
    float[] cntN_raw
    float[] upN_raw
    float[] dnN_raw
    float[] cnt1_raw
    float[] up1_raw
    float[] dn1_raw
    float[] cntN_bull_raw
    float[] upN_bull_raw
    float[] dnN_bull_raw
    float[] cntN_bear_raw
    float[] upN_bear_raw
    float[] dnN_bear_raw
    float[] cnt1_bull_raw
    float[] up1_bull_raw
    float[] dn1_bull_raw
    float[] cnt1_bear_raw
    float[] up1_bear_raw
    float[] dn1_bear_raw
    // A2 â€“ SGD Momentum buffers (Adam-lite)
    float[] momPlattN  // [mom_a, mom_b]
    float[] momPlatt1  // [mom_a, mom_b]
    // Quantile bins (per horizon)
    float[] qScoreBuf
    float[] qCutsN
    float[] qCuts1
    // --- Baseline comparators (Uniform + Prior) ---
    // Uniform baseline
    float[] evBrierBaseU_N
    float[] evSumBrierBaseU_N
    float[] evLogBaseU_N
    float[] evSumLogBaseU_N
    float[] evBrierBaseU_1
    float[] evSumBrierBaseU_1
    float[] evLogBaseU_1
    float[] evSumLogBaseU_1
    // Prior baseline (Laplace-smoothed rolling prior)
    float[] evBrierBaseP_N
    float[] evSumBrierBaseP_N
    float[] evLogBaseP_N
    float[] evSumLogBaseP_N
    float[] evBrierBaseP_1
    float[] evSumBrierBaseP_1
    float[] evLogBaseP_1
    float[] evSumLogBaseP_1
    // Prior outcome counts [nUp, nFlat, nDown]
    float[] priorCounts3
    // --- Eligible population (Variant B active at enqueue) ---
    // Model eligible
    float[] evBrierN_Elig
    float[] evSumBrierN_Elig
    float[] evLogN_Elig
    float[] evSumLogN_Elig
    float[] evBrier1_Elig
    float[] evSumBrier1_Elig
    float[] evLog1_Elig
    float[] evSumLog1_Elig
    // Uniform baseline eligible
    float[] evBrierBaseU_N_Elig
    float[] evSumBrierBaseU_N_Elig
    float[] evLogBaseU_N_Elig
    float[] evSumLogBaseU_N_Elig
    // Prior baseline eligible (head-independent: prior uses outcome
    // frequencies only, so one track serves both N and 1 heads)
    float[] evBrierBaseP_N_Elig
    float[] evSumBrierBaseP_N_Elig
    float[] evLogBaseP_N_Elig
    float[] evSumLogBaseP_N_Elig
    // Eligible prior outcome counts (shared across heads)
    float[] priorCounts3_Elig
    // Coverage & skip diagnostics
    int enqCount
    int resolvedScored
    int enqCountElig
    int resolvedScoredElig
    int skipBias0
    int skipAtrInvalid
    int skipIgnore
    int skipTieNeutral2Way
    int skipTotalElig
    int skipBias0Elig
    int skipAtrInvalidElig
    int skipIgnoreElig
    int skipTieNeutral2WayElig
    float[] ageAtResolve
    float[] sumAgeResolve
    int prevQDepth

// Helper to initialize TfState
f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_int(), array.new_int(),
    array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
            array.new_int(),
            array.new_bool(),
        array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.from(1.0, 0.0), array.from(1.0, 0.0),
    array.from(1.0), array.from(1.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0), array.from(1.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0), array.from(1.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
    array.new_int(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
    array.new_int(), array.new_float(), array.new_float(),
    // Raw (non-decayed) counts
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.new_float(), array.new_float(int(math.max(nBinsN - 1, 0)), na), array.new_float(int(math.max(nBins1 - 1, 0)), na),
    // --- Baseline comparators ---
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(3, 0.0),
    // --- Eligible population ---
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(3, 0.0),
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    array.new_float(),
    array.new_float(1, 0.0),
    na
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)

//====================
// Helpers
//====================
// --- Sum int array (total resolved samples across all bins)
f_sum_int_array(a) =>
    float s = 0.0
    for i = 0 to array.size(a) - 1
        s += array.get(a, i)
    s

// --- Safe array removal helpers
f_safe_remove_float(float[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

f_safe_remove_int(int[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

f_safe_remove_bool(bool[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

// --- Safe array access helpers
f_safe_get_float(float[] arr, int idx, float fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

f_safe_get_int(int[] arr, int idx, int fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

f_safe_get_bool(bool[] arr, int idx, bool fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

// --- TF selector helpers (avoid long ternary chains)
// Pine Script lacks generics, so one copy per return type is required.
f_sel_tf_str(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

f_sel_tf_float(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

f_sel_tf_bool(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

f_sel_tf_farr(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

// --- Update quantile cutpoints (score dimension)
f_fill_cuts(sorted, cuts, bins) =>
    cutCount = bins - 1
    if cutCount > 0
        n = array.size(sorted)
        for i = 0 to cutCount - 1
            frac = (i + 1.0) / bins
            idx = int(math.floor(frac * (n - 1)))
            array.set(cuts, i, array.get(sorted, idx))

// Forecast binning (fallback: fixed width)
f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = int(math.floor(u * bins))
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b

// Quantile cutpoints are recalculated every `quantileUpdate` bars once
// `quantileMinSamples` scores have been collected. Until then, uniform
// (equal-width) binning is used as the warm-up fallback.
f_update_quantiles(TfState st, score) =>
    if useQuantileBins and (calibrateInBackground or showTable or showEvalSection)
        array.push(st.qScoreBuf, score)
        if array.size(st.qScoreBuf) > quantileWindow
            array.shift(st.qScoreBuf)
        if bar_index % quantileUpdate == 0 and array.size(st.qScoreBuf) >= quantileMinSamples
            tmp = array.copy(st.qScoreBuf)
            array.sort(tmp, order.ascending)
            f_fill_cuts(tmp, st.qCutsN, predBinsN)
            f_fill_cuts(tmp, st.qCuts1, predBins1)

f_bin_quantile(score, cuts, bins) =>
    if (not useQuantileBins) or array.size(cuts) == 0 or na(array.get(cuts, 0))
        f_bin(score, bins)
    else
        b = 0
        for i = 0 to array.size(cuts) - 1
            if score <= array.get(cuts, i)
                b := i
                break
            else
                b := i + 1
        math.max(0, math.min(bins - 1, b))

f_regime_bin(trendScore) =>
    trendScore > 0.5 ? 2 : trendScore < -0.5 ? 0 : 1

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

// @function Clamp value to arbitrary [lo, hi] range
// @param val Value to clamp
// @param lo Minimum bound
// @param hi Maximum bound
// @returns Clamped value
f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_min_sec(a, b) =>
    na(a) ? b : na(b) ? a : math.min(a, b)

f_forecast_allowed() =>
    baseSec = timeframe.in_seconds(timeframe.period)
    s1 = timeframe.in_seconds(tfF1)
    s2 = timeframe.in_seconds(tfF2)
    s3 = timeframe.in_seconds(tfF3)
    s4 = timeframe.in_seconds(tfF4)
    s5 = timeframe.in_seconds(tfF5)
    s6 = timeframe.in_seconds(tfF6)
    s7 = timeframe.in_seconds(tfF7)
    minSec = f_min_sec(s1, f_min_sec(s2, f_min_sec(s3, f_min_sec(s4, f_min_sec(s5, f_min_sec(s6, s7))))))
    if na(baseSec) or na(minSec)
        allowForecastOnNonFixed
    else
        baseSec <= minSec

f_eval_mode_allow() =>
    barstate.isconfirmed and ((evalMode != "LiveOnly") or barstate.isrealtime)

f_tf_from_horizon(h) =>
    if h == "F1"
        tfF1
    else if h == "F2"
        tfF2
    else if h == "F3"
        tfF3
    else if h == "F4"
        tfF4
    else if h == "F5"
        tfF5
    else if h == "F6"
        tfF6
    else
        tfF7

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" : tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  : tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "â€”" : v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") : v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") : v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") : str.tostring(v, "#")

// Map a TF into your "Fast/Mid/Slow" profiles.
f_profile(tf) =>
    s = timeframe.in_seconds(tf)
    not na(s) and s <= SEC_5M ? "Fast" : not na(s) and s <= SEC_1H ? "Mid" : "Slow"

// Pick which target is active for that TF profile.
f_target_for_tf(tf) =>
    prof = f_profile(tf)
    prof == "Fast" ? fcTargetF : prof == "Mid" ? fcTargetM : fcTargetS

f_apply_tp_sl_preset(baseTp, baseSl) =>
    tpEff = tpPreset30m == "Manual" ? baseTp : tpPreset30m == "Conservative" ? 2.5 : tpPreset30m == "Balanced" ? 3.0 : tpPreset30m == "Runner" ? 3.8 : 4.4
    slEff = tpPreset30m == "Manual" ? baseSl : tpPreset30m == "Conservative" ? 1.1 : tpPreset30m == "Balanced" ? 1.0 : tpPreset30m == "Runner" ? 0.85 : 0.75
    [tpEff, slEff]

f_dyn_sl_preset_vals(baseStop, baseTrail) =>
    dStop = dynSlPreset30m == "Manual" ? baseStop : dynSlPreset30m == "Conservative" ? 1.00 : dynSlPreset30m == "Balanced" ? 0.90 : dynSlPreset30m == "Runner" ? 0.75 : 0.65
    dTrail = dynSlPreset30m == "Manual" ? baseTrail : dynSlPreset30m == "Conservative" ? 2.30 : dynSlPreset30m == "Balanced" ? 2.00 : dynSlPreset30m == "Runner" ? 1.70 : 1.40
    [dStop, dTrail]

f_ci95_halfwidth(p, n) =>
    if na(p) or na(n) or n <= 0
        na
    else
        z2 = Z_95 * Z_95
        den = 1.0 + z2 / n
        half = (Z_95 * math.sqrt((p * (1.0 - p) / n) + (z2 / (4.0 * n * n)))) / den
        half

f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= HW_STRONG ? "strong" : hw <= HW_OK ? "ok" : "weak"
    lbl

// D1 â€“ Continuous trend strength [-1, 1] (smooth alternative to discrete f_trend_regime)
f_trend_strength(emaF, emaS) =>
    emaDiff = (emaF - emaS) / math.max(nz(emaS, 1), PRICE_EPS)
    math.max(-1.0, math.min(1.0, emaDiff / math.max(SIDEWAYS_EMA_THRESH, PRICE_EPS)))

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    // B1 â€“ Continuous trend: smooth EMA gap vs binary
    trend = useSmoothTrend ? f_trend_strength(emaF_tf, emaS_tf) : (emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0)
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = (not na(sec)) and sec <= SEC_5M // <= 5m
    isMid  = (not na(sec)) and sec <= SEC_1H // <= 1h
    baseTp = isFast ? tpATRF : isMid ? tpATRM : tpATRS
    baseSl = isFast ? slATRF : isMid ? slATRM : slATRS
    [tpEff, slEff] = f_apply_tp_sl_preset(baseTp, baseSl)
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     tpEff,
     slEff]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    // Clamp output to prevent extreme values
    math.max(-LOGIT_CLAMP, math.min(LOGIT_CLAMP, math.log(pc / (1.0 - pc))))

f_sigmoid(x) =>
    // Prevent overflow for extreme x values
    x < -500 ? 0.0 : x > 500 ? 1.0 : 1.0 / (1.0 + math.exp(-x))

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Bias -1 (Bear): mirror logic; Bias 0 (neutral): return 0
    bias == 1 ? (c > ef ? 0.5 : c > es ? 1.0 : -1.0) : bias == -1 ? (c < ef ? 0.5 : c < es ? 1.0 : -1.0) : 0.0

// @function Computes trend regime score (bull/bear/sideways)
// @param emaF Fast EMA value
// @param emaS Slow EMA value
// @param atrNorm ATR normalized by close (for sideways detection)
// @returns Score in [-1, 1]: +1=bull, -1=bear, 0=sideways/choppy
f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / math.max(nz(emaS, 1), PRICE_EPS)
    // Strong trend: EMAs diverging significantly (>0.5% gap)
    // Sideways: EMAs close together AND low volatility
    isSideways = math.abs(emaDiff) < SIDEWAYS_EMA_THRESH and atrNorm < SIDEWAYS_ATR_THRESH
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Vol Regime Score (-1..1)
    // sD: Trend Regime Score (-1..1): bull/bear/sideways
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// B2 â€“ ROC (Rate of Change) score: momentum via price change [-1, 1]
f_roc_score(c, rocL) =>
    roc = ta.roc(c, rocL)
    r = na(roc) ? 0.0 : roc
    // Normalise: Â±5% => Â±1
    math.max(-1.0, math.min(1.0, r / 5.0))

// B4 â€“ Volume score: above/below SMA [-1, 1]
f_vol_score(vol, volSmaLen) =>
    if na(vol) or vol == 0
        0.0
    else
        sma = ta.sma(vol, volSmaLen)
        ratio = na(sma) or sma == 0.0 ? 0.0 : (vol / sma - 1.0)
        math.max(-1.0, math.min(1.0, ratio))

// --- Phase 2 Helpers: 2D Binning ---
// @function Computes 2D bin index from score and trend regime
// @param score Ensemble score in [-1, 1]
// @param trendScore Trend regime score in [-1, 1]
// @param binsScore Number of bins for score dimension
// @param binsReg Number of bins for regime dimension (typically 3)
// @param cutsArr Quantile cutpoints for score dimension
// @returns Flattened bin index
f_bin2D(score, trendScore, binsScore, binsReg, cutsArr) =>
    bS = f_bin_quantile(score, cutsArr, binsScore)
    bR = f_regime_bin(trendScore)
    idx = int(bS * binsReg + bR)
    maxIdx = binsScore * binsReg - 1
    idx < 0 ? 0 : idx > maxIdx ? maxIdx : idx

f_db_mult(tf) =>
    sec = timeframe.in_seconds(tf)
    na(sec) ? deadbandSlow : sec <= SEC_5M ? deadbandFast : sec <= SEC_1H ? deadbandMid : deadbandSlow

f_outcome3(delta, db) =>
    delta > db ? 1 : delta < -db ? -1 : 0

f_bias_from_score(score) =>
    score > 0 ? 1 : score < 0 ? -1 : 0

f_is_bull_bias(score, emaF_tf, emaS_tf) =>
    b = f_bias_from_score(score)
    b == 0 ? (emaF_tf >= emaS_tf) : b == 1

f_decay_counts(cntArr, upArr, dnArr, decay) =>
    if decay < 0.9999
        for i = 0 to array.size(cntArr) - 1
            array.set(cntArr, i, array.get(cntArr, i) * decay)
            array.set(upArr,  i, array.get(upArr,  i) * decay)
            array.set(dnArr,  i, array.get(dnArr,  i) * decay)

f_cal_update3(cntArr, upArr, dnArr, bin, outcome) =>
    if na(bin) or array.size(cntArr) == 0
        na
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
        n0 = array.get(cntArr, b)
        u0 = array.get(upArr,  b)
        d0 = array.get(dnArr,  b)
        array.set(cntArr, b, n0 + 1.0)
        array.set(upArr,  b, u0 + (outcome == 1 ? 1.0 : 0.0))
        array.set(dnArr,  b, d0 + (outcome == -1 ? 1.0 : 0.0))

f_prob3(u, f, d, n, alpha) =>
    denom = n + 3.0 * alpha
    if denom == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [(u + alpha) / denom, (f + alpha) / denom, (d + alpha) / denom]

f_cal_cur3(cntArr, upArr, dnArr, bin, alpha, shrinkK, shrinkReg) =>
    if na(bin) or array.size(cntArr) == 0
        [float(na), float(na), float(na), float(na)]
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b

        n = array.get(cntArr, b)
        u = array.get(upArr,  b)
        d = array.get(dnArr,  b)
        f = math.max(0, n - u - d)

        [pUb_t, pFb_t, pDb_t] = f_prob3(u, f, d, n, alpha)
        pUb = pUb_t
        pFb = pFb_t
        pDb = pDb_t

        regBin = b % dim2Bins
        binsScore = int(array.size(cntArr) / dim2Bins)
        nReg = 0.0
        uReg = 0.0
        dReg = 0.0
        for i = 0 to binsScore - 1
            idx = i * dim2Bins + regBin
            nReg += array.get(cntArr, idx)
            uReg += array.get(upArr,  idx)
            dReg += array.get(dnArr,  idx)
        fReg = math.max(0, nReg - uReg - dReg)
        [pUr_t, pFr_t, pDr_t] = f_prob3(uReg, fReg, dReg, nReg, alpha)
        pUr = pUr_t
        pFr = pFr_t
        pDr = pDr_t

        nBase = array.sum(cntArr)
        uBase = array.sum(upArr)
        dBase = array.sum(dnArr)
        fBase = math.max(0, nBase - uBase - dBase)
        [pU0_t, pF0_t, pD0_t] = f_prob3(uBase, fBase, dBase, nBase, alpha)
        pU0 = pU0_t
        pF0 = pF0_t
        pD0 = pD0_t

        wReg = (shrinkReg <= 0) ? 1.0 : (n / (n + shrinkReg + 0.0))
        pUreg = wReg * pUb + (1.0 - wReg) * pUr
        pFreg = wReg * pFb + (1.0 - wReg) * pFr
        pDreg = wReg * pDb + (1.0 - wReg) * pDr

        w = (shrinkK <= 0) ? 1.0 : (nReg / (nReg + shrinkK + 0.0))
        pU = w * pUreg + (1.0 - w) * pU0
        pF = w * pFreg + (1.0 - w) * pF0
        pD = w * pDreg + (1.0 - w) * pD0

        s = pU + pF + pD
        if s == 0.0
            [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, n]
        else
            [pU / s, pF / s, pD / s, n]

f_safe_log(p) =>
    math.log(math.max(PROB_EPS, p))

f_softmax3(zU, zF, zD) =>
    zMax = math.max(zU, math.max(zF, zD))
    eU = math.exp(zU - zMax)
    eF = math.exp(zF - zMax)
    eD = math.exp(zD - zMax)
    s = eU + eF + eD
    if s == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [eU / s, eF / s, eD / s]

f_can_cal3(nBin) =>
    calibratorMode != "Off" and (not cal3AutoFallback or nBin >= cal3MinSamples)

f_cal_apply(zU, zF, zD, tempArr, aArr, bArr) =>
    zUo = zU
    zFo = zF
    zDo = zD
    if calibratorMode == "Temp"
        t = array.get(tempArr, 0)
        t := t <= 0.0 ? 1.0 : t
        zUo := zU / t
        zFo := zF / t
        zDo := zD / t
    else if calibratorMode == "Vector"
        aU = array.get(aArr, 0)
        aF = array.get(aArr, 1)
        aD = array.get(aArr, 2)
        bU = array.get(bArr, 0)
        bF = array.get(bArr, 1)
        bD = array.get(bArr, 2)
        zUo := aU * zU + bU
        zFo := aF * zF + bF
        zDo := aD * zD + bD
    f_softmax3(zUo, zFo, zDo)

f_epsClamp(p) =>
    eps = PROB_EPS
    math.max(eps, math.min(1.0 - eps, p))

f_brier3(pU, pF, pD, outcome) =>
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0
    ((pU - yU) * (pU - yU) + (pF - yF) * (pF - yF) + (pD - yD) * (pD - yD)) / 3.0

f_logloss3(pU, pF, pD, outcome) =>
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD
    -math.log(f_epsClamp(pTrue))

f_prior3(tf, outScore) =>
    sec = timeframe.in_seconds(tf)
    isFast = (not na(sec)) and sec <= SEC_5M
    isMid  = (not na(sec)) and sec <= SEC_1H
    baseFlat = isFast ? flatPriorFast : isMid ? flatPriorMid : flatPriorSlow
    tiltMax  = isFast ? tiltMaxFast  : isMid ? tiltMaxMid  : tiltMaxSlow

    baseSide = (1.0 - baseFlat) * 0.5
    tilt = f_clamp(outScore, -1.0, 1.0) * tiltMax

    pU = f_clamp(baseSide + tilt, 0.0, 1.0)
    pD = f_clamp(baseSide - tilt, 0.0, 1.0)
    pF = f_clamp(baseFlat, 0.0, 1.0)

    s = pU + pF + pD
    if s == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [pU / s, pF / s, pD / s]

f_blend_prior(pU, pF, pD, pUpr, pFpr, pDpr, nRaw) =>
    eff = na(nRaw) ? 0.0 : nRaw
    w = calMinSamples <= 0 ? 1.0 : math.min(1.0, math.max(0.0, eff / calMinSamples))
    [pU * w + pUpr * (1.0 - w),
     pF * w + pFpr * (1.0 - w),
     pD * w + pDpr * (1.0 - w)]

f_samp_label(enabled, total) =>
    not enabled ? "off" : total < calMinSamples ? "â€¦" : total < calMinSamples * 3 ? "ok" : "strong"

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

f_tf_pack(tf) =>
    [t, c, h, l, ef, es, r, a, vr] = request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(ta.atr(atrLen) / math.max(close, PRICE_EPS), volRankLen)],
        barmerge.gaps_off,
        barmerge.lookahead_off
    )
    // NOTE: barstate.isconfirmed moved outside request.security() to avoid
    //       TradingView repainting warning that blocks alert creation.
    // Patch A: Return clear HTF data (without forced LTF confirmation boolean)
    [t, c, h, l, ef, es, r, a, vr]

f_score_tf(c, ef, es, r) =>
    f_state_score(c, ef, es, r)

// @function Computes Laplace-smoothed probability with division safety
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter (default typically 1.0)
// @returns Probability in (0, 1), defaults to 0.5 if denominator is zero
f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_update(cntArr, upArr, bin, isUp) =>
    if na(bin) or array.size(cntArr) == 0
        na
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
        n0 = array.get(cntArr, b)
        u0 = array.get(upArr,  b)
        array.set(cntArr, b, n0 + 1.0)
        array.set(upArr,  b, u0 + (isUp ? 1.0 : 0.0))

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Clamp bin to valid range (defensive, mirrors f_cal_update)
    b = int(bin)
    maxIdx = array.size(cntArr) - 1
    b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
    // Bin raw
    n = array.get(cntArr, b)
    u = array.get(upArr,  b)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "â€”" : n < calMinSamples ? "â€¦" : pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) : n < calMinSamples ? color.new(color.white, 60) : pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_brier(p, y) =>
    d = p - y
    d * d

f_logloss(p, y) =>
    pc = f_epsClamp(p)
    if na(pc) or na(y)
        float(na)
    else
        -(y * math.log(pc) + (1.0 - y) * math.log(1.0 - pc))

f_update_accum_stats(statsArr, val) =>
    if not na(val)
        curSum = array.get(statsArr, 0)
        curCnt = array.get(statsArr, 1)
        array.set(statsArr, 0, curSum + val)
        array.set(statsArr, 1, curCnt + 1.0)

f_roll_add(buf, sumArr, v, maxLen) =>
    array.push(buf, v)
    array.set(sumArr, 0, array.get(sumArr, 0) + v)
    if array.size(buf) > maxLen
        old = array.shift(buf)
        array.set(sumArr, 0, array.get(sumArr, 0) - old)
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(buf) > 0
        array.set(sumArr, 0, array.sum(buf))

// @function Reset single-element sum arrays safely
// @param sumArr Single-element array holding running sum
f_reset_sum1(sumArr) =>
    if array.size(sumArr) == 0
        array.push(sumArr, 0.0)
    else
        array.set(sumArr, 0, 0.0)

f_bucket(p, B) =>
    b = int(math.floor(p * B))
    b < 0 ? 0 : b > (B - 1) ? (B - 1) : b

f_cal_roll_update(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, p, y, maxLen) =>
    B = array.size(calCnt)
    bi = f_bucket(p, B)

    array.push(bBuf, bi)
    array.push(pBuf, p)
    array.push(yBuf, y)

    array.set(calCnt,  bi, array.get(calCnt,  bi) + 1)
    array.set(calSumP, bi, array.get(calSumP, bi) + p)
    array.set(calSumY, bi, array.get(calSumY, bi) + y)

    if array.size(bBuf) > maxLen
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_cal_roll_update3(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, pU, pF, pD, outcome, maxLen) =>
    B = evalBuckets
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0

    biU = f_bucket(pU, B)
    biF = f_bucket(pF, B)
    biD = f_bucket(pD, B)

    idxU = 0 * B + biU
    idxF = 1 * B + biF
    idxD = 2 * B + biD

    array.push(bBuf, idxU), array.push(pBuf, pU), array.push(yBuf, yU)
    array.push(bBuf, idxF), array.push(pBuf, pF), array.push(yBuf, yF)
    array.push(bBuf, idxD), array.push(pBuf, pD), array.push(yBuf, yD)

    array.set(calCnt,  idxU, array.get(calCnt,  idxU) + 1)
    array.set(calSumP, idxU, array.get(calSumP, idxU) + pU)
    array.set(calSumY, idxU, array.get(calSumY, idxU) + yU)

    array.set(calCnt,  idxF, array.get(calCnt,  idxF) + 1)
    array.set(calSumP, idxF, array.get(calSumP, idxF) + pF)
    array.set(calSumY, idxF, array.get(calSumY, idxF) + yF)

    array.set(calCnt,  idxD, array.get(calCnt,  idxD) + 1)
    array.set(calSumP, idxD, array.get(calSumP, idxD) + pD)
    array.set(calSumY, idxD, array.get(calSumY, idxD) + yD)

    maxLen3 = maxLen * 3
    while array.size(bBuf) > maxLen3
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_eval_stats_one(brierBuf, sumBrier, logBuf, sumLog, ySBuf, sumYS, yLBuf, sumYL, calCnt, calSumP, calSumY) =>
    nScore = array.size(brierBuf)
    brierAvg = nScore == 0 ? na : array.get(sumBrier, 0) / nScore
    logAvg   = nScore == 0 ? na : array.get(sumLog,   0) / nScore

    nS = array.size(ySBuf)
    nL = array.size(yLBuf)
    wS = nS == 0 ? na : array.get(sumYS, 0) / nS
    wL = nL == 0 ? na : array.get(sumYL, 0) / nL
    drift = (na(wS) or na(wL)) ? na : (wS - wL)

    ece = float(na)
    maxErr = float(na)
    B = evalBuckets
    sizeCnt = array.size(calCnt)
    if sizeCnt == B
        tot = 0
        for i = 0 to sizeCnt - 1
            tot += array.get(calCnt, i)
        if tot > 0
            e = 0.0
            m = 0.0
            for i = 0 to sizeCnt - 1
                c = array.get(calCnt, i)
                if c > 0
                    ap = array.get(calSumP, i) / c
                    ay = array.get(calSumY, i) / c
                    err = math.abs(ap - ay)
                    e += err * (c / tot)
                    m := math.max(m, err)
            ece := e
            maxErr := m
    else if sizeCnt == B * 3
        eTot = 0.0
        mTot = 0.0
        for cls = 0 to 2
            totC = 0
            for i = 0 to B - 1
                totC += array.get(calCnt, cls * B + i)
            if totC > 0
                eC = 0.0
                mC = 0.0
                for i = 0 to B - 1
                    idx = cls * B + i
                    c = array.get(calCnt, idx)
                    if c > 0
                        ap = array.get(calSumP, idx) / c
                        ay = array.get(calSumY, idx) / c
                        err = math.abs(ap - ay)
                        eC += err * (c / totC)
                        mC := math.max(mC, err)
                eTot += eC
                mTot := math.max(mTot, mC)
        ece := eTot / 3.0
        maxErr := mTot

    [brierAvg, logAvg, ece, maxErr, wS, wL, drift, nScore]

f_eval_update_one(p, y,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: section visible/background + confirmed bar + mode gate.
    evalAllow = f_eval_mode_allow()
    canEval = (showEvalSection or evalInBackground) and evalAllow
    if canEval
        pc = f_epsClamp(p)

        f_roll_add(brierBuf, sumBrier, f_brier(pc, y), evalRollScore)
        f_roll_add(logBuf,   sumLog,   f_logloss(pc, y), evalRollScore)

        f_roll_add(ySBuf, sumYS, y, evalRollShort)
        f_roll_add(yLBuf, sumYL, y, evalRollLong)

        f_cal_roll_update(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pc, y, evalRollScore)

f_eval_update_one3(pU, pF, pD, outcome,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: section visible/background + confirmed bar + mode gate.
    evalAllow = f_eval_mode_allow()
    canEval = (showEvalSection or evalInBackground) and evalAllow
    if canEval
        b3 = f_brier3(pU, pF, pD, outcome)
        ll = f_logloss3(pU, pF, pD, outcome)
        yUp = outcome == 1 ? 1.0 : 0.0

        f_roll_add(brierBuf, sumBrier, b3, evalRollScore)
        f_roll_add(logBuf,   sumLog,   ll, evalRollScore)

        f_roll_add(ySBuf, sumYS, yUp, evalRollShort)
        f_roll_add(yLBuf, sumYL, yUp, evalRollLong)

        f_cal_roll_update3(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pU, pF, pD, outcome, evalRollScore)

f_eval_on_resolve(TfState st, pPredN, pPred1, isUp) =>
    y = isUp ? 1.0 : 0.0

    f_eval_update_one(pPredN, y, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
    f_eval_update_one(pPred1, y, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

// Table Helpers
f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0.0), array.fill(st.upN, 0.0), array.fill(st.dnN, 0.0)
    array.fill(st.cnt1, 0.0), array.fill(st.up1, 0.0), array.fill(st.dn1, 0.0)
    array.fill(st.cntN_bull, 0.0), array.fill(st.upN_bull, 0.0), array.fill(st.dnN_bull, 0.0)
    array.fill(st.cntN_bear, 0.0), array.fill(st.upN_bear, 0.0), array.fill(st.dnN_bear, 0.0)
    array.fill(st.cnt1_bull, 0.0), array.fill(st.up1_bull, 0.0), array.fill(st.dn1_bull, 0.0)
    array.fill(st.cnt1_bear, 0.0), array.fill(st.up1_bear, 0.0), array.fill(st.dn1_bear, 0.0)
    array.fill(st.cntN_raw, 0.0), array.fill(st.upN_raw, 0.0), array.fill(st.dnN_raw, 0.0)
    array.fill(st.cnt1_raw, 0.0), array.fill(st.up1_raw, 0.0), array.fill(st.dn1_raw, 0.0)
    array.fill(st.cntN_bull_raw, 0.0), array.fill(st.upN_bull_raw, 0.0), array.fill(st.dnN_bull_raw, 0.0)
    array.fill(st.cntN_bear_raw, 0.0), array.fill(st.upN_bear_raw, 0.0), array.fill(st.dnN_bear_raw, 0.0)
    array.fill(st.cnt1_bull_raw, 0.0), array.fill(st.up1_bull_raw, 0.0), array.fill(st.dn1_bull_raw, 0.0)
    array.fill(st.cnt1_bear_raw, 0.0), array.fill(st.up1_bear_raw, 0.0), array.fill(st.dn1_bear_raw, 0.0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    array.clear(st.qBias)
    array.clear(st.qUseForecast)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    array.clear(st.qPUpN)
    array.clear(st.qPFlN)
    array.clear(st.qPDnN)
    array.clear(st.qPUp1)
    array.clear(st.qPFl1)
    array.clear(st.qPDn1)
    array.clear(st.qZUpN)
    array.clear(st.qZFlN)
    array.clear(st.qZDnN)
    array.clear(st.qZUp1)
    array.clear(st.qZFl1)
    array.clear(st.qZDn1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)
    array.set(st.tempN, 0, 1.0)
    array.set(st.temp1, 0, 1.0)
    array.set(st.vecAN, 0, 1.0)
    array.set(st.vecAN, 1, 1.0)
    array.set(st.vecAN, 2, 1.0)
    array.set(st.vecBN, 0, 0.0)
    array.set(st.vecBN, 1, 0.0)
    array.set(st.vecBN, 2, 0.0)
    array.set(st.vecA1, 0, 1.0)
    array.set(st.vecA1, 1, 1.0)
    array.set(st.vecA1, 2, 1.0)
    array.set(st.vecB1, 0, 0.0)
    array.set(st.vecB1, 1, 0.0)
    array.set(st.vecB1, 2, 0.0)

    array.set(st.tempN_bull, 0, 1.0)
    array.set(st.temp1_bull, 0, 1.0)
    array.set(st.vecAN_bull, 0, 1.0)
    array.set(st.vecAN_bull, 1, 1.0)
    array.set(st.vecAN_bull, 2, 1.0)
    array.set(st.vecBN_bull, 0, 0.0)
    array.set(st.vecBN_bull, 1, 0.0)
    array.set(st.vecBN_bull, 2, 0.0)
    array.set(st.vecA1_bull, 0, 1.0)
    array.set(st.vecA1_bull, 1, 1.0)
    array.set(st.vecA1_bull, 2, 1.0)
    array.set(st.vecB1_bull, 0, 0.0)
    array.set(st.vecB1_bull, 1, 0.0)
    array.set(st.vecB1_bull, 2, 0.0)

    array.set(st.tempN_bear, 0, 1.0)
    array.set(st.temp1_bear, 0, 1.0)
    array.set(st.vecAN_bear, 0, 1.0)
    array.set(st.vecAN_bear, 1, 1.0)
    array.set(st.vecAN_bear, 2, 1.0)
    array.set(st.vecBN_bear, 0, 0.0)
    array.set(st.vecBN_bear, 1, 0.0)
    array.set(st.vecBN_bear, 2, 0.0)
    array.set(st.vecA1_bear, 0, 1.0)
    array.set(st.vecA1_bear, 1, 1.0)
    array.set(st.vecA1_bear, 2, 1.0)
    array.set(st.vecB1_bear, 0, 0.0)
    array.set(st.vecB1_bear, 1, 0.0)
    array.set(st.vecB1_bear, 2, 0.0)

    array.clear(st.qScoreBuf)
    array.fill(st.qCutsN, na)
    array.fill(st.qCuts1, na)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN)
    f_reset_sum1(st.evSumBrierN)
    array.clear(st.evLogN)
    f_reset_sum1(st.evSumLogN)
    array.clear(st.evYS_N)
    f_reset_sum1(st.evSumYS_N)
    array.clear(st.evYL_N)
    f_reset_sum1(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1)
    f_reset_sum1(st.evSumBrier1)
    array.clear(st.evLog1)
    f_reset_sum1(st.evSumLog1)
    array.clear(st.evYS_1)
    f_reset_sum1(st.evSumYS_1)
    array.clear(st.evYL_1)
    f_reset_sum1(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)
    // Baseline comparators
    array.clear(st.evBrierBaseU_N), f_reset_sum1(st.evSumBrierBaseU_N)
    array.clear(st.evLogBaseU_N),   f_reset_sum1(st.evSumLogBaseU_N)
    array.clear(st.evBrierBaseU_1), f_reset_sum1(st.evSumBrierBaseU_1)
    array.clear(st.evLogBaseU_1),   f_reset_sum1(st.evSumLogBaseU_1)
    array.clear(st.evBrierBaseP_N), f_reset_sum1(st.evSumBrierBaseP_N)
    array.clear(st.evLogBaseP_N),   f_reset_sum1(st.evSumLogBaseP_N)
    array.clear(st.evBrierBaseP_1), f_reset_sum1(st.evSumBrierBaseP_1)
    array.clear(st.evLogBaseP_1),   f_reset_sum1(st.evSumLogBaseP_1)
    array.fill(st.priorCounts3, 0.0)
    // Eligible population
    array.clear(st.evBrierN_Elig), f_reset_sum1(st.evSumBrierN_Elig)
    array.clear(st.evLogN_Elig),   f_reset_sum1(st.evSumLogN_Elig)
    array.clear(st.evBrier1_Elig), f_reset_sum1(st.evSumBrier1_Elig)
    array.clear(st.evLog1_Elig),   f_reset_sum1(st.evSumLog1_Elig)
    array.clear(st.evBrierBaseU_N_Elig), f_reset_sum1(st.evSumBrierBaseU_N_Elig)
    array.clear(st.evLogBaseU_N_Elig),   f_reset_sum1(st.evSumLogBaseU_N_Elig)
    array.clear(st.evBrierBaseP_N_Elig), f_reset_sum1(st.evSumBrierBaseP_N_Elig)
    array.clear(st.evLogBaseP_N_Elig),   f_reset_sum1(st.evSumLogBaseP_N_Elig)
    array.fill(st.priorCounts3_Elig, 0.0)
    // Coverage & skip diagnostics
    st.enqCount := 0, st.resolvedScored := 0
    st.enqCountElig := 0, st.resolvedScoredElig := 0
    st.skipBias0 := 0, st.skipAtrInvalid := 0, st.skipIgnore := 0, st.skipTieNeutral2Way := 0, st.skipTotalElig := 0
    st.skipBias0Elig := 0, st.skipAtrInvalidElig := 0, st.skipIgnoreElig := 0, st.skipTieNeutral2WayElig := 0
    array.clear(st.ageAtResolve), f_reset_sum1(st.sumAgeResolve)
    st.prevQDepth := na

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// A5 â€“ ECE-triggered recalibration: boost Platt LR when model is poorly calibrated
var float prevEvalEce = na
lrPlattEff = lrPlatt
if useEceRecal and not na(prevEvalEce) and prevEvalEce >= eceWarn
    lrPlattEff := math.min(lrPlatt * eceRecalBoost, 0.05)

// Process one TF calibration step (updates on TF close)
// @param _hid Horizon ID (1-7) - reserved for debugging/logging
f_process_tf(_hid, _tf, tfBarConfirmed, sA, 
            cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
            TfState st,
            fcTgt, kB, aThr, pH, tpA, slA,
            alphaNVal, alpha1Val, shrinkKVal, wStateVal, wPullbackVal, wRegimeVal, wTrendVal) =>

    if tfBarConfirmed
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = f_safe_get_int(st.qAge,   i, 0)
            entry_i = f_safe_get_float(st.qEntry, i, na)
            atr_i   = f_safe_get_float(st.qAtr,   i, na)
            mh_i    = f_safe_get_float(st.qMaxH,  i, na)
            ml_i    = f_safe_get_float(st.qMinL,  i, na)
            bN_i    = f_safe_get_int(st.qBinN,  i, 0)
            b1_i    = f_safe_get_int(st.qBin1,  i, 0)
            bias_i  = f_safe_get_int(st.qBias,  i, 0)
            useFc_i = f_safe_get_bool(st.qUseForecast, i, false)

            // Stored at entry
            float probN_i = na
            float prob1_i = na
            float lgtN_i = na
            float lgt1_i = na
            float predN_i = na
            float pred1_i = na
            if not use3Way
                probN_i := f_safe_get_float(st.qProbN,  i, na)
                prob1_i := f_safe_get_float(st.qProb1,  i, na)
                lgtN_i  := f_safe_get_float(st.qLogitN, i, na)
                lgt1_i  := f_safe_get_float(st.qLogit1, i, na)
                predN_i := f_safe_get_float(st.qPredN,  i, na)
                pred1_i := f_safe_get_float(st.qPred1,  i, na)

            // 3-way stored probs/logits
            float pUpN_i = na
            float pFlN_i = na
            float pDnN_i = na
            float pUp1_i = na
            float pFl1_i = na
            float pDn1_i = na
            float zUpN_i = na
            float zFlN_i = na
            float zDnN_i = na
            float zUp1_i = na
            float zFl1_i = na
            float zDn1_i = na
            if use3Way
                pUpN_i := f_safe_get_float(st.qPUpN, i, na)
                pFlN_i := f_safe_get_float(st.qPFlN, i, na)
                pDnN_i := f_safe_get_float(st.qPDnN, i, na)
                pUp1_i := f_safe_get_float(st.qPUp1, i, na)
                pFl1_i := f_safe_get_float(st.qPFl1, i, na)
                pDn1_i := f_safe_get_float(st.qPDn1, i, na)
                zUpN_i := f_safe_get_float(st.qZUpN, i, na)
                zFlN_i := f_safe_get_float(st.qZFlN, i, na)
                zDnN_i := f_safe_get_float(st.qZDnN, i, na)
                zUp1_i := f_safe_get_float(st.qZUp1, i, na)
                zFl1_i := f_safe_get_float(st.qZFl1, i, na)
                zDn1_i := f_safe_get_float(st.qZDn1, i, na)

            resolved = false
            doUpdate = false
            isUp     = false
            int outcome = 0
            int skipReason = 0  // 0=none, 1=bias0, 2=atrInvalid, 3=ignore, 4=tieNeutral2way

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                        skipReason := 2
                    else
                        doUpdate := true
                        if use3Way
                            db = f_db_mult(_tf) * atr_i
                            delta = cNow - entry_i
                            outcome := f_outcome3(delta, db)
                            isUp := outcome == 1
                        else
                            retATR = (cNow - entry_i) / atr_i
                            isUp := retATR >= aThr
                            outcome := isUp ? 1 : -1

            else // PathTPvsSL (directional by stored bias)
                if bias_i == 0
                    if age_i >= pH
                        resolved := true
                        doUpdate := false
                        skipReason := 1
                else if na(atr_i) or atr_i <= 0.0
                    if age_i >= pH
                        resolved := true
                        doUpdate := false
                        skipReason := 2
                else
                    dir = bias_i > 0 ? 1 : -1
                    tpPx = dir == 1 ? (entry_i + tpA * atr_i) : (entry_i - tpA * atr_i)
                    slPx = dir == 1 ? (entry_i - slA * atr_i) : (entry_i + slA * atr_i)
                    winHit  = dir == 1 ? (mh_i >= tpPx) : (ml_i <= tpPx)
                    lossHit = dir == 1 ? (ml_i <= slPx) : (mh_i >= slPx)

                    if winHit or lossHit
                        resolved := true
                        doUpdate := true
                        if winHit and lossHit
                            if pathTiePolicy == "Win"
                                outcome := dir
                            else if pathTiePolicy == "Neutral"
                                if use3Way
                                    outcome := 0
                                else
                                    doUpdate := false
                                    skipReason := 4
                            else
                                outcome := -dir
                            isUp := outcome == 1
                        else
                            outcome := winHit ? dir : -dir
                            isUp := outcome == 1

                    else if age_i >= pH
                        resolved := true
                        if noHitPolicy == "Loss"
                            doUpdate := true
                            outcome := -dir
                            isUp := outcome == 1
                        else if use3Way and noHitPolicy == "Neutral"
                            doUpdate := true
                            outcome := 0
                        else
                            doUpdate := false
                            skipReason := 3

            if resolved
                if doUpdate
                    // Coverage: count scorable resolve + age
                    st.resolvedScored += 1
                    f_roll_add(st.ageAtResolve, st.sumAgeResolve, age_i, evalRollScore)
                    if useFc_i
                        st.resolvedScoredElig += 1
                    if not use3Way
                        outcome := isUp ? 1 : -1
                    if use3Way
                        f_decay_counts(st.cntN, st.upN, st.dnN, countDecay)
                        f_decay_counts(st.cnt1, st.up1, st.dn1, countDecay)
                    f_cal_update3(st.cntN, st.upN, st.dnN, bN_i, outcome)
                    f_cal_update3(st.cnt1, st.up1, st.dn1, b1_i, outcome)
                    f_cal_update3(st.cntN_raw, st.upN_raw, st.dnN_raw, bN_i, outcome)
                    f_cal_update3(st.cnt1_raw, st.up1_raw, st.dn1_raw, b1_i, outcome)

                    if use3Way and useBullBearCal and bias_i != 0
                        useBull = bias_i > 0
                        cntN_sel = useBull ? st.cntN_bull : st.cntN_bear
                        upN_sel  = useBull ? st.upN_bull  : st.upN_bear
                        dnN_sel  = useBull ? st.dnN_bull  : st.dnN_bear
                        cnt1_sel = useBull ? st.cnt1_bull : st.cnt1_bear
                        up1_sel  = useBull ? st.up1_bull  : st.up1_bear
                        dn1_sel  = useBull ? st.dn1_bull  : st.dn1_bear
                        cntN_raw_sel = useBull ? st.cntN_bull_raw : st.cntN_bear_raw
                        upN_raw_sel  = useBull ? st.upN_bull_raw  : st.upN_bear_raw
                        dnN_raw_sel  = useBull ? st.dnN_bull_raw  : st.dnN_bear_raw
                        cnt1_raw_sel = useBull ? st.cnt1_bull_raw : st.cnt1_bear_raw
                        up1_raw_sel  = useBull ? st.up1_bull_raw  : st.up1_bear_raw
                        dn1_raw_sel  = useBull ? st.dn1_bull_raw  : st.dn1_bear_raw
                        f_decay_counts(cntN_sel, upN_sel, dnN_sel, countDecay)
                        f_decay_counts(cnt1_sel, up1_sel, dn1_sel, countDecay)
                        f_cal_update3(cntN_sel, upN_sel, dnN_sel, bN_i, outcome)
                        f_cal_update3(cnt1_sel, up1_sel, dn1_sel, b1_i, outcome)
                        f_cal_update3(cntN_raw_sel, upN_raw_sel, dnN_raw_sel, bN_i, outcome)
                        f_cal_update3(cnt1_raw_sel, up1_raw_sel, dn1_raw_sel, b1_i, outcome)
                    
                    outcomeVal = isUp ? 1.0 : 0.0
                    
                    // --- Evaluation (Live Scoring) ---
                    // Score based on the final prediction we made (predN_i / pred1_i)
                    if use3Way
                        f_eval_update_one3(pUpN_i, pFlN_i, pDnN_i, outcome,
                            st.evBrierN, st.evSumBrierN,
                            st.evLogN, st.evSumLogN,
                            st.evYS_N, st.evSumYS_N,
                            st.evYL_N, st.evSumYL_N,
                            st.evCalCntN, st.evCalSumPN, st.evCalSumYN,
                            st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
                        f_eval_update_one3(pUp1_i, pFl1_i, pDn1_i, outcome,
                            st.evBrier1, st.evSumBrier1,
                            st.evLog1, st.evSumLog1,
                            st.evYS_1, st.evSumYS_1,
                            st.evYL_1, st.evSumYL_1,
                            st.evCalCnt1, st.evCalSumP1, st.evCalSumY1,
                            st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

                        // --- Baseline scoring (same event population, no leakage) ---
                        evalAllow = f_eval_mode_allow()
                        canEvalBase = (showEvalSection or evalInBackground) and evalAllow
                        if canEvalBase
                            // A) Uniform baseline: 1/3 each class
                            uProb = 1.0 / 3.0
                            uB3 = f_brier3(uProb, uProb, uProb, outcome)
                            uLL  = f_logloss3(uProb, uProb, uProb, outcome)
                            f_roll_add(st.evBrierBaseU_N, st.evSumBrierBaseU_N, uB3, evalRollScore)
                            f_roll_add(st.evLogBaseU_N,   st.evSumLogBaseU_N,   uLL, evalRollScore)
                            f_roll_add(st.evBrierBaseU_1, st.evSumBrierBaseU_1, uB3, evalRollScore)
                            f_roll_add(st.evLogBaseU_1,   st.evSumLogBaseU_1,   uLL, evalRollScore)

                            // B) Prior baseline (Laplace / Dirichlet(1,1,1) smoothing)
                            nUp_pr = array.get(st.priorCounts3, 0)
                            nFl_pr = array.get(st.priorCounts3, 1)
                            nDn_pr = array.get(st.priorCounts3, 2)
                            nTot_pr = nUp_pr + nFl_pr + nDn_pr
                            prU = (nUp_pr + 1.0) / (nTot_pr + 3.0)
                            prF = (nFl_pr + 1.0) / (nTot_pr + 3.0)
                            prD = (nDn_pr + 1.0) / (nTot_pr + 3.0)
                            pB3 = f_brier3(prU, prF, prD, outcome)
                            pLL = f_logloss3(prU, prF, prD, outcome)
                            f_roll_add(st.evBrierBaseP_N, st.evSumBrierBaseP_N, pB3, evalRollScore)
                            f_roll_add(st.evLogBaseP_N,   st.evSumLogBaseP_N,   pLL, evalRollScore)
                            f_roll_add(st.evBrierBaseP_1, st.evSumBrierBaseP_1, pB3, evalRollScore)
                            f_roll_add(st.evLogBaseP_1,   st.evSumLogBaseP_1,   pLL, evalRollScore)

                            // Update prior counts AFTER scoring (no leakage)
                            if outcome == 1
                                array.set(st.priorCounts3, 0, nUp_pr + 1.0)
                            else if outcome == 0
                                array.set(st.priorCounts3, 1, nFl_pr + 1.0)
                            else
                                array.set(st.priorCounts3, 2, nDn_pr + 1.0)

                            // --- Eligible population scoring (Variant B active at enqueue) ---
                            if useFc_i
                                // Model eligible
                                b3_eN = f_brier3(pUpN_i, pFlN_i, pDnN_i, outcome)
                                ll_eN = f_logloss3(pUpN_i, pFlN_i, pDnN_i, outcome)
                                f_roll_add(st.evBrierN_Elig, st.evSumBrierN_Elig, b3_eN, evalRollScore)
                                f_roll_add(st.evLogN_Elig,   st.evSumLogN_Elig,   ll_eN, evalRollScore)
                                b3_e1 = f_brier3(pUp1_i, pFl1_i, pDn1_i, outcome)
                                ll_e1 = f_logloss3(pUp1_i, pFl1_i, pDn1_i, outcome)
                                f_roll_add(st.evBrier1_Elig, st.evSumBrier1_Elig, b3_e1, evalRollScore)
                                f_roll_add(st.evLog1_Elig,   st.evSumLog1_Elig,   ll_e1, evalRollScore)
                                // Uniform baseline eligible
                                f_roll_add(st.evBrierBaseU_N_Elig, st.evSumBrierBaseU_N_Elig, uB3, evalRollScore)
                                f_roll_add(st.evLogBaseU_N_Elig,   st.evSumLogBaseU_N_Elig,   uLL, evalRollScore)
                                // Prior baseline eligible (separate prior counts)
                                neUp = array.get(st.priorCounts3_Elig, 0)
                                neFl = array.get(st.priorCounts3_Elig, 1)
                                neDn = array.get(st.priorCounts3_Elig, 2)
                                neTot = neUp + neFl + neDn
                                peU = (neUp + 1.0) / (neTot + 3.0)
                                peF = (neFl + 1.0) / (neTot + 3.0)
                                peD = (neDn + 1.0) / (neTot + 3.0)
                                peB3 = f_brier3(peU, peF, peD, outcome)
                                peLL = f_logloss3(peU, peF, peD, outcome)
                                f_roll_add(st.evBrierBaseP_N_Elig, st.evSumBrierBaseP_N_Elig, peB3, evalRollScore)
                                f_roll_add(st.evLogBaseP_N_Elig,   st.evSumLogBaseP_N_Elig,   peLL, evalRollScore)
                                // Update eligible prior AFTER scoring (no leakage)
                                if outcome == 1
                                    array.set(st.priorCounts3_Elig, 0, neUp + 1.0)
                                else if outcome == 0
                                    array.set(st.priorCounts3_Elig, 1, neFl + 1.0)
                                else
                                    array.set(st.priorCounts3_Elig, 2, neDn + 1.0)
                    else
                        f_eval_on_resolve(st, predN_i, pred1_i, isUp)

                    if use3Way and calibratorMode != "Off"
                        nBinN_cur = array.get(st.cntN, bN_i)
                        nBin1_cur = array.get(st.cnt1, b1_i)
                        canCalN = not cal3AutoFallback or nBinN_cur >= cal3MinSamples
                        canCal1 = not cal3AutoFallback or nBin1_cur >= cal3MinSamples
                        regW_N = calRegStrength * (cal3MinSamples <= 0 ? 0.0 : math.max(0.0, 1.0 - math.min(1.0, nBinN_cur / cal3MinSamples)))
                        regW_1 = calRegStrength * (cal3MinSamples <= 0 ? 0.0 : math.max(0.0, 1.0 - math.min(1.0, nBin1_cur / cal3MinSamples)))
                        yU = outcome == 1 ? 1.0 : 0.0
                        yF = outcome == 0 ? 1.0 : 0.0
                        yD = outcome == -1 ? 1.0 : 0.0
                        tempN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
                        temp1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
                        vecAN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
                        vecBN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
                        vecA1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
                        vecB1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1

                        if calibratorMode == "Temp"
                            if canCalN
                                tN = array.get(tempN_sel, 0)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(zUpN_i / tN, zFlN_i / tN, zDnN_i / tN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                gradN = ((pUNc - yU) * zUpN_i + (pFNc - yF) * zFlN_i + (pDNc - yD) * zDnN_i) / (tN * tN)
                                tN := f_clamp(tN - lrCal * gradN - regW_N * (tN - 1.0), tempMin, tempMax)
                                array.set(tempN_sel, 0, tN)

                            if canCal1
                                t1 = array.get(temp1_sel, 0)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(zUp1_i / t1, zFl1_i / t1, zDn1_i / t1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                grad1 = ((pU1c - yU) * zUp1_i + (pF1c - yF) * zFl1_i + (pD1c - yD) * zDn1_i) / (t1 * t1)
                                t1 := f_clamp(t1 - lrCal * grad1 - regW_1 * (t1 - 1.0), tempMin, tempMax)
                                array.set(temp1_sel, 0, t1)
                        else if calibratorMode == "Vector"
                            if canCalN
                                aUN = array.get(vecAN_sel, 0)
                                aFN = array.get(vecAN_sel, 1)
                                aDN = array.get(vecAN_sel, 2)
                                bUN = array.get(vecBN_sel, 0)
                                bFN = array.get(vecBN_sel, 1)
                                bDN = array.get(vecBN_sel, 2)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(aUN * zUpN_i + bUN, aFN * zFlN_i + bFN, aDN * zDnN_i + bDN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                aUN := f_clamp(aUN - lrCal * (pUNc - yU) * zUpN_i - regW_N * (aUN - 1.0), vecAMin, vecAMax)
                                aFN := f_clamp(aFN - lrCal * (pFNc - yF) * zFlN_i - regW_N * (aFN - 1.0), vecAMin, vecAMax)
                                aDN := f_clamp(aDN - lrCal * (pDNc - yD) * zDnN_i - regW_N * (aDN - 1.0), vecAMin, vecAMax)
                                bUN := f_clamp(bUN - lrCal * (pUNc - yU) - regW_N * bUN, vecBMin, vecBMax)
                                bFN := f_clamp(bFN - lrCal * (pFNc - yF) - regW_N * bFN, vecBMin, vecBMax)
                                bDN := f_clamp(bDN - lrCal * (pDNc - yD) - regW_N * bDN, vecBMin, vecBMax)
                                array.set(vecAN_sel, 0, aUN)
                                array.set(vecAN_sel, 1, aFN)
                                array.set(vecAN_sel, 2, aDN)
                                array.set(vecBN_sel, 0, bUN)
                                array.set(vecBN_sel, 1, bFN)
                                array.set(vecBN_sel, 2, bDN)

                            if canCal1
                                aU1 = array.get(vecA1_sel, 0)
                                aF1 = array.get(vecA1_sel, 1)
                                aD1 = array.get(vecA1_sel, 2)
                                bU1 = array.get(vecB1_sel, 0)
                                bF1 = array.get(vecB1_sel, 1)
                                bD1 = array.get(vecB1_sel, 2)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(aU1 * zUp1_i + bU1, aF1 * zFl1_i + bF1, aD1 * zDn1_i + bD1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                aU1 := f_clamp(aU1 - lrCal * (pU1c - yU) * zUp1_i - regW_1 * (aU1 - 1.0), vecAMin, vecAMax)
                                aF1 := f_clamp(aF1 - lrCal * (pF1c - yF) * zFl1_i - regW_1 * (aF1 - 1.0), vecAMin, vecAMax)
                                aD1 := f_clamp(aD1 - lrCal * (pD1c - yD) * zDn1_i - regW_1 * (aD1 - 1.0), vecAMin, vecAMax)
                                bU1 := f_clamp(bU1 - lrCal * (pU1c - yU) - regW_1 * bU1, vecBMin, vecBMax)
                                bF1 := f_clamp(bF1 - lrCal * (pF1c - yF) - regW_1 * bF1, vecBMin, vecBMax)
                                bD1 := f_clamp(bD1 - lrCal * (pD1c - yD) - regW_1 * bD1, vecBMin, vecBMax)
                                array.set(vecA1_sel, 0, aU1)
                                array.set(vecA1_sel, 1, aF1)
                                array.set(vecA1_sel, 2, aD1)
                                array.set(vecB1_sel, 0, bU1)
                                array.set(vecB1_sel, 1, bF1)
                                array.set(vecB1_sel, 2, bD1)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    if not use3Way
                        nBinN_cur = array.get(st.cntN, bN_i)
                        if nBinN_cur >= calMinSamples
                            // Brier on raw prob
                            sqErrN = math.pow(outcomeVal - probN_i, 2)
                            curSumN = array.get(st.brierStatsN, 0)
                            curCntN = array.get(st.brierStatsN, 1)
                            array.set(st.brierStatsN, 0, curSumN + sqErrN)
                            array.set(st.brierStatsN, 1, curCntN + 1.0)
                            
                            // Platt SGD
                            if usePlatt
                                aN = array.get(st.plattN, 0)
                                bN = array.get(st.plattN, 1)
                                pAdj = f_sigmoid(aN * lgtN_i + bN)
                                err = pAdj - outcomeVal
                                da = err * lgtN_i
                                db = err
                                // A2 â€“ Momentum: EMA of gradients
                                float effDa = da
                                float effDb = db
                                if useSgdMomentum
                                    mA = sgdBeta * array.get(st.momPlattN, 0) + (1.0 - sgdBeta) * da
                                    mB = sgdBeta * array.get(st.momPlattN, 1) + (1.0 - sgdBeta) * db
                                    array.set(st.momPlattN, 0, mA)
                                    array.set(st.momPlattN, 1, mB)
                                    effDa := mA
                                    effDb := mB
                                // Update
                                aN := math.max(0.1, math.min(5.0, aN - lrPlattEff * effDa)) 
                                bN := math.max(-3.0, math.min(3.0, bN - lrPlattEff * effDb))
                                array.set(st.plattN, 0, aN)
                                array.set(st.plattN, 1, bN)
                                
                                // LogLoss
                                ll = f_logloss(pAdj, outcomeVal)
                                f_update_accum_stats(st.llStatsN, ll)
                        
                        // --- Phase 4: SGD Update & LogLoss (1) ---
                        sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                        curSum1 = array.get(st.brierStats1, 0)
                        curCnt1 = array.get(st.brierStats1, 1)
                        array.set(st.brierStats1, 0, curSum1 + sqErr1)
                        array.set(st.brierStats1, 1, curCnt1 + 1.0)

                        if usePlatt
                            pltA1 = array.get(st.platt1, 0)
                            pltB1 = array.get(st.platt1, 1)
                            pAdj1 = f_sigmoid(pltA1 * lgt1_i + pltB1)
                            err1 = pAdj1 - outcomeVal
                            da1 = err1 * lgt1_i
                            db1 = err1
                            // A2 â€“ Momentum: EMA of gradients (head 1)
                            float effDa1 = da1
                            float effDb1 = db1
                            if useSgdMomentum
                                mA1 = sgdBeta * array.get(st.momPlatt1, 0) + (1.0 - sgdBeta) * da1
                                mB1 = sgdBeta * array.get(st.momPlatt1, 1) + (1.0 - sgdBeta) * db1
                                array.set(st.momPlatt1, 0, mA1)
                                array.set(st.momPlatt1, 1, mB1)
                                effDa1 := mA1
                                effDb1 := mB1
                            pltA1 := math.max(0.1, math.min(5.0, pltA1 - lrPlattEff * effDa1))
                            pltB1 := math.max(-3.0, math.min(3.0, pltB1 - lrPlattEff * effDb1))
                            array.set(st.platt1, 0, pltA1)
                            array.set(st.platt1, 1, pltB1)
                            
                            ll1 = f_logloss(pAdj1, outcomeVal)
                            f_update_accum_stats(st.llStats1, ll1)

                else
                    // Skip tracking: resolved but not scorable
                    if skipReason == 1
                        st.skipBias0 += 1
                    else if skipReason == 2
                        st.skipAtrInvalid += 1
                    else if skipReason == 3
                        st.skipIgnore += 1
                    else if skipReason == 4
                        st.skipTieNeutral2Way += 1
                    if useFc_i
                        st.skipTotalElig += 1
                        if skipReason == 1
                            st.skipBias0Elig += 1
                        else if skipReason == 2
                            st.skipAtrInvalidElig += 1
                        else if skipReason == 3
                            st.skipIgnoreElig += 1
                        else if skipReason == 4
                            st.skipTieNeutral2WayElig += 1

                if not use3Way
                    f_safe_remove_float(st.qProbN, i)
                    f_safe_remove_float(st.qProb1, i)
                    f_safe_remove_float(st.qLogitN, i)
                    f_safe_remove_float(st.qLogit1, i)
                    f_safe_remove_float(st.qPredN, i)
                    f_safe_remove_float(st.qPred1, i)
                if use3Way
                    f_safe_remove_float(st.qPUpN, i)
                    f_safe_remove_float(st.qPFlN, i)
                    f_safe_remove_float(st.qPDnN, i)
                    f_safe_remove_float(st.qPUp1, i)
                    f_safe_remove_float(st.qPFl1, i)
                    f_safe_remove_float(st.qPDn1, i)
                    f_safe_remove_float(st.qZUpN, i)
                    f_safe_remove_float(st.qZFlN, i)
                    f_safe_remove_float(st.qZDnN, i)
                    f_safe_remove_float(st.qZUp1, i)
                    f_safe_remove_float(st.qZFl1, i)
                    f_safe_remove_float(st.qZDn1, i)
                f_safe_remove_int(st.qAge,   i)
                f_safe_remove_float(st.qMaxH,  i)
                f_safe_remove_float(st.qMinL,  i)
                f_safe_remove_float(st.qAtr,   i)
                f_safe_remove_float(st.qEntry, i)
                f_safe_remove_int(st.qBinN,  i)
                f_safe_remove_int(st.qBin1,  i)
                f_safe_remove_int(st.qBias, i)
                f_safe_remove_bool(st.qUseForecast, i)
            i -= 1
        bias = emaFNow > emaSNow ? 1 : emaFNow < emaSNow ? -1 : 0
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        // Epsilon PRICE_EPS prevents division by zero on penny stocks or exotic instruments with close near 0
        atrNorm = atrNow / math.max(cNow, PRICE_EPS)
        sD = f_trend_regime(emaFNow, emaSNow, atrNorm)
        sEns = f_ensemble4(sA, sB, sC, sD, wStateVal, wPullbackVal, wRegimeVal, wTrendVal)
        if not na(sEns) and not na(sD)
            f_update_quantiles(st, sEns)
            
            // --- Phase 2: 2D Binning ---
            bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, st.qCutsN)
            b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, st.qCuts1)

            dirFlag = f_bias_from_score(sA)
            biasSel = f_bias_from_score(sA)
            if biasSel == 0
                biasSel := bias == 0 ? 1 : bias
            cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
            upN_sel  = useBullBearCal ? (biasSel > 0 ? st.upN_bull  : st.upN_bear)  : st.upN
            dnN_sel  = useBullBearCal ? (biasSel > 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
            cnt1_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
            up1_sel  = useBullBearCal ? (biasSel > 0 ? st.up1_bull  : st.up1_bear)  : st.up1
            dn1_sel  = useBullBearCal ? (biasSel > 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1

            tempN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
            temp1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
            vecAN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
            vecBN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
            vecA1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
            vecB1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1

            if use3Way
                [pUrawN_t, pFrawN_t, pDrawN_t, _nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaNVal, shrinkKVal, kShrinkReg)
                [pUraw1_t, pFraw1_t, pDraw1_t, _n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1Val, shrinkKVal, kShrinkReg)
                pUrawN = pUrawN_t
                pFrawN = pFrawN_t
                pDrawN = pDrawN_t
                _nN = _nN_t
                pUraw1 = pUraw1_t
                pFraw1 = pFraw1_t
                pDraw1 = pDraw1_t
                _n1 = _n1_t

                zUN = f_safe_log(pUrawN)
                zFN = f_safe_log(pFrawN)
                zDN = f_safe_log(pDrawN)
                zU1 = f_safe_log(pUraw1)
                zF1 = f_safe_log(pFraw1)
                zD1 = f_safe_log(pDraw1)

                useCalN = f_can_cal3(_nN)
                useCal1 = f_can_cal3(_n1)
                float pUN = na
                float pFN = na
                float pDN = na
                float pU1 = na
                float pF1 = na
                float pD1 = na
                if useCalN
                    [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, tempN_sel, vecAN_sel, vecBN_sel)
                    pUN := tUN_t
                    pFN := tFN_t
                    pDN := tDN_t
                else
                    pUN := pUrawN
                    pFN := pFrawN
                    pDN := pDrawN
                if useCal1
                    [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, temp1_sel, vecA1_sel, vecB1_sel)
                    pU1 := tU1_t
                    pF1 := tF1_t
                    pD1 := tD1_t
                else
                    pU1 := pUraw1
                    pF1 := pFraw1
                    pD1 := pDraw1

                array.push(st.qBinN,  bN)
                array.push(st.qBin1,  b1)
                array.push(st.qEntry, cNow)
                array.push(st.qAtr,   atrNow)

                array.push(st.qMaxH,  cNow)
                array.push(st.qMinL,  cNow)

                array.push(st.qAge,   0)
                array.push(st.qBias,  dirFlag)
                array.push(st.qUseForecast, enableForecast and f_forecast_allowed())
                st.enqCount += 1
                if enableForecast and f_forecast_allowed()
                    st.enqCountElig += 1

                array.push(st.qPUpN, pUN)
                array.push(st.qPFlN, pFN)
                array.push(st.qPDnN, pDN)
                array.push(st.qPUp1, pU1)
                array.push(st.qPFl1, pF1)
                array.push(st.qPDn1, pD1)

                array.push(st.qZUpN, zUN)
                array.push(st.qZFlN, zFN)
                array.push(st.qZDnN, zDN)
                array.push(st.qZUp1, zU1)
                array.push(st.qZFl1, zF1)
                array.push(st.qZDn1, zD1)
            else
                // Capture current probabilities
                [pNowN_t, _nN_t] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
                [pNow1_t, _n1_t] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)
                pNowN = pNowN_t
                _nN = _nN_t
                pNow1 = pNow1_t
                _n1 = _n1_t

                // Logits (Phase 4)
                lgtN = f_logit(pNowN)
                lgt1 = f_logit(pNow1)

                // Platt Adjust (Display/Predict)
                aN = array.get(st.plattN, 0)
                bN_p = array.get(st.plattN, 1)
                pAdjN = f_sigmoid(aN * lgtN + bN_p)

                pltA1 = array.get(st.platt1, 0)
                pltB1_p = array.get(st.platt1, 1)
                pAdj1 = f_sigmoid(pltA1 * lgt1 + pltB1_p)

                // Use adjusted if Platt enabled, else raw
                pFinalN = usePlatt ? pAdjN : pNowN
                pFinal1 = usePlatt ? pAdj1 : pNow1

                array.push(st.qBinN,  bN)
                array.push(st.qBin1,  b1)
                array.push(st.qEntry, cNow)
                array.push(st.qAtr,   atrNow)

                array.push(st.qMaxH,  cNow)
                array.push(st.qMinL,  cNow)

                array.push(st.qAge,   0)
                array.push(st.qBias,  dirFlag)
                array.push(st.qUseForecast, enableForecast and f_forecast_allowed())
                st.enqCount += 1
                if enableForecast and f_forecast_allowed()
                    st.enqCountElig += 1

                array.push(st.qProbN, pNowN)
                array.push(st.qProb1, pNow1)
                array.push(st.qLogitN, lgtN)
                array.push(st.qLogit1, lgt1)
                array.push(st.qPredN, pFinalN)
                array.push(st.qPred1, pFinal1)

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Volume Weighted Trend core (configurable)
bool vwtAutoPreset = vwtPreset == "Auto"
string vwtPresetEff = vwtAutoPreset ? (entryPreset == "Intraday" ? "Fast Response" : entryPreset == "Swing" ? "Smooth Trend" : "Default") : vwtPreset
int vwtLenEff = vwtPresetEff == "Fast Response" ? 21 : vwtPresetEff == "Smooth Trend" ? 55 : vwtLengthInput
float vwtAtrMultEff = vwtPresetEff == "Fast Response" ? 1.2 : vwtPresetEff == "Smooth Trend" ? 2.0 : vwtAtrMultInput
int vwtReversalWindowEff = vwtAutoPreset ? (entryPreset == "Intraday" ? 2 : entryPreset == "Swing" ? 4 : vwtReversalWindowBars) : vwtReversalWindowBars
vwtBasis = ta.vwma(close, vwtLenEff)
vwtAtr = ta.atr(vwtLenEff)
vwtUpperBand = vwtBasis + vwtAtr * vwtAtrMultEff
vwtLowerBand = vwtBasis - vwtAtr * vwtAtrMultEff

var int vwtTrendDirection = 0
if close > vwtUpperBand
    vwtTrendDirection := 1
else if close < vwtLowerBand
    vwtTrendDirection := -1

vwtTurnedBull = vwtTrendDirection == 1 and vwtTrendDirection[1] != 1
vwtTurnedBear = vwtTrendDirection == -1 and vwtTrendDirection[1] != -1
vwtBullRecent = (not na(ta.barssince(vwtTurnedBull))) and (ta.barssince(vwtTurnedBull) <= vwtReversalWindowEff)
vwtBearRecent = (not na(ta.barssince(vwtTurnedBear))) and (ta.barssince(vwtTurnedBear) <= vwtReversalWindowEff)
vwtLongEntryOk = (not useVwtTrendFilter) or (vwtTrendDirection == 1 and ((not vwtReversalOnly) or vwtBullRecent))
vwtShortEntryOk = (not useVwtTrendFilter) or (vwtTrendDirection == -1 and ((not vwtReversalOnly) or vwtBearRecent))

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ? ((not na(baseSecs) and baseSecs <= SEC_5M) ? rsiLenFastTF : (not na(baseSecs) and baseSecs <= SEC_1H) ? rsiLenMidTF : rsiLenSlowTF) : rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

//====================
// USI Quantum Pulse computation (visual overlay only)
//====================
f_zl_src(src, len) =>
    e1 = ta.ema(src, len)
    e2 = ta.ema(e1, len)
    2.0 * e1 - e2

// 2. 30m Gate (Regime Context) - STABLE
// Logic: Calculate normal 30m USI, but request with [1] to get the Last Completed Bar.
f_usi_30m_calc_raw() =>
    // Standard USI calc on the requested TF (no [1] shift here)
    _c = close
    _e = ta.ema(close, usiEmaLen)
    
    // Note: We access f_zl_src which is globally defined
    _s1 = usiZeroLag ? f_zl_src(close, usiLen1) : close
    _s2 = usiZeroLag ? f_zl_src(close, usiLen2) : close
    _s3 = usiZeroLag ? f_zl_src(close, usiLen3) : close
    _s4 = usiZeroLag ? f_zl_src(close, usiLen4) : close
    _s5 = usiZeroLag ? f_zl_src(close, usiLen5) : close
    
    _r1 = ta.rsi(_s1, usiLen1)
    _r2 = ta.rsi(_s2, usiLen2)
    _r3 = ta.rsi(_s3, usiLen3)
    _r4 = ta.rsi(_s4, usiLen4)
    _r5 = ta.rsi(_s5, usiLen5)
    
    _cA = math.avg(_r1, _r2, _r3, _r4)
    [_c, _e, _r5, _cA]

usiSrc1 = usiZeroLag ? f_zl_src(close, usiLen1) : close
usiSrc2 = usiZeroLag ? f_zl_src(close, usiLen2) : close
usiSrc3 = usiZeroLag ? f_zl_src(close, usiLen3) : close
usiSrc4 = usiZeroLag ? f_zl_src(close, usiLen4) : close
usiSrc5 = usiZeroLag ? f_zl_src(close, usiLen5) : close

usiLine1 = ta.rsi(usiSrc1, usiLen1)  // slowest (Blue)
usiLine2 = ta.rsi(usiSrc2, usiLen2)  // Green
usiLine3 = ta.rsi(usiSrc3, usiLen3)  // Yellow
usiLine4 = ta.rsi(usiSrc4, usiLen4)  // Orange
usiLine5 = ta.rsi(usiSrc5, usiLen5)  // fastest (Red)

usiBullStack = (usiLine5 > usiLine4 ? 1 : 0) +
     (usiLine4 > usiLine3 ? 1 : 0) +
     (usiLine3 > usiLine2 ? 1 : 0) +
     (usiLine2 > usiLine1 ? 1 : 0)
usiBearStack = (usiLine1 > usiLine2 ? 1 : 0) +
     (usiLine2 > usiLine3 ? 1 : 0) +
     (usiLine3 > usiLine4 ? 1 : 0) +
     (usiLine4 > usiLine5 ? 1 : 0)
usiStackMax = math.max(usiBullStack, usiBearStack)
usiStackDir = usiBullStack >= usiMinStack ? 1 : usiBearStack >= usiMinStack ? -1 : 0

// USI Quality Logic (Red vs All)
// Pattern A: "Premium vs Standard" Signaling
// Defined: Red (L5) vs Envelopes of Others (L1-L4)
usiMaxEnv = math.max(math.max(usiLine1, usiLine2), math.max(usiLine3, usiLine4))
usiMinEnv = math.min(math.min(usiLine1, usiLine2), math.min(usiLine3, usiLine4))

// "Red under all, then crosses above all" -> BUY
// Implies: Yesterday Red < MinEnv, Today Red crosses above MaxEnv
// usiWasBelowAll removed as it was dead code
usiWasAboveAll = usiLine5[1] > usiMaxEnv[1]

_usiXUp = ta.crossover(usiLine5, usiMaxEnv)
_usiXDn = ta.crossunder(usiLine5, usiMinEnv)

// usiBuySignal removed as it was dead code
usiSellSignal = usiWasAboveAll and _usiXDn

// State: Red clearly dominant above/below all others
usiBullState = usiLine5 > usiMaxEnv
usiBearState = usiLine5 < usiMinEnv

//====================
// USI Quantum Pulse Logic (Fast+Verify) - v6.3.3
//====================

// 1. Cluster & Trend (Timeframe: Chart)
// usiMaxEnv / usiMinEnv are already calculated above (L1-L4)
// Def: cluster = avg(L1..L4)
usiClusterHigh = usiMaxEnv
usiClusterLow  = usiMinEnv
usiClusterAvg  = math.avg(usiLine1, usiLine2, usiLine3, usiLine4)
usiSpread      = usiClusterHigh - usiClusterLow

// Tight Spread Detection (Dynamic using Median p50)
// If spread is below X% of median spread -> "Tight"
usiSpreadP50   = ta.percentile_linear_interpolation(usiSpread, usiSpreadLookback, 50)
usiTightSpread = (usiSpreadP50 > 0) and (usiSpread < (usiSpreadP50 * usiTightFactor))

usiEmaGate     = ta.ema(close, usiEmaLen)

// Fetch Stable 30m Data (Previous Closed Bar)
// Variant A: Fetch raw, then shift. This avoids tuple indexing ambiguity.
[qCl30_raw, qEma30_raw, qL5_30_raw, qClusterA30_raw] = request.security(syminfo.tickerid, usiTfGate, f_usi_30m_calc_raw(), lookahead = barmerge.lookahead_off)

// Apply 1-bar shift to get the last COMPLETED 30m bar
qCl30       = qCl30_raw[1]
qEma30      = qEma30_raw[1]
qL5_30      = qL5_30_raw[1]
qClusterA30 = qClusterA30_raw[1]

// Gate Check (Valid if regime in previous confirmed 30m bar was correct)
qRegimeBuy  = qCl30 >= qEma30 and qL5_30 >= qClusterA30
qRegimeSell = qCl30 <= qEma30 and qL5_30 <= qClusterA30

// 3. Fast Signal (Bar 0) - Detection
// _usiXUp / _usiXDn are ta.crossover(usiLine5, usiMaxEnv)
// We just capture the raw crossover here. Gates are applied at verification to avoid "missing" a cross that happened just before gate opened.
qFastSignalBuy  = _usiXUp
qFastSignalSell = _usiXDn

// 4. Verify & Enter (Bar 1) - USI Logic
// Check if signal happened yesterday
qSigWasBuy  = usiAggressiveSameBarVerify ? qFastSignalBuy : qFastSignalBuy[1]
qSigWasSell = usiAggressiveSameBarVerify ? qFastSignalSell : qFastSignalSell[1]

// Gate Logic: Must be valid NOW (at moment of entry)
qGatesValidBuy  = (close > usiEmaGate) and qRegimeBuy
qGatesValidSell = (close < usiEmaGate) and qRegimeSell

// Verify Criteria BUY (Bar 1)
// 1. Hold: L5 > Cluster (Avg) [Hardened: AND L5 > L4]
vBuy1_Hold_base = usiLine5 > usiClusterAvg
vBuy1_Hold      = hardenHold ? (vBuy1_Hold_base and (usiLine5 > usiLine4)) : vBuy1_Hold_base
// 2. Continuation: L5 > L5[1]
vBuy2_Cont  = usiLine5 > usiLine5[1]
// 3. Mini-Stack: L5 > L4 > L3
vBuy3_Stack = (usiLine5 > usiLine4) and (usiLine4 > usiLine3)

// Verify Decisions Buy
qVerifyVotesMin = usiAggressiveOneOfThree ? 1 : 2
bool qVerifyBuy = false
if usiTightSpread
    if usiAggressiveTightSpreadVotes
        qVerifyBuy := qSigWasBuy and ((vBuy1_Hold?1:0) + (vBuy2_Cont?1:0) + (vBuy3_Stack?1:0) >= qVerifyVotesMin)
    else
        // Strict Mode for tight spread: Must have Hold AND Continuation
        qVerifyBuy := qSigWasBuy and vBuy1_Hold and vBuy2_Cont
else
    // Standard Mode: 2 of 3 (or 1 of 3 in aggressive mode)
    qVerifyBuy := qSigWasBuy and ((vBuy1_Hold?1:0) + (vBuy2_Cont?1:0) + (vBuy3_Stack?1:0) >= qVerifyVotesMin)

// Verify Criteria SELL (Bar 1)
// 1. Hold: L5 < Cluster (Avg) [Hardened: AND L5 < L4]
vSell1_Hold_base = usiLine5 < usiClusterAvg
vSell1_Hold      = hardenHold ? (vSell1_Hold_base and (usiLine5 < usiLine4)) : vSell1_Hold_base
// 2. Contin: L5 < L5[1]
vSell2_Cont  = usiLine5 < usiLine5[1]
// 3. Stack: L5 < L4 < L3
vSell3_Stack = (usiLine5 < usiLine4) and (usiLine4 < usiLine3)

// Verify Decisions Sell
bool qVerifySell = false
if usiTightSpread
    if usiAggressiveTightSpreadVotes
        qVerifySell := qSigWasSell and ((vSell1_Hold?1:0) + (vSell2_Cont?1:0) + (vSell3_Stack?1:0) >= qVerifyVotesMin)
    else
        // Strict Mode for tight spread: Must have Hold AND Continuation
        qVerifySell := qSigWasSell and vSell1_Hold and vSell2_Cont
else
    // Standard Mode: 2 of 3 (or 1 of 3 in aggressive mode)
    qVerifySell := qSigWasSell and ((vSell1_Hold?1:0) + (vSell2_Cont?1:0) + (vSell3_Stack?1:0) >= qVerifyVotesMin)

// Final Entry (Trigger)
// Combine Verification + Gates at the moment of entry (Bar 1)
qFinalEntryBuy  = useUsi and qVerifyBuy and qGatesValidBuy
qFinalEntrySell = useUsi and qVerifySell and qGatesValidSell

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime (protect against close=0 on exotic instruments)
atrRank = f_pct_rank(atr / math.max(close, PRICE_EPS), volRankLen)

// ATR regime + percentile (light context layer)
atrBaselineReg = atrRegimeBaselineType == "EMA" ? ta.ema(atr, atrRegimeBaselineLen) : ta.sma(atr, atrRegimeBaselineLen)
atrRatioReg = atrBaselineReg > 0 ? atr / atrBaselineReg : 1.0
atrWasRecentlyHigh = ta.highest(atrRatioReg[1], atrExhaustLookback) >= atrHighVolThr
atrDeclining = ta.falling(atr, atrExhaustLookback)
int atrRegime = atrRatioReg < atrCompressionThr ? 1 : atrRatioReg >= atrHighVolThr ? 3 : (atrWasRecentlyHigh and atrDeclining and atrRatioReg < atrHighVolThr) ? 4 : atrRatioReg >= atrExpansionThr ? 2 : 0
atrRegimeName = atrRegime == 1 ? "COMPRESSION" : atrRegime == 2 ? "EXPANSION" : atrRegime == 3 ? "HIGH VOL" : atrRegime == 4 ? "EXHAUSTION" : "NEUTRAL"
atrRegimeBg = atrRegime == 1 ? color.new(color.lime, 88) : atrRegime == 2 ? color.new(color.orange, 88) : atrRegime == 3 ? color.new(color.red, 88) : atrRegime == 4 ? color.new(color.purple, 88) : na
atrPercentile = enableAtrPercentile ? (f_pct_rank(atr, atrPercentileLookback) * 100.0) : na

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? nz(volRankRaw, 0.5) : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScoreDir = macroGateMode == "Off" ? 0.5 : emaF > emaS ? (1.0 - macroPct) : emaF < emaS ? macroPct : 0.5
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSevereSafe = math.max(ddSevere, ddMild + PRICE_EPS)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevereSafe - ddMild, PRICE_EPS))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // global per-bar
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    trendOk = dir == 1 ? (emaF > emaS and close > emaS) : (emaF < emaS and close < emaS)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier = config == "Standard" ? 1.00 : config == "Pro" ? 1.05 : config == "V2 Essential" ? 0.95 : config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScoreDir, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

// v6.2.20: REV opening window â€” bypass pU around market open
sessOpen       = timestamp(syminfo.timezone, year, month, dayofmonth, rthOpenHour, rthOpenMinute)
minsFromOpen   = (time - sessOpen) / 60000.0
openWindowEngineOk = revOpenWindowEngine == "All" or revOpenWindowEngine == engine
inRevOpenWindowLong = useRevOpenWindow and openWindowEngineOk and timeframe.isintraday and (minsFromOpen >= -revOpenWindowLongMins) and (minsFromOpen <= revOpenWindowLongMins)
inRevOpenWindowShort = useRevOpenWindow and openWindowEngineOk and timeframe.isintraday and (minsFromOpen >= -revOpenWindowShortMins) and (minsFromOpen <= revOpenWindowShortMins)
inRevOpenWindow = inRevOpenWindowLong or inRevOpenWindowShort
openWindowBypassEntries = revOpenWindowMode == "All Entries"

//====================
// Zones (anchored)
//====================
var float entryPrice = na
var float entryAtr   = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice = zoneAnchor == "Entry" and not na(entryPrice) ? entryPrice : zoneAnchor == "VWAP" ? vwapVal : zoneAnchor == "MA200" ? sma200Val : zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

// Pullback mode: directional bands based on current bias
// bullBias â†’ bands below anchor (dip-buy zone); bearBias â†’ bands above (pop-sell zone)
float pbDir = bullBias ? -1.0 : 1.0
aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice + pbDir * zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice + pbDir * zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setLongPulse = setPulseOnly ? (setLong and not setLong[1]) : setLong
setShortPulse = setPulseOnly ? (setShort and not setShort[1]) : setShort

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var int lastSignalTime = na
var string lastSig = "â€”"

bool presetIsManual = entryPreset == "Manuell" or entryPreset == "Manual"
bool presetIsIntraday = entryPreset == "Intraday"
bool presetOverridesActive = (not presetIsManual) and (not lockPresetOverrides)
bool legacyEntryBehavior = entryBehaviorProfile == "Legacy (v6.3.9-like)"
bool scalpEarlyEntryBehavior = entryBehaviorProfile == "Scalp Early (v6.3.12-fast)"

int scoreThresholdLongEff = presetOverridesActive ? (presetIsIntraday ? 5 : 7) : scoreThresholdLong
int scoreThresholdShortEff = presetOverridesActive ? (presetIsIntraday ? 5 : 7) : scoreThresholdShort
if scalpEarlyEntryBehavior
    scoreThresholdLongEff := math.max(4, scoreThresholdLongEff - 1)
    scoreThresholdShortEff := math.max(4, scoreThresholdShortEff - 1)

float minDirProbLongEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : minDirProbLong
float minDirProbShortEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : minDirProbShort
float scoreMinConfLongEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinConfLong
float scoreMinConfShortEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinConfShort
float scoreMinPuEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinPu
float scoreMinPdEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinPd
if scalpEarlyEntryBehavior
    minDirProbLongEff := math.max(0.30, minDirProbLongEff - 0.05)
    minDirProbShortEff := math.max(0.30, minDirProbShortEff - 0.05)
    scoreMinPuEff := math.max(0.30, scoreMinPuEff - 0.05)
    scoreMinPdEff := math.max(0.30, scoreMinPdEff - 0.05)
    scoreMinConfLongEff := math.max(0.30, scoreMinConfLongEff - 0.05)
    scoreMinConfShortEff := math.max(0.30, scoreMinConfShortEff - 0.05)
bool useScoreEntriesEff = presetOverridesActive ? true : useScoreEntries
int wUsiEff = presetOverridesActive ? (presetIsIntraday ? 5 : 3) : wUsi
int wLiquidityEff = presetOverridesActive ? (presetIsIntraday ? 3 : 2) : wLiquidity
int wMomentumEff = presetOverridesActive ? (presetIsIntraday ? 3 : 2) : wMomentum
int wEngulfingEff = presetOverridesActive ? (presetIsIntraday ? 2 : 1) : wEngulfing
int wTrendContextEff = presetOverridesActive ? (presetIsIntraday ? 1 : 2) : wTrendContext
int wChopPenaltyEff = presetOverridesActive ? (presetIsIntraday ? -2 : -4) : wChopPenalty
if legacyEntryBehavior
    wChopPenaltyEff := math.min(wChopPenaltyEff, -1)
bool scoreRequireDirectionalContextEff = not legacyEntryBehavior
bool scoreChopHardVetoEff = not legacyEntryBehavior and not scalpEarlyEntryBehavior
float chochMinProbEff = legacyEntryBehavior ? math.max(0.34, chochMinProb - 0.05) : scalpEarlyEntryBehavior ? math.max(0.30, chochMinProb - 0.08) : chochMinProb

// C2 â€“ Adaptive cooldown: halve wait when model confidence is high
effectiveCooldownBars = (confidence >= 0.80) ? math.max(2, math.round(cooldownBars / 2)) : cooldownBars
effectiveCooldownMin  = (confidence >= 0.80) ? math.max(2, math.round(cooldownMinutes / 2)) : cooldownMinutes
bool tpPreset30mIsManual = tpPreset30m == "Manual"
float dynamicTpKickInREff = tpPreset30mIsManual ? dynamicTpKickInR : tpPreset30m == "Conservative" ? 1.0 : tpPreset30m == "Balanced" ? 0.7 : tpPreset30m == "Runner" ? 0.4 : 0.2
float dynamicTpAddATRPerREff = tpPreset30mIsManual ? dynamicTpAddATRPerR : tpPreset30m == "Conservative" ? 0.30 : tpPreset30m == "Balanced" ? 0.50 : tpPreset30m == "Runner" ? 0.75 : 1.00
float dynamicTpMaxAddATREff = tpPreset30mIsManual ? dynamicTpMaxAddATR : tpPreset30m == "Conservative" ? 2.5 : tpPreset30m == "Balanced" ? 4.0 : tpPreset30m == "Runner" ? 6.0 : 8.0

cooldownOk =
     cooldownMode == "Bars"
         ? (na(lastSignalBar) ? true : (bar_index - lastSignalBar > effectiveCooldownBars))
         : (na(lastSignalTime) ? true : (time - lastSignalTime > (effectiveCooldownMin * 60 * 1000)))

f_getBrier_raw(tfSel) =>
    float score = na

    TfState st = na
    if tfSel == "F1"
        st := tf1State
    else if tfSel == "F2"
        st := tf2State
    else if tfSel == "F3"
        st := tf3State
    else if tfSel == "F4"
        st := tf4State
    else if tfSel == "F5"
        st := tf5State
    else if tfSel == "F6"
        st := tf6State
    else if tfSel == "F7"
        st := tf7State

    if not na(st)
        if use3Way
            score := array.size(st.evBrierN) == 0 ? na : array.get(st.evSumBrierN, 0) / array.size(st.evBrierN)
        else
            s = array.get(st.brierStatsN, 0)
            c = array.get(st.brierStatsN, 1)
            score := c > 0 ? s / c : na

    score

f_get_total_samples(tfSel, useBull) =>
    float total = na
    float[] cnt = na
    useBullSel = (useBull == true)
    if tfSel == "F1"
        cnt := useBullBearCal ? (useBullSel ? tf1State.cntN_bull_raw : tf1State.cntN_bear_raw) : tf1State.cntN_raw
    else if tfSel == "F2"
        cnt := useBullBearCal ? (useBullSel ? tf2State.cntN_bull_raw : tf2State.cntN_bear_raw) : tf2State.cntN_raw
    else if tfSel == "F3"
        cnt := useBullBearCal ? (useBullSel ? tf3State.cntN_bull_raw : tf3State.cntN_bear_raw) : tf3State.cntN_raw
    else if tfSel == "F4"
        cnt := useBullBearCal ? (useBullSel ? tf4State.cntN_bull_raw : tf4State.cntN_bear_raw) : tf4State.cntN_raw
    else if tfSel == "F5"
        cnt := useBullBearCal ? (useBullSel ? tf5State.cntN_bull_raw : tf5State.cntN_bear_raw) : tf5State.cntN_raw
    else if tfSel == "F6"
        cnt := useBullBearCal ? (useBullSel ? tf6State.cntN_bull_raw : tf6State.cntN_bear_raw) : tf6State.cntN_raw
    else if tfSel == "F7"
        cnt := useBullBearCal ? (useBullSel ? tf7State.cntN_bull_raw : tf7State.cntN_bear_raw) : tf7State.cntN_raw

    if not na(cnt)
        total := array.sum(cnt)
    total

f_get_state_for_tf(tfSel) =>
    TfState st = na
    if tfSel == "F1"
        st := tf1State
    else if tfSel == "F2"
        st := tf2State
    else if tfSel == "F3"
        st := tf3State
    else if tfSel == "F4"
        st := tf4State
    else if tfSel == "F5"
        st := tf5State
    else if tfSel == "F6"
        st := tf6State
    else if tfSel == "F7"
        st := tf7State
    st

f_eval_metrics_for_tf(tfSel) =>
    st = f_get_state_for_tf(tfSel)
    if na(st)
        [float(na), float(na), float(na)]
    else
        [_bAvg, _lAvg, ece, _mErr, _wS, _wL, drift, nSc] = f_eval_stats_one(st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN)
        [ece, drift * 100.0, nSc]

f_eval_success_for_tf(tfSel) =>
    st = f_get_state_for_tf(tfSel)
    if na(st)
        [float(na), 0]
    else
        n = array.size(st.evYS_N)
        wr = n == 0 ? na : array.get(st.evSumYS_N, 0) / n
        [wr, n]


// Rel-value arrays (source of truth for gate/table)
var float[] relPUN  = array.new_float(7, na)
var float[] relPFN  = array.new_float(7, na)
var float[] relPDN  = array.new_float(7, na)
var float[] relNN   = array.new_float(7, na)
var float[] relTotN = array.new_float(7, na)

f_tf_index(tfSel) =>
    tfSel == "F1" ? 0 : tfSel == "F2" ? 1 : tfSel == "F3" ? 2 : tfSel == "F4" ? 3 : tfSel == "F5" ? 4 : tfSel == "F6" ? 5 : 6

f_idx_to_tfsel(idx) =>
    idx == 0 ? "F1" : idx == 1 ? "F2" : idx == 2 ? "F3" : idx == 3 ? "F4" : idx == 4 ? "F5" : idx == 5 ? "F6" : "F7"

f_find_tf_idx(tf, tfArr) =>
    int idx = -1
    for i = 0 to array.size(tfArr) - 1
        if array.get(tfArr, i) == tf
            idx := i
            break
    idx

f_get_rel_vals(tfSel) =>
    float pU = na
    float pF = na
    float pD = na
    float nBin = na
    float total = na
    idx = f_tf_index(tfSel)
    pU := array.get(relPUN, idx)
    pF := array.get(relPFN, idx)
    pD := array.get(relPDN, idx)
    nBin := array.get(relNN, idx)
    total := array.get(relTotN, idx)
    [pU, pF, pD, nBin, total]

f_edges3(pU, pF, pD) =>
    [pU - pF, pU - pD, pD - pF, pD - pU]

// Decision quality helper (used by forecast gate and decision banners)
f_decision_quality(pU, pF, pD, nBin, total) =>
    if not use3Way
        [false, "3-way off", color.gray, na]
    else
        // Handle warmup / NA safely
        if na(pU) or na(pF) or na(pD) or na(nBin) or na(total)
            [false, "n/a", color.orange, na]
        else
            maxP = math.max(pU, math.max(pF, pD))
            tieEps = 1e-10
            isMaxU = math.abs(pU - maxP) <= tieEps
            isMaxF = math.abs(pF - maxP) <= tieEps
            isMaxD = math.abs(pD - maxP) <= tieEps
            dir = (isMaxU and not (isMaxF or isMaxD)) ? 1 : (isMaxD and not (isMaxU or isMaxF)) ? -1 : 0
            edgeFlat = dir == 1 ? (pU - pF) : dir == -1 ? (pD - pF) : 0.0
            edgeOpp  = dir == 1 ? (pU - pD) : dir == -1 ? (pD - pU) : 0.0
            edge = dir == 0 ? na : math.min(edgeFlat, edgeOpp)

            binOk   = (tradeMinBinSamples <= 0) or (nBin >= tradeMinBinSamples)
            totalOk = (tradeMinTotalSamples <= 0) or (total >= tradeMinTotalSamples)
            edgeOk  = (dir != 0) and edge >= abstainMinEdge

            ok = edgeOk and binOk and totalOk

            reason =
                 (tradeMinTotalSamples > 0 and total < tradeMinTotalSamples) ? "Low Total" :
                 (tradeMinBinSamples   > 0 and nBin  < tradeMinBinSamples)   ? "Weak Bin" :
                 (dir == 0)                                                  ? "Flat" :
                 (edge < abstainMinEdge)                                    ? "Low Edge" :
                 "OK"

            col = ok ? color.lime : color.orange
            [ok, reason, col, edge]

//====================
// Signal execution layer
//====================

// Trend regime
atrNormHere = atr / math.max(close, PRICE_EPS)
trendReg = f_trend_regime(emaF, emaS, atrNormHere)
trendUp  = trendReg == 1.0
trendDn  = trendReg == -1.0
// Engine-side sideways state

// Visual consolidation regime (UX only): hysteresis to reduce "sticky" state flips.
// Does NOT alter engine gating/entries; it only drives consolidation alert state.
sideEmaAbs = math.abs((emaF - emaS) / math.max(nz(emaS, 1.0), PRICE_EPS))
sideEnter = sideEmaAbs < (SIDEWAYS_EMA_THRESH * 0.70) and atrNormHere < (SIDEWAYS_ATR_THRESH * 0.80)
sideExit  = sideEmaAbs > (SIDEWAYS_EMA_THRESH * 1.15) or  atrNormHere > (SIDEWAYS_ATR_THRESH * 1.20)
var bool sidewaysVisual = false
if sideEnter
    sidewaysVisual := true
else if sideExit
    sidewaysVisual := false

// D1 â€“ Smooth trend strength (continuous [-1, 1] alternative)
trendStrength = f_trend_strength(emaF, emaS)
trendUpSmooth  = useSmoothTrend ? trendStrength > TREND_SMOOTH_THRESH : trendUp
trendDnSmooth  = useSmoothTrend ? trendStrength < -TREND_SMOOTH_THRESH : trendDn

// D2 â€“ ADX trend strength filter
[diPlus, diMinus, adxRaw] = ta.dmi(adxLen, adxLen)
adxOk = (not useAdx) or (not na(adxRaw) and adxRaw >= adxThresh)

// B2 â€“ ROC momentum score at signal layer
rocScore = f_roc_score(close, rocLen)
rocLongOk  = wRoc == 0 or rocScore > 0.0
rocShortOk = wRoc == 0 or rocScore < 0.0

// B4 â€“ Volume score at signal layer
volScore = f_vol_score(volume, volEnsLen)
volEnsLongOk  = wVol == 0 or volScore > -0.3
volEnsShortOk = wVol == 0 or volScore > -0.3  // symmetric: both sides reject depressed volume

//====================
// Risk Helpers
//====================

var float stopPx  = na
var float tpPx    = na
var float trailPx = na
var int   enBar   = 0     // Track Entry Bar Index for cooldown hold handling
var int   enTime  = na    // Track Entry Time for EntriesOnly minute-mode hold

// Calculate risk levels on entry; returns updated stop/tp/trail
f_set_risk_on_entry(isLong, entry, atrNow) =>
    // v6.3.0 Fix: Link Strategy Execution to Profile Inputs (Fast/Mid/Slow)
    [pFc, pK, pA, pH, pTp, pSl] = f_get_params(timeframe.period)
    float useStopMul = nz(pSl, stopATR) 
    float useTpMul   = nz(pTp, tpATR)

    float stopOut  = isLong ? (entry - useStopMul * atrNow) : (entry + useStopMul * atrNow)
    float tpOut    = isLong ? (entry + useTpMul   * atrNow) : (entry - useTpMul   * atrNow)
    float trailOut = na
    [stopOut, tpOut, trailOut]

// Update trailing stop; returns updated trail
f_update_trail(isLong, entry, atrNow, stopVal, trailVal) =>
    // activate trailing only after reaching +R
    denom = math.max(math.abs(entry - stopVal), PRICE_EPS)
    rNow = isLong ? ((close - entry) / denom) : ((entry - close) / denom)
    float trailOut = trailVal
    [_, dTrailEff] = f_dyn_sl_preset_vals(decayStopATR, trailATR)
    trailMulEff = dTrailEff
    if rNow >= trailAfterR
        float trailCandidate = isLong ? (close - trailMulEff * atrNow) : (close + trailMulEff * atrNow)
        trailOut := na(trailOut) ? trailCandidate : (isLong ? math.max(trailOut, trailCandidate) : math.min(trailOut, trailCandidate))
    trailOut

f_risk_exit_hit(isLong, stopVal, tpVal, trailVal) =>
    if not useAtrRisk or na(stopVal)
        [false, ""]
    else
        // User Request: Stop Loss on CLOSE only (ignore wicks)
        stopHit  = isLong ? (close <= stopVal) : (close >= stopVal)
        tpHit    = not na(tpVal) and (isLong ? (high >= tpVal)  : (low  <= tpVal))
        // Trailing Stop also on CLOSE
        trailHit = not na(trailVal) and (isLong ? (close <= trailVal) : (close >= trailVal))
        
        // Optimistic Exit Priority on Favorable Candles (TP wins if bar closed in profit)
        bool favorableClose = isLong ? (close > open) : (close < open)
        // If TP hit and bar looks strong, assume TP happened before any deep wick
        bool priorityTP = tpHit and favorableClose

        // standard: stop wins if both in same bar (unless optimistic priority)
        hit = priorityTP ? true : (stopHit or trailHit or tpHit)
        // Priority logic
        msg = priorityTP ? "TP" : stopHit ? "SL" : trailHit ? "Trail" : tpHit ? "TP" : ""
        [hit, msg]

//====================
// Outlook/Forecast packs (one security call per horizon TF)
//====================
// PATCH A REPAINTING FIX: HTF Stable Sync (Strategy)
// We retrieve only raw HTF data and manage confirmation/sync manually
// to avoid updating stateful logic on "in-progress" HTF bars.

f_stable_val(isSame, valRaw, valPrev) => (isSame and barstate.isconfirmed) ? valRaw : valPrev
f_stable_pulse(isSame, timeRaw)       => isSame ? barstate.isconfirmed : (nz(ta.change(timeRaw)) != 0)

[t1_r, c1_r, h1_r, l1_r, ef1_r, es1_r, r1_r, a1_r, vR1_r] = f_tf_pack(tfF1)
[t2_r, c2_r, h2_r, l2_r, ef2_r, es2_r, r2_r, a2_r, vR2_r] = f_tf_pack(tfF2)
[t3_r, c3_r, h3_r, l3_r, ef3_r, es3_r, r3_r, a3_r, vR3_r] = f_tf_pack(tfF3)
[t4_r, c4_r, h4_r, l4_r, ef4_r, es4_r, r4_r, a4_r, vR4_r] = f_tf_pack(tfF4)
[t5_r, c5_r, h5_r, l5_r, ef5_r, es5_r, r5_r, a5_r, vR5_r] = f_tf_pack(tfF5)
[t6_r, c6_r, h6_r, l6_r, ef6_r, es6_r, r6_r, a6_r, vR6_r] = f_tf_pack(tfF6)
[t7_r, c7_r, h7_r, l7_r, ef7_r, es7_r, r7_r, a7_r, vR7_r] = f_tf_pack(tfF7)

// 1) Define Pulses (When to Resolves/Update)
same1 = tfF1 == timeframe.period
same2 = tfF2 == timeframe.period
same3 = tfF3 == timeframe.period
same4 = tfF4 == timeframe.period
same5 = tfF5 == timeframe.period
same6 = tfF6 == timeframe.period
same7 = tfF7 == timeframe.period

pulse1 = f_stable_pulse(same1, t1_r)
pulse2 = f_stable_pulse(same2, t2_r)
pulse3 = f_stable_pulse(same3, t3_r)
pulse4 = f_stable_pulse(same4, t4_r)
pulse5 = f_stable_pulse(same5, t5_r)
pulse6 = f_stable_pulse(same6, t6_r)
pulse7 = f_stable_pulse(same7, t7_r)

// 2) Define Stable Values (At pulse moment, use Finished Bar)
t1 = f_stable_val(same1, t1_r, t1_r[1]), c1 = f_stable_val(same1, c1_r, c1_r[1]), h1 = f_stable_val(same1, h1_r, h1_r[1]), l1 = f_stable_val(same1, l1_r, l1_r[1]), ef1 = f_stable_val(same1, ef1_r, ef1_r[1]), es1 = f_stable_val(same1, es1_r, es1_r[1]), r1 = f_stable_val(same1, r1_r, r1_r[1]), a1 = f_stable_val(same1, a1_r, a1_r[1]), vR1 = f_stable_val(same1, vR1_r, vR1_r[1])
t2 = f_stable_val(same2, t2_r, t2_r[1]), c2 = f_stable_val(same2, c2_r, c2_r[1]), h2 = f_stable_val(same2, h2_r, h2_r[1]), l2 = f_stable_val(same2, l2_r, l2_r[1]), ef2 = f_stable_val(same2, ef2_r, ef2_r[1]), es2 = f_stable_val(same2, es2_r, es2_r[1]), r2 = f_stable_val(same2, r2_r, r2_r[1]), a2 = f_stable_val(same2, a2_r, a2_r[1]), vR2 = f_stable_val(same2, vR2_r, vR2_r[1])
t3 = f_stable_val(same3, t3_r, t3_r[1]), c3 = f_stable_val(same3, c3_r, c3_r[1]), h3 = f_stable_val(same3, h3_r, h3_r[1]), l3 = f_stable_val(same3, l3_r, l3_r[1]), ef3 = f_stable_val(same3, ef3_r, ef3_r[1]), es3 = f_stable_val(same3, es3_r, es3_r[1]), r3 = f_stable_val(same3, r3_r, r3_r[1]), a3 = f_stable_val(same3, a3_r, a3_r[1]), vR3 = f_stable_val(same3, vR3_r, vR3_r[1])
t4 = f_stable_val(same4, t4_r, t4_r[1]), c4 = f_stable_val(same4, c4_r, c4_r[1]), h4 = f_stable_val(same4, h4_r, h4_r[1]), l4 = f_stable_val(same4, l4_r, l4_r[1]), ef4 = f_stable_val(same4, ef4_r, ef4_r[1]), es4 = f_stable_val(same4, es4_r, es4_r[1]), r4 = f_stable_val(same4, r4_r, r4_r[1]), a4 = f_stable_val(same4, a4_r, a4_r[1]), vR4 = f_stable_val(same4, vR4_r, vR4_r[1])
t5 = f_stable_val(same5, t5_r, t5_r[1]), c5 = f_stable_val(same5, c5_r, c5_r[1]), h5 = f_stable_val(same5, h5_r, h5_r[1]), l5 = f_stable_val(same5, l5_r, l5_r[1]), ef5 = f_stable_val(same5, ef5_r, ef5_r[1]), es5 = f_stable_val(same5, es5_r, es5_r[1]), r5 = f_stable_val(same5, r5_r, r5_r[1]), a5 = f_stable_val(same5, a5_r, a5_r[1]), vR5 = f_stable_val(same5, vR5_r, vR5_r[1])
t6 = f_stable_val(same6, t6_r, t6_r[1]), c6 = f_stable_val(same6, c6_r, c6_r[1]), h6 = f_stable_val(same6, h6_r, h6_r[1]), l6 = f_stable_val(same6, l6_r, l6_r[1]), ef6 = f_stable_val(same6, ef6_r, ef6_r[1]), es6 = f_stable_val(same6, es6_r, es6_r[1]), r6 = f_stable_val(same6, r6_r, r6_r[1]), a6 = f_stable_val(same6, a6_r, a6_r[1]), vR6 = f_stable_val(same6, vR6_r, vR6_r[1])
t7 = f_stable_val(same7, t7_r, t7_r[1]), c7 = f_stable_val(same7, c7_r, c7_r[1]), h7 = f_stable_val(same7, h7_r, h7_r[1]), l7 = f_stable_val(same7, l7_r, l7_r[1]), ef7 = f_stable_val(same7, ef7_r, ef7_r[1]), es7 = f_stable_val(same7, es7_r, es7_r[1]), r7 = f_stable_val(same7, r7_r, r7_r[1]), a7 = f_stable_val(same7, a7_r, a7_r[1]), vR7 = f_stable_val(same7, vR7_r, vR7_r[1])

// Get Target Params per TF
[fcT1, kB1, aT1, pH1, tp1, sl1] = f_get_params(tfF1)
[fcT2, kB2, aT2, pH2, tp2, sl2] = f_get_params(tfF2)
[fcT3, kB3, aT3, pH3, tp3, sl3] = f_get_params(tfF3)
[fcT4, kB4, aT4, pH4, tp4, sl4] = f_get_params(tfF4)
[fcT5, kB5, aT5, pH5, tp5, sl5] = f_get_params(tfF5)
[fcT6, kB6, aT6, pH6, tp6, sl6] = f_get_params(tfF6)
[fcT7, kB7, aT7, pH7, tp7, sl7] = f_get_params(tfF7)

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

tfForecastArr = array.from(tfF1, tfF2, tfF3, tfF4, tfF5, tfF6, tfF7)
cForecastArr = array.from(c1, c2, c3, c4, c5, c6, c7)
hForecastArr = array.from(h1, h2, h3, h4, h5, h6, h7)
lForecastArr = array.from(l1, l2, l3, l4, l5, l6, l7)
efForecastArr = array.from(ef1, ef2, ef3, ef4, ef5, ef6, ef7)
esForecastArr = array.from(es1, es2, es3, es4, es5, es6, es7)
rForecastArr = array.from(r1, r2, r3, r4, r5, r6, r7)
aForecastArr = array.from(a1, a2, a3, a4, a5, a6, a7)
vRForecastArr = array.from(vR1, vR2, vR3, vR4, vR5, vR6, vR7)
// PATCH A: confForecastArr uses barstate.isconfirmed (not pulse) so calibration
// accumulates samples at the normal rate.  Anti-repainting is handled by
// f_stable_val on the DATA values (c1, ef1, â€¦) fed into the learner.
confForecastArr = array.from(barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed)
outScoreArr = array.from(outScore1, outScore2, outScore3, outScore4, outScore5, outScore6, outScore7)

f_entry_forecast_gate(isLong) =>
    // v6.2.20: bypass entire forecast gate during opening window
    if openWindowBypassEntries and (isLong ? inRevOpenWindowLong : inRevOpenWindowShort)
        true
    else
        bool ok = true
        forecastAllowed = enableForecast and f_forecast_allowed()
        if useForecastGateEntry and use3Way and forecastAllowed
            [pU, pF, pD, nBin, total] = f_get_rel_vals(entryFcTF)
            binOk   = (tradeMinBinSamples <= 0) or (nBin >= tradeMinBinSamples)
            totalOk = (tradeMinTotalSamples <= 0) or (total >= tradeMinTotalSamples)

            // reliability label from your CI logic (re-used)
            canCal = forecastAllowed and (not na(total) and total > 0)
            relLbl = f_rel_label(isLong ? pU : pD, nBin, total, canCal)
            relOk  = (not requireRelOk) or (relLbl == "ok" or relLbl == "strong")

            [eUf, eUo, eDf, eDo] = f_edges3(pU, pF, pD)

            if requirePathTargetEntry and f_target_for_tf(f_tf_from_horizon(entryFcTF)) != "PathTPvsSL"
                ok := false
            else if isLong
                edgeOk = (not na(eUf) and eUf >= minEdgePP) and (not na(eUo) and eUo >= minEdgePP)
                ok := binOk and totalOk and relOk and (not na(pU) and pU >= minDirProbLongEff) and edgeOk
            else
                edgeOk = (not na(eDf) and eDf >= minEdgePP) and (not na(eDo) and eDo >= minEdgePP)
                ok := binOk and totalOk and relOk and (not na(pD) and pD >= minDirProbShortEff) and edgeOk

            idxFc = f_tf_index(entryFcTF)
            cSel = array.get(cForecastArr, idxFc)
            efSel = array.get(efForecastArr, idxFc)
            esSel = array.get(esForecastArr, idxFc)
            aSel = array.get(aForecastArr, idxFc)
            confSel = array.get(confForecastArr, idxFc)
            trendSideLocal = (confSel == true) and (f_trend_regime(efSel, esSel, aSel / math.max(cSel, PRICE_EPS)) == 0.0)
            if useChopAbstain and trendSideLocal and (not na(pF) and pF >= flatAbstainThr)
                ok := false
        ok

// MTF packs (for normalized score access)
[tS1, cS1, hS1, lS1, efS1, esS1, rS1, aS1, vRS1] = f_tf_pack(tfShort1), confS1 = barstate.isconfirmed
[tS2, cS2, hS2, lS2, efS2, esS2, rS2, aS2, vRS2] = f_tf_pack(tfShort2), confS2 = barstate.isconfirmed
[tS3, cS3, hS3, lS3, efS3, esS3, rS3, aS3, vRS3] = f_tf_pack(tfShort3), confS3 = barstate.isconfirmed
[tM1, cM1, hM1, lM1, efM1, esM1, rM1, aM1, vRM1] = f_tf_pack(tfMedium1), confM1 = barstate.isconfirmed
[tM2, cM2, hM2, lM2, efM2, esM2, rM2, aM2, vRM2] = f_tf_pack(tfMedium2), confM2 = barstate.isconfirmed
[tM3, cM3, hM3, lM3, efM3, esM3, rM3, aM3, vRM3] = f_tf_pack(tfMedium3), confM3 = barstate.isconfirmed
[tL1, cL1, hL1, lL1, efL1, esL1, rL1, aL1, vRL1] = f_tf_pack(tfLong1), confL1 = barstate.isconfirmed
[tL2, cL2, hL2, lL2, efL2, esL2, rL2, aL2, vRL2] = f_tf_pack(tfLong2), confL2 = barstate.isconfirmed
[tL3, cL3, hL3, lL3, efL3, esL3, rL3, aL3, vRL3] = f_tf_pack(tfLong3), confL3 = barstate.isconfirmed

tfMtfArr = array.from(tfShort1, tfShort2, tfShort3, tfMedium1, tfMedium2, tfMedium3, tfLong1, tfLong2, tfLong3)
cMtfArr = array.from(cS1, cS2, cS3, cM1, cM2, cM3, cL1, cL2, cL3)
efMtfArr = array.from(efS1, efS2, efS3, efM1, efM2, efM3, efL1, efL2, efL3)
esMtfArr = array.from(esS1, esS2, esS3, esM1, esM2, esM3, esL1, esL2, esL3)
rMtfArr = array.from(rS1, rS2, rS3, rM1, rM2, rM3, rL1, rL2, rL3)

isBull1 = f_is_bull_bias(outScore1, ef1, es1)
isBull2 = f_is_bull_bias(outScore2, ef2, es2)
isBull3 = f_is_bull_bias(outScore3, ef3, es3)
isBull4 = f_is_bull_bias(outScore4, ef4, es4)
isBull5 = f_is_bull_bias(outScore5, ef5, es5)
isBull6 = f_is_bull_bias(outScore6, ef6, es6)
isBull7 = f_is_bull_bias(outScore7, ef7, es7)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= SEC_30M) ? "Short" : (not na(mtfBaseSecs) and mtfBaseSecs <= SEC_4H) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

f_score_tf_cached(tf) =>
    idx = f_find_tf_idx(tf, tfForecastArr)
    if idx >= 0
        f_score_tf(array.get(cForecastArr, idx), array.get(efForecastArr, idx), array.get(esForecastArr, idx), array.get(rForecastArr, idx))
    else
        idxM = f_find_tf_idx(tf, tfMtfArr)
        idxM >= 0 ? f_score_tf(array.get(cMtfArr, idxM), array.get(efMtfArr, idxM), array.get(esMtfArr, idxM), array.get(rMtfArr, idxM)) : na

getVoteScore() =>
    float sum = 0.0
    float wgt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    // Weight higher timeframes more (tf3 > tf2 > tf1 by convention)
    // nz(..., 0.0): prevent na contamination when a TF is not found in cache.
    // Without this, one na can propagate into mtfScore and silently block entries.
    if f_is_tf_higher_or_equal(tf1)
        sum += 1.0 * nz(f_score_tf_cached(tf1), 0.0)
        wgt += 1.0
    if f_is_tf_higher_or_equal(tf2)
        sum += 1.5 * nz(f_score_tf_cached(tf2), 0.0)
        wgt += 1.5
    if f_is_tf_higher_or_equal(tf3)
        sum += 2.0 * nz(f_score_tf_cached(tf3), 0.0)
        wgt += 2.0

    wgt == 0 ? 0.0 : sum / wgt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > SCORE_NEUTRAL_BAND)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -SCORE_NEUTRAL_BAND)

// Per-horizon bin arrays (unrolled â€” Pine v6 does not support array-of-arrays)
cntN1Arr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull : tf1State.cntN_bear) : tf1State.cntN
cntN2Arr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull : tf2State.cntN_bear) : tf2State.cntN
cntN3Arr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull : tf3State.cntN_bear) : tf3State.cntN
cntN4Arr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull : tf4State.cntN_bear) : tf4State.cntN
cntN5Arr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull : tf5State.cntN_bear) : tf5State.cntN
cntN6Arr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull : tf6State.cntN_bear) : tf6State.cntN
cntN7Arr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull : tf7State.cntN_bear) : tf7State.cntN

cntN1RawArr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull_raw : tf1State.cntN_bear_raw) : tf1State.cntN_raw
cntN2RawArr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull_raw : tf2State.cntN_bear_raw) : tf2State.cntN_raw
cntN3RawArr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull_raw : tf3State.cntN_bear_raw) : tf3State.cntN_raw
cntN4RawArr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull_raw : tf4State.cntN_bear_raw) : tf4State.cntN_raw
cntN5RawArr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull_raw : tf5State.cntN_bear_raw) : tf5State.cntN_raw
cntN6RawArr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull_raw : tf6State.cntN_bear_raw) : tf6State.cntN_raw
cntN7RawArr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull_raw : tf7State.cntN_bear_raw) : tf7State.cntN_raw

//====================
// Reset handling (rising edge) â€” per horizon F1..F7
//====================
f_is_chart_tf(tf) =>
    timeframe.period == tf

// INV! first-failure latch (persists until chart refresh)

var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All"
        f_reset_eval_all()
        f_reset_tf(tf1State)
        f_reset_tf(tf2State)
        f_reset_tf(tf3State)
        f_reset_tf(tf4State)
        f_reset_tf(tf5State)
        f_reset_tf(tf6State)
        f_reset_tf(tf7State)

    if resetWhich == "F1" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF1))
        f_reset_tf(tf1State)
    if resetWhich == "F2" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF2))
        f_reset_tf(tf2State)
    if resetWhich == "F3" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF3))
        f_reset_tf(tf3State)
    if resetWhich == "F4" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF4))
        f_reset_tf(tf4State)
    if resetWhich == "F5" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF5))
        f_reset_tf(tf5State)
    if resetWhich == "F6" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF6))
        f_reset_tf(tf6State)
    if resetWhich == "F7" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF7))
        f_reset_tf(tf7State)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed and f_forecast_allowed() and (calibrateInBackground or showTable or showEvalSection)
if doCal
    for i = 0 to 6
        tfSel = f_idx_to_tfsel(i)
        tfH = array.get(tfForecastArr, i)
        [fc, kb, at, ph, tp, sl] = f_get_params(tfH)
        st = f_get_state_for_tf(tfSel)
        if not na(st)
            f_process_tf(i + 1, tfH, array.get(confForecastArr, i), array.get(outScoreArr, i), array.get(cForecastArr, i), array.get(hForecastArr, i), array.get(lForecastArr, i), array.get(aForecastArr, i), array.get(vRForecastArr, i), array.get(efForecastArr, i), array.get(esForecastArr, i),
                st,
                fc, kb, at, ph, tp, sl,
                alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

// NOTE: f_get_disp_vals reads global inputs: wState, wPullback, wRegime,
//       wTrend, predBinsN, predBins1, dim2Bins, useBullBearCal, alphaN,
//       alpha1, kShrink, kShrinkReg, calMinSamples.  Pine's 14-param limit
//       prevents passing these explicitly.
f_get_disp_vals(_tf, sA, c, atrVal, ef, es, vr, TfState st) =>
    bias = ef > es ? 1 : ef < es ? -1 : 0
    sB = f_pullback_score(c, ef, es, bias)
    sC = vr >= VOL_THRESH_HIGH ? -1.0 : (vr <= VOL_THRESH_LOW ? 1.0 : 0.0)
    // Epsilon PRICE_EPS prevents division by zero on penny stocks or exotic instruments
    atrNorm = atrVal / math.max(c, PRICE_EPS)
    sD = f_trend_regime(ef, es, atrNorm)
    sEns = f_ensemble4(sA, sB, sC, sD, wState, wPullback, wRegime, wTrend)
    if na(sEns) or na(sD)
        [pUpr_t, pFpr_t, pDpr_t] = f_prior3(_tf, sA)
        [pUpr_t, pFpr_t, pDpr_t, 0.0]
    else
        bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, st.qCutsN)
        biasSel = useBullBearCal ? f_bias_from_score(sA) : 0
        if biasSel == 0
            biasSel := bias == 0 ? 1 : bias
        cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        upN_sel  = useBullBearCal ? (biasSel > 0 ? st.upN_bull  : st.upN_bear)  : st.upN
        dnN_sel  = useBullBearCal ? (biasSel > 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
        cntN_raw_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull_raw : st.cntN_bear_raw) : st.cntN_raw
        tempN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
        vecAN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
        vecBN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
        [pUN_t, pFN_t, pDN_t, nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaN, kShrink, kShrinkReg)
        pUN = pUN_t
        pFN = pFN_t
        pDN = pDN_t
        nN = array.get(cntN_raw_sel, bN)
        useCalN = f_can_cal3(nN_t)
        if useCalN
            zUN = f_safe_log(pUN)
            zFN = f_safe_log(pFN)
            zDN = f_safe_log(pDN)
            [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, tempN_sel, vecAN_sel, vecBN_sel)
            pUN := tUN_t
            pFN := tFN_t
            pDN := tDN_t
        if nN < calMinSamples
            [pUpr_t, pFpr_t, pDpr_t] = f_prior3(_tf, sA)
            [pUN_b, pFN_b, pDN_b] = f_blend_prior(pUN, pFN, pDN, pUpr_t, pFpr_t, pDpr_t, nN)
            pUN := pUN_b
            pFN := pFN_b
            pDN := pDN_b
        [pUN, pFN, pDN, nN]

//====================
// Display values â€” N and 1 per horizon
//====================
var float[] dispPUN = array.new_float(7, na)
var float[] dispPFN = array.new_float(7, na)
var float[] dispPDN = array.new_float(7, na)
var float[] dispNN  = array.new_float(7, na)

for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    tfH = array.get(tfForecastArr, i)
    st = f_get_state_for_tf(tfSel)
    if not na(st)
        [pUN_t, pFN_t, pDN_t, nN_t] = f_get_disp_vals(tfH, array.get(outScoreArr, i), array.get(cForecastArr, i), array.get(aForecastArr, i), array.get(efForecastArr, i), array.get(esForecastArr, i), array.get(vRForecastArr, i), st)
        array.set(dispPUN, i, pUN_t)
        array.set(dispPFN, i, pFN_t)
        array.set(dispPDN, i, pDN_t)
        array.set(dispNN,  i, nN_t)

// --- Total resolved samples per TF (across all bins)
totNArr = array.new_float(7, na)
for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    cntN = f_sel_tf_farr(tfSel, cntN1Arr, cntN2Arr, cntN3Arr, cntN4Arr, cntN5Arr, cntN6Arr, cntN7Arr)
    array.set(totNArr, i, f_sum_int_array(cntN))


// Populate rel-value arrays for gating/table (current bar)

for i = 0 to 6
    array.set(relPUN,  i, array.get(dispPUN, i))
    array.set(relPFN,  i, array.get(dispPFN, i))
    array.set(relPDN,  i, array.get(dispPDN, i))
    array.set(relNN,   i, array.get(dispNN, i))
    array.set(relTotN, i, array.get(totNArr, i))

forecastAllowed = enableForecast and f_forecast_allowed()

curBrierRaw = f_getBrier_raw(relFilterTF)
curBrier = nz(curBrierRaw, 0.5)
relBull = relFilterTF == "F1" ? isBull1 : relFilterTF == "F2" ? isBull2 : relFilterTF == "F3" ? isBull3 : relFilterTF == "F4" ? isBull4 : relFilterTF == "F5" ? isBull5 : relFilterTF == "F6" ? isBull6 : isBull7

// === Population Management (Variante B-Safe) ===
// Evidence check counts SPECIFIC subset samples (Bull OR Bear).
totSampSub = f_get_total_samples(relFilterTF, relBull)

// Reliability check aligns with GLOBAL Brier score (Bull + Bear).
// Optimization: Compute global sum only if strictly needed (Forecast+Filter+Split active).
totSampGlob = totSampSub
if useBullBearCal and forecastAllowed and useRelFilter
    totSampGlob := f_get_total_samples(relFilterTF, true) + f_get_total_samples(relFilterTF, false)

// HELPER: Fail-Closed Gates
f_fc_bool(x) => x == true
f_fc_num(x)  => not na(x)

// VARIANT B: Explicit Forecast Activation
// If forecastAllowed is na, we treat it as false (Baseline Mode).
useForecast = (forecastAllowed == true)

// GATE 1: Reliability
// If Forecast OFF or Filter OFF -> Pass (True).
// If ON -> STRICT Fail-Closed (na blocks).
// Uses GLOBAL metrics (Brier + Global Count) to match data source.
reliabilityOk =
     (not useForecast)  ? true :
     (not useRelFilter) ? true :
     (f_fc_num(curBrierRaw) and f_fc_num(totSampGlob) and (totSampGlob > 0) and (curBrierRaw <= maxBrier))

// GATE 2: Evidence
// Uses SPECIFIC subset count.
evidenceOk =
     (not useForecast)  ? true :
     (not evidenceGate) ? true :
     (f_fc_num(totSampSub) and (totSampSub >= evidenceMinTotal))

[pRelU_t, pRelF_t, pRelD_t, nRel_t, totRel_t] = f_get_rel_vals(relFilterTF)
pRelU = pRelU_t
pRelF = pRelF_t
pRelD = pRelD_t
nRel  = nRel_t
totRel = totRel_t

[decisionOk_t, _, _, decisionEdge_t] = f_decision_quality(pRelU, pRelF, pRelD, nRel, totRel)
decisionOk = decisionOk_t
decisionEdge = decisionEdge_t

[evalEce, evalDriftPP, evalN] = f_eval_metrics_for_tf(relFilterTF)
[evalSuccessRate, evalSuccessN] = f_eval_success_for_tf(relFilterTF)
evalSuccessTxt = (evalSuccessN > 0 and not na(evalSuccessRate)) ? str.tostring(evalSuccessRate * 100.0, "#.0") + "%" : "0%"
evalModeTxt = evalMode == "LiveOnly" ? "LiveOnly" : "History+Live"
evalSuccessHudTxt = "Success rate (" + evalModeTxt + "): " + evalSuccessTxt + " (N=" + str.tostring(evalSuccessN) + ")"
// A5 â€“ store ECE for next bar's recal decision
prevEvalEce := evalEce
eceOk = (not useEceGate) or (not na(evalEce) and evalEce <= eceMax)
driftOk = (not useDriftGate) or (not na(evalDriftPP) and math.abs(evalDriftPP) <= driftMaxPP)
evalOk = (not forecastAllowed) or (eceOk and driftOk)
evalSoftHit = useEvalPenalty and ((not na(evalEce) and evalEce >= eceWarn) or (not na(evalDriftPP) and math.abs(evalDriftPP) >= driftWarnPP))
confGate = evalSoftHit ? f_clamp01(confidence * (1.0 - evalPenalty)) : confidence

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown (+ eval penalty)
// Fail-Open Helper
f_soft(bool x) => 
    // Fix for "na() expects float" error in strict contexts:
    // We check if the boolean is neither true nor false.
    (x == true) ? true : (x == false) ? false : true

ddOk        = (ddHardGateHit == false)

// Gating Logic (Refactored 2026-02-14)
// gateLongNow now uses soft checks for MTF/Macro and removes Confidence hard-block.
gateLongNow  = ddOk and f_soft(mtfOkLong)  and f_soft(macroGateLong) and vwtLongEntryOk
gateShortNow = ddOk and f_soft(mtfOkShort) and f_soft(macroGateShort) and vwtShortEntryOk

decisionOkSafe     = (not use3Way) ? true : na(decisionEdge) ? true : f_fc_bool(decisionOk)
isHighConf         = (not na(confGate)) and (confGate >= abstainOverrideConf)
decisionFinal      = decisionOkSafe or isHighConf
cooldownOkSafe     = (cooldownOk == true)
nearCloseOk        = (blockNearClose == false)

// Session Check
inSession = (not useSessionFilter) or (not na(time(timeframe.period, sessionWin)))

// CORE ENTRY ALLOWANCE (gated, parity with indicator + session filter)
signalOnCloseOnly = alertOnBarCloseOnly
signalGateConfirmed = barstate.isconfirmed or (not signalOnCloseOnly and barstate.isrealtime)

allowEntry =
     inSession
 and signalGateConfirmed
 and cooldownOkSafe
 and nearCloseOk
 and (reliabilityOk == true)
 and (evidenceOk == true)
 and (evalOk == true)
 and (not abstainGate or decisionFinal)

// EntriesOnly exit-hold must follow configured cooldown duration (Bars/Minutes).
// Use base (confidence-insensitive) cooldown for hold window so high-confidence
// entries don't get a shortened protection period.
holdCooldownBars = cooldownBars
holdCooldownMin  = cooldownMinutes
entryOnlyExitHoldActive =
     (cooldownTriggers == "EntriesOnly")
 and pos != 0
 and (
        cooldownMode == "Bars"
            ? (holdCooldownBars >= 1 and (not na(enBar)) and (bar_index - enBar <= holdCooldownBars))
            : (holdCooldownMin  >= 1 and (not na(enTime)) and (time - enTime <= (holdCooldownMin * 60 * 1000)))
    )
allowExitBase = signalGateConfirmed and (not entryOnlyExitHoldActive)
// EntriesOnly hold exceptions are evaluated inside exit blocks:
// - allowed during hold: EXIT SL, EXIT TP, directional Engulfing exits.
// - blocked during hold: USI/structure/stalemate and other non-exception exits.
allowExitDuringHold = signalGateConfirmed and entryOnlyExitHoldActive
allowExitLong = allowExitBase or allowExitDuringHold
allowExitShort = allowExitBase or allowExitDuringHold

// Initialize signal flags
buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false
// Track USI trigger source (reset every bar)
_trigUsiBuy    = false
_trigUsiSell   = false
_trigUsiCoBuy  = false
_trigUsiCoSell = false

// v6.2.13: Track reversal entry type for EXIT/COVER labels and REV-BUY/SHORT plotshapes
bool isRevBuy   = false
bool isRevShort = false


// Strategy token-budget mode: UI table and pulse debug plots removed in strategy build.
// Strategy token budget safeguard
// full table rendering is disabled
// token limits
// primary visualization surface


//====================
// Signal Logic (Post-Forecast)
//====================
volSma = ta.sma(volume, volLen)
volOk = (not useVolConfirm) or (not na(volume) and volume > volSma * volMult)

// Global Volume Ratio
float volRatioG = (not na(volume) and not na(volSma) and volSma > 0) ? volume / volSma : 0.0
bool hugeVolG   = volRatioG >= rescueVolMult

// Rescue Logic: Replaced Volume-only trigger with Price Impulse trigger (v6.2)
// User Intent: Prevent falling knife entries on huge bearish volume.
// Require "Considerable Price Increase" (Impulse Candle > 0.7 ATR). Lowered from 1.0 to catch valid signals.
float bodySize = math.abs(close - open)
bool isImpulse = bodySize > (atr * rescueImpulseATR)

bool allowRescueLong  = isImpulse and (close > open) and signalGateConfirmed and cooldownOkSafe
bool allowRescueShort = isImpulse and (close < open) and signalGateConfirmed and cooldownOkSafe

// Legacy support (OR logic)
bool allowRescue = (allowRescueLong or allowRescueShort)

// D3 â€“ Regression Slope Oscillator Calculation
float regSlopeOsc = 0.0
bool regSlopeLongOk = true
bool regSlopeShortOk = true

if useRegSlope
    regSlopeOsc := f_calc_reg_slope_osc(close, rsMinRange, rsMaxRange, rsStep)
    
    // Gate Logic:
    // Long: Oscillator > 0 (Trend is Up)
    // Short: Oscillator < 0 (Trend is Down)
    regSlopeLongOk  := regSlopeOsc > 0
    regSlopeShortOk := regSlopeOsc < 0

// C1 â€“ Pre-signal momentum (RSI alignment)
chartRsi = ta.rsi(close, rsiStateLen)
preMomLongOk  = (not usePreMomentum) or (not na(chartRsi) and chartRsi >= preMomRsiLo)
preMomShortOk = (not usePreMomentum) or (not na(chartRsi) and chartRsi <= preMomRsiHi)

// C3 â€“ EMA acceleration (gap expanding)
emaGap     = math.abs(emaF - emaS) / math.max(close, PRICE_EPS)
emaGapPrev = math.abs(emaF[1] - emaS[1]) / math.max(close[1], PRICE_EPS)
// NOTE: small 5% tolerance added to prevent repainting rejection on borderline bars
emaAccelTol = 0.05 * (emaGapPrev + 0.0001)
emaAccelLongOk  = (not useEmaAccel) or (emaGap >= (emaGapPrev - emaAccelTol))
emaAccelShortOk = (not useEmaAccel) or (emaGap <= (emaGapPrev + emaAccelTol))

// C4 â€“ VWAP alignment (intraday only; vwapVal computed in Zones section)
vwapLongOk  = (not useVwap) or (not timeframe.isintraday) or (na(vwapVal) or close >= vwapVal)
vwapShortOk = (not useVwap) or (not timeframe.isintraday) or (na(vwapVal) or close <= vwapVal)

fcGateLong  = f_entry_forecast_gate(true)
fcGateShort = f_entry_forecast_gate(false)

// Fetch probabilities for strict ChoCH filtering (Global Scope)
[pU, pF, pD, nBin_prob, total_prob] = f_get_rel_vals(entryFcTF)

// Global directional probability floor (applies to all entry paths)
bool hardLongProbOk = (not enforceGlobalProbFloor) or ((openWindowBypassEntries and inRevOpenWindowLong) ? true : ((not na(pU)) and pU >= scoreMinPuEff))
bool hardShortProbOk = (not enforceGlobalProbFloor) or ((openWindowBypassEntries and inRevOpenWindowShort) ? true : ((not na(pD)) and pD >= scoreMinPdEff))

// Pullback depth
pbLow = ta.lowest(low, pbLookback)
pbHigh = ta.highest(high, pbLookback)
pbDepthLong = (emaF - pbLow) / math.max(atr, PRICE_EPS)
pbDepthShort = (pbHigh - emaF) / math.max(atr, PRICE_EPS)

touchEmaF_Long  = low <= emaF and close >= emaF
touchEmaF_Short = high >= emaF and close <= emaF

bullReversal = close > open and close > emaF and low <= emaF
bearReversal = close < open and close < emaF and high >= emaF

// 3-candle context engulfing filter (noise reduction)
prevThreeBear = (open[3] > close[3]) and (open[2] > close[2]) and (open[1] > close[1])
prevThreeBull = (open[3] < close[3]) and (open[2] < close[2]) and (open[1] < close[1])
prevBody = math.abs(open[1] - close[1])
bullBody = close - open
bearBody = open - close

bullEngulf3 = prevThreeBear and (close > open) and (close >= open[1]) and (close[1] >= open) and ((not engulfingRequireBodyDominance) or (bullBody > prevBody))
bearEngulf3 = prevThreeBull and (open > close) and (open >= close[1]) and (open[1] >= close) and ((not engulfingRequireBodyDominance) or (bearBody > prevBody))

// Standard Engulfing (No 3-candle filter)
bullEngulfStd = (close > open) and (close >= open[1]) and (close[1] >= open) and ((not engulfingRequireBodyDominance) or (bullBody > prevBody))
bearEngulfStd = (open > close) and (open >= close[1]) and (open[1] >= close) and ((not engulfingRequireBodyDominance) or (bearBody > prevBody))

engulfLongOk = (not useEngulfing3Filter) or bullEngulf3
engulfShortOk = (not useEngulfing3Filter) or bearEngulf3

setOkLong  = (not requireSET) or setLong
setOkShort = (not requireSET) or setShort

// NOTE: Tolerance added to Pullback Depth (0.25 ATR) to handle repaint/wick differences
pbTol = 0.25
pullbackLongOk  = trendUpSmooth and bullBias and (pbDepthLong >= (pbMinATR - pbTol)) and (pbDepthLong <= (pbMaxATR + pbTol)) and (close > emaS)
pullbackShortOk = trendDnSmooth and bearBias and (pbDepthShort >= (pbMinATR - pbTol)) and (pbDepthShort <= (pbMaxATR + pbTol)) and (close < emaS)

// Breakout
var float lastSwingHigh = na
var float lastSwingLow  = na
var int lastSwingHighBar = na
var int lastSwingLowBar  = na
bool chochFastPresetEff = chochScalpPreset and not chochScalpSaferPreset
bool chochSaferPresetEff = chochScalpSaferPreset
int swingREff = (chochFastPresetEff or chochSaferPresetEff) ? math.max(1, swingR) : swingR
string breakoutSourceEff = (chochFastPresetEff or chochSaferPresetEff) ? "Wick" : breakoutSource
string chochSignalModeEff = chochFastPresetEff ? "Ping (Fast)" : chochSaferPresetEff ? "Ping+Verify" : chochSignalMode
ph = ta.pivothigh(high, swingL, swingREff)
pl = ta.pivotlow(low,  swingL, swingREff)
// Snapshot swing levels BEFORE pivot mutation so close[1] comparisons
// reference the level that was live on the previous bar.
float prevSwingHigh = lastSwingHigh
float prevSwingLow  = lastSwingLow
if not na(ph)
    lastSwingHigh := ph
    lastSwingHighBar := bar_index
if not na(pl)
    lastSwingLow := pl
    lastSwingLowBar := bar_index
if swingMaxAgeBars > 0
    if not na(lastSwingHighBar) and (bar_index - lastSwingHighBar > swingMaxAgeBars)
        lastSwingHigh := na
        lastSwingHighBar := na
    if not na(lastSwingLowBar) and (bar_index - lastSwingLowBar > swingMaxAgeBars)
        lastSwingLow := na
        lastSwingLowBar := na

// Breakout Logic (Close vs Wick)
bool breakHigh = false
bool breakLow  = false

bool _xoWick = ta.crossover(high, lastSwingHigh)
bool _xuWick = ta.crossunder(low, lastSwingLow)

if breakoutSourceEff == "Close"
    breakHigh := (not na(lastSwingHigh)) and (not na(prevSwingHigh)) and close > lastSwingHigh and close[1] <= prevSwingHigh
    breakLow  := (not na(lastSwingLow)) and (not na(prevSwingLow)) and close < lastSwingLow  and close[1] >= prevSwingLow
else // Wick
    if not na(lastSwingHigh)
        breakHigh := _xoWick
    if not na(lastSwingLow)
        breakLow  := _xuWick

breakoutLong  = not na(lastSwingHigh) and breakHigh
breakoutShort = not na(lastSwingLow)  and breakLow

// Expanded Logic for Sweep/Reclaim Mode
bool sweepHigh = false
bool reclaimLow = false

// Pre-calc cross to avoid conditional execution warning
bool cx_sweepHigh = ta.crossunder(low, lastSwingHigh)
bool cx_reclaimLow = ta.crossover(high, lastSwingLow)

if structureLogic == "SMC+Sweep" and not na(lastSwingHigh) and not na(lastSwingLow)
    // Sweep High (Bearish Reversal Pattern): Price crossed above High then fell back below
    if breakoutSourceEff == "Close"
        sweepHigh := (not na(prevSwingHigh)) and close < lastSwingHigh and high > lastSwingHigh and close[1] > prevSwingHigh
        reclaimLow := (not na(prevSwingLow)) and close > lastSwingLow and low < lastSwingLow and close[1] < prevSwingLow
    else // Wick (Crossunder/Crossover Logic matches Reference Script)
        sweepHigh := cx_sweepHigh
        reclaimLow := cx_reclaimLow

// Liquidity Sweeps (SMC)
bool isSweep_Bull = not na(lastSwingLow) and (low < lastSwingLow) and (close > lastSwingLow)
bool isSweep_Bear = not na(lastSwingHigh) and (high > lastSwingHigh) and (close < lastSwingHigh)
int barsSinceSweep_Bull = ta.barssince(isSweep_Bull)
int barsSinceSweep_Bear = ta.barssince(isSweep_Bear)
bool sweepRecent_Bull = (not na(barsSinceSweep_Bull)) and (barsSinceSweep_Bull <= liqSweepLookback)
bool sweepRecent_Bear = (not na(barsSinceSweep_Bear)) and (barsSinceSweep_Bear <= liqSweepLookback)

// --- Market Structure State (BOS vs ChoCH) ---
var int structState = 0 // 0=Neutral, 1=Bullish, -1=Bearish
bool isChoCH_Long = false
bool isBOS_Long   = false
bool isChoCH_Short = false
bool isBOS_Short   = false
bool chochPingLong = false
bool chochPingShort = false
bool chochVerifyLong = false
bool chochVerifyShort = false

if structureLogic == "Standard"
    // Standard Trend Logic
    if breakoutLong
        chochPingLong := structState == -1
        if not chochPingLong
            isBOS_Long := true
        structState := 1

    if breakoutShort
        chochPingShort := structState == 1
        if not chochPingShort
            isBOS_Short := true
        structState := -1

else // SMC+Sweep (Standard Style)
    if breakoutLong
        chochPingLong := structState == -1
        if not chochPingLong
            isBOS_Long := true
        structState := 1

    if breakoutShort
        chochPingShort := structState == 1
        if not chochPingShort
            isBOS_Short := true
        structState := -1

    if reclaimLow
        chochPingLong := true

    if sweepHigh
        chochPingShort := true

chochVerifyLong := chochPingLong[1] and (not na(lastSwingHigh) and close > lastSwingHigh)
chochVerifyShort := chochPingShort[1] and (not na(lastSwingLow) and close < lastSwingLow)

isChoCH_Long := chochSignalModeEff == "Ping (Fast)" ? chochPingLong : chochSignalModeEff == "Verify (Safer)" ? chochVerifyLong : (chochPingLong or chochVerifyLong)
isChoCH_Short := chochSignalModeEff == "Ping (Fast)" ? chochPingShort : chochSignalModeEff == "Verify (Safer)" ? chochVerifyShort : (chochPingShort or chochVerifyShort)

// Single-fire canonical event: Ping bar only (for recency clocks, scores, isBreakout).
// In Ping+Verify mode this is the Ping bar; in other modes it equals isChoCH_*.
// Display/label logic continues to use isChoCH_Long/Short for both Ping and Verify bars.
chochEventLong = chochSignalModeEff == "Ping+Verify" ? chochPingLong : isChoCH_Long
chochEventShort = chochSignalModeEff == "Ping+Verify" ? chochPingShort : isChoCH_Short

// Fail-closed signal subconditions: any na => deny (== true coerces na to false)
fcGateLongSafe  = (fcGateLong == true)
fcGateShortSafe = (fcGateShort == true)
volOkSafe       = (volOk == true)
setOkLongSafe   = (setOkLong == true)
setOkShortSafe  = (setOkShort == true)
pullbackLongOkSafe  = (pullbackLongOk == true)
pullbackShortOkSafe = (pullbackShortOk == true)
touchEmaF_LongSafe  = (touchEmaF_Long == true)
touchEmaF_ShortSafe = (touchEmaF_Short == true)
crossClose_EmaF_upSafe   = (crossClose_EmaF_up == true)
crossClose_EmaF_downSafe = (crossClose_EmaF_down == true)
bullReversalSafe = (bullReversal == true)
bearReversalSafe = (bearReversal == true)
trendUpSafe      = (trendUp == true)
trendDnSafe      = (trendDn == true)
breakoutLongSafe  = (breakoutLong == true)
breakoutShortSafe = (breakoutShort == true)
trendFlipUpSafe   = (trendFlipUp == true)
trendFlipDownSafe = (trendFlipDown == true)
reclaimUpSafe     = (reclaimUp == true)
reclaimDownSafe   = (reclaimDown == true)
regSlopeLongOkSafe  = (regSlopeLongOk == true)
regSlopeShortOkSafe = (regSlopeShortOk == true)

// Combined signal enhancement filter (Soft-AND / Fail-Open)
// All these were previously "Safe" (na -> false). Now convert to Fail-Open (na -> true).
// Important: Liquidity, Momentum, USI should be primary drivers, so we keep `safe` checks only if they are critical.
// But per request: "Features should help when present, but fail-open when absent".

enhLongOk  = f_soft(adxOk) and f_soft(rocLongOk) and f_soft(volEnsLongOk) and f_soft(preMomLongOk) and f_soft(emaAccelLongOk) and f_soft(vwapLongOk) and f_soft(regSlopeLongOk)
enhShortOk = f_soft(adxOk) and f_soft(rocShortOk) and f_soft(volEnsShortOk) and f_soft(preMomShortOk) and f_soft(emaAccelShortOk) and f_soft(vwapShortOk) and f_soft(regSlopeShortOk)

// Score Engine Helpers (Option C)
f_score_add(bool cond, int points) => cond ? points : 0
f_penalty(bool cond, int penalties) => cond ? penalties : 0

hybridLongTrigger  = touchEmaF_LongSafe  and (crossClose_EmaF_upSafe   or bullReversalSafe)
hybridShortTrigger = touchEmaF_ShortSafe and (crossClose_EmaF_downSafe or bearReversalSafe)

// v6.2.7 Refactor: Named bypass variable for clarity
// v6.2.9: Added barstate.isconfirmed to prevent intra-bar evaluation (parity with allowEntry/allowRescue)
int barsSinceChoCH_L = ta.barssince(chochEventLong)
int barsSinceChoCH_S = ta.barssince(chochEventShort)
allowRevBypass = allowNeuralReversals and signalGateConfirmed and cooldownOkSafe and (isChoCH_Long or isChoCH_Short)

// Signals
// v6.2.11: allowRevBypass enters this block even when pos != 0 so reversal
// signals are computed BEFORE the state machine. Phase 1 (COVER/EXIT) sets
// pos := 0, then Phase 2 can immediately use the pre-computed buySignal.
if (pos == 0 and (allowEntry or allowRescue)) or allowRevBypass

    // Recency (Global Scope inside loop for safety)
    bool revRecencyOkL   = (not na(barsSinceChoCH_L)) and (barsSinceChoCH_L <= revRecencyBars or volRatioG >= rescueVolMult)
    bool revRecencyOkS   = (not na(barsSinceChoCH_S)) and (barsSinceChoCH_S <= revRecencyBars or volRatioG >= rescueVolMult)

    // Reversal Logic (Global)
    // NA safety handled by f_fc_bool wrapper on revBuyGlobal/revShortGlobal below.
    // v6.2.10: Restore original lightweight gates. Rev-buys bypass MTF, Macro,
    //   and SMC (these are standard-entry filters that contradict reversal purpose).
    //   Only ddOk (portfolio drawdown) is kept as a hard safety gate.
    // v6.2.11: Lowered hugeVol threshold from 0.40 to 0.20 (see Indicator comment).
    //   Require directional impulse candle on rescue path.
    // v6.2.37: Allow Engulfing signals to bypass strict ATR Impulse requirement.
    bool impulseLong  = (isImpulse and (close > open)) or bullEngulf3
    bool impulseShort = (isImpulse and (close < open)) or bearEngulf3
    // v6.2.20: open-window bypass can be scoped by side/engine/mode
    bool bypassRevLong   = inRevOpenWindowLong
    bool bypassRevShort  = inRevOpenWindowShort
    // v6.2.35: enforce hard REV-BUY floor (pU >= 0.25) to match Indicator logic.
    // Lowered from 0.37 to 0.25 to allow Oversold Bounce (Rescue) trades.
    // Fail-open: when bypass (open window) is active, floor drops to 0 so na-prob doesn't block entry.
    float revBuyMinProbFloor = bypassRevLong ? 0.0 : 0.25
    float revShortMinProbFloor = bypassRevShort ? 0.0 : 0.25
    // Rescue Logic: HugeVol OR BullEngulf3. Min Prob also lowered to 0.25.
    bool probOkGlobal    = (na(pU) or pU >= revBuyMinProbFloor) and (bypassRevLong or ((pU >= revMinProb) or ((hugeVolG or bullEngulf3) and pU >= 0.25 and impulseLong)))
    bool probOkGlobalS   = (na(pD) or pD >= revShortMinProbFloor) and (bypassRevShort or ((pD >= revMinProb) or ((hugeVolG or bearEngulf3) and pD >= 0.25 and impulseShort)))
    
    // SMC Filter: If enabled, requires recent sweep
    // A Reversal Buy requires a Bullish Sweep (Stop Run on Lows)
    // allowRescue (Volume > 1.5x) allows bypassing strict SMC Structure (Restored v6.2)
    // Updated to use allowable rescue Direction (Impulse)
    bool smcOkL = (not useLiqSweep) or sweepRecent_Bull or allowRescueLong
    bool smcOkS = (not useLiqSweep) or sweepRecent_Bear or allowRescueShort
    
    // Global Gate: allowNeuralReversals
    // Neural Reversals: Fail-Open VolOk. ProbOkGlobal remains strict.
    bool revBuyGlobal    = allowNeuralReversals and ddOk and revRecencyOkL and smcOkL and chochEventLong and probOkGlobal and hardLongProbOk and f_soft(volOk) and vwtLongEntryOk
    bool revShortGlobal  = allowNeuralReversals and ddOk and revRecencyOkS and smcOkS and chochEventShort and probOkGlobalS and hardShortProbOk and f_soft(volOk) and vwtShortEntryOk

    // v6.2.13: Export reversal flags for label rendering
    isRevBuy   := revBuyGlobal
    isRevShort := revShortGlobal

    // Engine-specific signals only when standard entry is allowed (pos==0 + allowEntry or allowRescue).
    bool standardEntryOk = (pos == 0) and (allowEntry or allowRescue)

    // v6.2.X: FAST BUY Architecture - Fail-Open Priority
    // 1. Liquidity (volume gate) = Soft
    bool liqOk_L = f_soft(volOk)
    bool liqOk_S = f_soft(volOk)

    // 2. Momentum (forecast gate) = Soft
    bool momOk_L = f_soft(fcGateLong)
    bool momOk_S = f_soft(fcGateShort)

    // 3. Engine Features (setups/pullbacks) = Soft
    bool engOk_L = f_soft(setOkLong)  and f_soft(pullbackLongOk)
    bool engOk_S = f_soft(setOkShort) and f_soft(pullbackShortOk)

    // --- SCORE ENGINE CALCULATION (Option C) - Strategy Sync ---
    // 1. USI Evidence (use existing global USI lines/states)
    float _uMax = usiMaxEnv
    float _uMin = usiMinEnv
    bool usiCrossUp   = _usiXUp
    bool usiCrossDown = _usiXDn
    bool usiSweepUp   = usiCrossUp and (usiLine5[1] < _uMin[1])
    bool usiSweepDown = usiCrossDown and (usiLine5[1] > _uMax[1])

    int scoreL = 0
    int scoreS = 0
    
    if useUsi
        scoreL += f_score_add(usiCrossUp, wUsiEff) + f_score_add(usiSweepUp, (wUsiEff + 1) / 2)
        scoreS += f_score_add(usiCrossDown, wUsiEff) + f_score_add(usiSweepDown, (wUsiEff + 1) / 2)
        // Add residual state score if cross happened earlier (supports late entries)
        scoreL += f_score_add(usiBullState and not usiCrossUp, (wUsiEff + 1) / 2)
        scoreS += f_score_add(usiBearState and not usiCrossDown, (wUsiEff + 1) / 2)

    // 2. Liquidity Evidence
    scoreL += f_score_add(reclaimUpSafe, wLiquidityEff) + f_score_add(chochEventLong, wLiquidityEff)
    scoreS += f_score_add(reclaimDownSafe, wLiquidityEff) + f_score_add(chochEventShort, wLiquidityEff)

    // 3. Momentum
    scoreL += f_score_add(rocLongOk, wMomentumEff) + f_score_add(adxOk, (wMomentumEff + 1) / 2) + f_score_add(hugeVolG and (close > open), (wMomentumEff + 1) / 2)
    scoreS += f_score_add(rocShortOk, wMomentumEff) + f_score_add(adxOk, (wMomentumEff + 1) / 2) + f_score_add(hugeVolG and (close < open), (wMomentumEff + 1) / 2)

    // 4. Trend Context
    scoreL += f_score_add(trendUpSafe, wTrendContextEff)
    scoreS += f_score_add(trendDnSafe, wTrendContextEff)

    // 5. Chop Penalty
    bool isBreakoutL = isImpulse or hugeVolG or bullEngulf3 or chochEventLong or reclaimUpSafe
    bool isBreakoutS = isImpulse or hugeVolG or bearEngulf3 or chochEventShort or reclaimDownSafe
    bool isBreakout = isBreakoutL or isBreakoutS
    bool isChopL = (not na(adxRaw) and adxRaw < 20) and (atr / math.max(close, PRICE_EPS) < 0.005) and not isBreakoutL
    bool isChopS = (not na(adxRaw) and adxRaw < 20) and (atr / math.max(close, PRICE_EPS) < 0.005) and not isBreakoutS
    bool chopRisk = isChopL or isChopS
    scoreL += f_penalty(isChopL, wChopPenaltyEff)
    scoreS += f_penalty(isChopS, wChopPenaltyEff)

    // 6. Engulfing Evidence (Pattern)
    scoreL += f_score_add(bullEngulf3, wEngulfingEff)
    scoreS += f_score_add(bearEngulf3, wEngulfingEff)

    // Final Decision
    // Base eligibility: Position 0, Allow Entry + Drawdown Check (ddOk)
    // Directional rescue eligibility: long rescue only helps long score, short rescue only helps short score
    bool baseEligible = (pos == 0) and ddOk and (allowEntry or allowRescue)
    bool baseEligibleL = (pos == 0) and ddOk and (allowEntry or allowRescueLong)
    bool baseEligibleS = (pos == 0) and ddOk and (allowEntry or allowRescueShort)
    bool scoreProbLongOk = (not na(pU)) and (pU >= scoreMinPuEff)
    bool scoreProbShortOk = (not na(pD)) and (pD >= scoreMinPdEff)
    bool scoreConfLongOk = (not na(confGate)) and (confGate >= scoreMinConfLongEff)
    bool scoreConfShortOk = (not na(confGate)) and (confGate >= scoreMinConfShortEff)

    bool scoreBuy   = baseEligibleL and (scoreL >= scoreThresholdLongEff) and scoreProbLongOk and scoreConfLongOk and vwtLongEntryOk
    bool scoreShort = baseEligibleS and enableShorts and (scoreS >= scoreThresholdShortEff) and scoreProbShortOk and scoreConfShortOk and vwtShortEntryOk

    bool chochVolOk = (not chochReqVol) or volOkSafe

    // Regime Score (Prior) â€” Forecast + USI soft factor
    float regimeScoreL = 0.0
    float regimeScoreS = 0.0
    if not na(pU)
        regimeScoreL += math.max(math.min((pU - 0.50) * 2.0, 0.4), -0.4)
    float rawShort = na(pD) ? 0.0 : (pD - 0.50)
    regimeScoreS += math.max(math.min(rawShort * 2.0, 0.4), -0.4)
    if useUsi
        if qRegimeBuy
            regimeScoreL += 1.0
            regimeScoreS -= 1.0
        else if qRegimeSell
            regimeScoreL -= 1.0
            regimeScoreS += 1.0

    // Veto Logic (hard showstoppers only)
    bool isVetoL = false
    bool isVetoS = false
    if ddOk == false
        isVetoL := true
        isVetoS := true
    if (not na(pU) and pU < 0.30 and regimeScoreL < -0.5)
        isVetoL := true
    if (not na(pD) and pD < 0.30 and regimeScoreS < -0.5)
        isVetoS := true

    if engine == "Hybrid"
        // Base triggers - Softened, split for regime context gate
        bool validTrendEntryL = standardEntryOk and gateLongNow and liqOk_L and momOk_L and engOk_L and enhLongOk and hybridLongTrigger
        bool contextL = (regimeScoreL > 0) or (f_soft(volOk) and f_soft(engulfLongOk))
        gateBuy   = validTrendEntryL and contextL and not isVetoL
        
        // ChoCH Filter (Strict)
        isChoCH_Entry = gateBuy and (structState == -1 or isChoCH_Long) 
        chochFilterOk = (not isChoCH_Entry) or ((na(pU) or pU >= chochMinProbEff) and chochVolOk)
        
        buySignal   := gateBuy and chochFilterOk
        
        bool validTrendEntryS = standardEntryOk and enableShorts and gateShortNow and liqOk_S and momOk_S and engOk_S and enhShortOk and hybridShortTrigger
        bool contextS = (regimeScoreS > 0) or (f_soft(volOk) and f_soft(engulfShortOk))
        gateShort = validTrendEntryS and contextS and not isVetoS
        isChoCH_ShortEntry = gateShort and (structState == 1 or isChoCH_Short) 
        chochShortFilterOk = (not isChoCH_ShortEntry) or ((na(pD) or pD >= chochMinProbEff) and chochVolOk)
        
        shortSignal := gateShort and chochShortFilterOk

    else if engine == "Breakout"
        // Base - Softened
        baseBuy = standardEntryOk and gateLongNow and liqOk_L and momOk_L and trendUpSafe and breakoutLongSafe and enhLongOk and f_soft(engulfLongOk)
        isChoCH_Entry = baseBuy and (structState == -1 or isChoCH_Long)
        chochFilterOk = (not isChoCH_Entry) or ((na(pU) or pU >= chochMinProbEff) and chochVolOk)
        
        buySignal   := baseBuy and chochFilterOk
        
        baseShort = standardEntryOk and enableShorts and gateShortNow and liqOk_S and momOk_S and trendDnSafe and breakoutShortSafe and enhShortOk and f_soft(engulfShortOk)
        isChoCH_ShortEntry = baseShort and (structState == 1 or isChoCH_Short)
        chochShortFilterOk = (not isChoCH_ShortEntry) or ((na(pD) or pD >= chochMinProbEff) and chochVolOk)
        
        shortSignal := baseShort and chochShortFilterOk

    else if engine == "Trend+Pullback"
        buySignal   := standardEntryOk and gateLongNow and (trendFlipUpSafe or reclaimUpSafe) and enhLongOk and f_soft(engulfLongOk)
        shortSignal := standardEntryOk and enableShorts and gateShortNow and (trendFlipDownSafe or reclaimDownSafe) and enhShortOk and f_soft(engulfShortOk)
    else // Loose
        buySignal   := standardEntryOk and gateLongNow and crossClose_EmaF_upSafe and enhLongOk and f_soft(engulfLongOk)
        shortSignal := standardEntryOk and enableShorts and gateShortNow and crossClose_EmaF_downSafe and enhShortOk and f_soft(engulfShortOk)

    // v6.2.11: Hard probability floor for standard entries.
    // The forecast gate (fcGateLongSafe) silently passes when forecastAllowed is
    // false, leaving NO directional probability check on engine signals.
    // Safety net: block standard long when pU < 0.50, short when pD < 0.50.
    // Only active when forecast gate is not already checking probability.
    // When forecastAllowed is true, fcGateLongSafe already enforces minDirProb.
    // Reversal entries have their own probability handling (probOkGlobal) and
    // are injected AFTER this check, so they are not affected.
    
    // REFACTOR 2026-02-14: REMOVED HARD FLOOR
    // Why: We want fail-open behavior. If fcModel didn't block it, we trust the core evidence.
    // Low prob is a penalty, not a block.
    // if not forecastAllowed
    //     if buySignal and (na(pU) or pU < 0.50)
    //         buySignal := false
    //     if shortSignal and (na(pD) or pD < 0.50)
    //         shortSignal := false

    // --- SCORE ENGINE INTEGRATION (Option C) ---
    // Allows high-quality setups to bypass engine rigidity.
    // Score signals act as an Alternative Entry Trigger.
    bool scoreLongWin = false
    bool scoreShortWin = false
    if useScoreEntriesEff
        bool scoreCtxLongOk  = (not scoreRequireDirectionalContextEff) or trendUpSafe or (useUsi and usiStackDir == 1)
        bool scoreCtxShortOk = (not scoreRequireDirectionalContextEff) or trendDnSafe or (useUsi and usiStackDir == -1)
        bool scoreChopVeto = scoreChopHardVetoEff and chopRisk and (wChopPenaltyEff < 0)
        scoreLongWin  := (scoreBuy and scoreCtxLongOk) and not scoreChopVeto
        scoreShortWin := (scoreShort and scoreCtxShortOk) and not scoreChopVeto
        // Score-based precedence: if score fires, it wins over regular engine path.
        if scoreLongWin
            buySignal := true
            shortSignal := false
        else if scoreShortWin
            shortSignal := true
            buySignal := false

    // Unified Neural Reversal injection (all engines, including Loose)
    if allowNeuralReversals
        buySignal   := buySignal   or revBuyGlobal
        shortSignal := shortSignal or revShortGlobal

    // Keep score precedence when opposite-side reversal also fires on same bar.
    if scoreLongWin and revShortGlobal
        shortSignal := false
    if scoreShortWin and revBuyGlobal
        buySignal := false

    // Global probability floors: block all entry paths (engine, score, and reversal)
    buySignal := buySignal and hardLongProbOk
    shortSignal := shortSignal and hardShortProbOk

    if buySignal and shortSignal
        buySignal := false
        shortSignal := false

preBuyNow = false
preShortNow = false
float preGapLong  = na   // distance to trigger (points)
float preGapShort = na
if pos == 0 and allowEntry
    float preDist = preWarnDistATR * atr
    distOk = (not na(preDist)) and (preDist > 0) and (not na(atr)) and (atr > 0)
    preSetOkLong = (not requireSET) or (preSetPulseOnly ? setLongPulse : setLong)
    preSetOkShort = (not requireSET) or (preSetPulseOnly ? setShortPulse : setShort)
    
    // v6.3.2: USI Filter for Pre-Signals
    bool _usiBear = useUsi and useUsiTrendOverride and usiStackDir == -1
    bool _usiBull = useUsi and useUsiTrendOverride and usiStackDir == 1

    if engine == "Hybrid"
        // Hybrid: distance = how far close is below emaF
        preGapLong  := (not na(emaF)) ? math.max(0.0, emaF - close) : na
        preGapShort := (not na(emaF)) ? math.max(0.0, close - emaF) : na
        preBuyNow := gateLongNow and fcGateLongSafe and volOkSafe and preSetOkLong and pullbackLongOkSafe and touchEmaF_LongSafe and not (crossClose_EmaF_upSafe or bullReversalSafe) and not _usiBear
        preShortNow := enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and preSetOkShort and pullbackShortOkSafe and touchEmaF_ShortSafe and not (crossClose_EmaF_downSafe or bearReversalSafe) and not _usiBull
    else if engine == "Breakout"
        nearLong = distOk and (not na(lastSwingHigh)) and (close <= lastSwingHigh) and ((lastSwingHigh - close) <= preDist)
        nearShort = distOk and (not na(lastSwingLow)) and (close >= lastSwingLow) and ((close - lastSwingLow) <= preDist)
        preGapLong  := (not na(lastSwingHigh)) ? math.max(0.0, lastSwingHigh - close) : na
        preGapShort := (not na(lastSwingLow))  ? math.max(0.0, close - lastSwingLow)  : na
        preBuyNow := gateLongNow and fcGateLongSafe and volOkSafe and trendUpSafe and nearLong and not breakoutLongSafe and not _usiBear
        preShortNow := enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and trendDnSafe and nearShort and not breakoutShortSafe and not _usiBull
    else if engine == "Trend+Pullback"
        nearFlipUp = distOk and (not na(emaF)) and (not na(emaS)) and (emaF < emaS) and ((emaS - emaF) <= preDist)
        nearFlipDown = distOk and (not na(emaF)) and (not na(emaS)) and (emaF > emaS) and ((emaF - emaS) <= preDist)
        nearReclaimUp = distOk and (not na(emaF)) and (bullBias == true) and (close < emaF) and ((emaF - close) <= preDist)
        nearReclaimDown = distOk and (not na(emaF)) and (bearBias == true) and (close > emaF) and ((close - emaF) <= preDist)
        preGapLong  := nearFlipUp ? (emaS - emaF) : nearReclaimUp ? (emaF - close) : na
        preGapShort := nearFlipDown ? (emaF - emaS) : nearReclaimDown ? (close - emaF) : na
        preBuyNow := gateLongNow and (nearFlipUp or nearReclaimUp) and not (trendFlipUpSafe or reclaimUpSafe) and not _usiBear
        preShortNow := enableShorts and gateShortNow and (nearFlipDown or nearReclaimDown) and not (trendFlipDownSafe or reclaimDownSafe) and not _usiBull
    else // Loose
        nearEmaFUp = distOk and (not na(emaF)) and (close < emaF) and ((emaF - close) <= preDist)
        nearEmaFDown = distOk and (not na(emaF)) and (close > emaF) and ((close - emaF) <= preDist)
        preGapLong  := nearEmaFUp  ? (emaF - close) : na
        preGapShort := nearEmaFDown ? (close - emaF) : na
        preBuyNow := gateLongNow and nearEmaFUp and not crossClose_EmaF_upSafe and not _usiBear
        preShortNow := enableShorts and gateShortNow and nearEmaFDown and not crossClose_EmaF_downSafe and not _usiBull

preBuyPrev = (preBuyNow[1] == true)
preShortPrev = (preShortNow[1] == true)
preBuyPulse = showPreEntryLabels and preBuyNow and not preBuyPrev
preShortPulse = showPreEntryLabels and preShortNow and not preShortPrev

// PRE-BUY / PRE-SHORT distance in ATR units (0.00 = at trigger)
float preGapATR_L = (not na(preGapLong)  and not na(atr) and atr > 0) ? (preGapLong  / atr) : na
float preGapATR_S = (not na(preGapShort) and not na(atr) and atr > 0) ? (preGapShort / atr) : na

var int barsSinceEntry = 0
if pos != pos[1] and pos != 0
    barsSinceEntry := 0
    enBar := bar_index
else if pos != 0
    barsSinceEntry := bar_index - enBar
else
    enBar := na
    barsSinceEntry := 0

bool canStructExit = (barsSinceEntry >= exitGraceBars)
bool canChochExit = (barsSinceEntry >= math.min(chochGraceBars, exitGraceBars))

// Risk Decay Calculation (Linear interpolation)
// Gated: decay pauses during huge volume shock (prevents premature tightening)
if useAtrRisk and useRiskDecay and barsSinceEntry <= decayBars and not hugeVolG
    float w   = math.min(1.0, float(barsSinceEntry) / float(decayBars))
    // v6.3.1 Fix: Dynamic Risk Decay uses Profile Risk
    // Calculate current target Multipliers
    [dFc, dK, dA, dH, dTp, dSl] = f_get_params(timeframe.period)
    float baseStop = nz(dSl, stopATR) 
    float baseTp   = nz(dTp, tpATR)
    [dStopEff, _dTrailEff] = f_dyn_sl_preset_vals(decayStopATR, trailATR)
    decayStopEff = dStopEff
    
    float cStopM = math.max(0.1, baseStop + (decayStopEff - baseStop) * w)
    float cTpM   = math.max(0.1, baseTp   + (decayTpATR   - baseTp)   * w)
    
    if pos == 1 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
        // Recalculate based on STATIC entry conditions to ensure stability
        targetStop = entryPrice - (cStopM * entryAtr)
        targetTp   = entryPrice + (cTpM   * entryAtr)
        
        // Tighten Only: Higher Stop, Lower TP
        stopPx := math.max(stopPx, targetStop)
        if not useInfiniteTP
            tpPx   := math.min(tpPx, targetTp)
            
    else if pos == -1 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
        targetStop = entryPrice + (cStopM * entryAtr)
        targetTp   = entryPrice - (cTpM   * entryAtr)
        
        // Tighten Only: Lower Stop, Higher TP
        stopPx := math.min(stopPx, targetStop)
        if not useInfiniteTP
            tpPx   := math.max(tpPx, targetTp)

// Dynamic TP Expansion (optional): expands TP as trade progresses in R.
if useAtrRisk and useDynamicTpExpansion and not useInfiniteTP and pos != 0 and not na(tpPx) and not na(entryPrice) and not na(entryAtr)
    [dtFc, dtK, dtA, dtH, dtTp, dtSl] = f_get_params(timeframe.period)
    float initRiskAbs = math.max(PRICE_EPS, nz(dtSl, stopATR) * entryAtr)
    float runRNow = pos == 1 ? ((close - entryPrice) / initRiskAbs) : ((entryPrice - close) / initRiskAbs)
    bool dynTpTrendOk = pos == 1 ? trendUpSafe : trendDnSafe
    bool dynTpConfOk = na(confGate) ? false : confGate >= dynamicTpMinConf
    bool dynTpGateOk = (not dynamicTpRequireTrend or dynTpTrendOk) and (not dynamicTpRequireConf or dynTpConfOk)

    if runRNow >= dynamicTpKickInREff and dynTpGateOk
        float extraAtr = math.min(dynamicTpMaxAddATREff, (runRNow - dynamicTpKickInREff) * dynamicTpAddATRPerREff)
        float targetTpMul = math.max(0.1, nz(dtTp, tpATR) + extraAtr)
        float dynamicTpPx = pos == 1 ? (entryPrice + targetTpMul * entryAtr) : (entryPrice - targetTpMul * entryAtr)
        tpPx := pos == 1 ? math.max(tpPx, dynamicTpPx) : math.min(tpPx, dynamicTpPx)

// Dynamic SL Profile (optional): early widening then progressive tightening by R.
if useAtrRisk and useDynamicSlProfile and pos != 0 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
    [dsFc, dsK, dsA, dsH, dsTp, dsSl] = f_get_params(timeframe.period)
    float baseSlMul = nz(dsSl, stopATR)
    float initRiskAbs = math.max(PRICE_EPS, baseSlMul * entryAtr)
    float runRNow = pos == 1 ? ((close - entryPrice) / initRiskAbs) : ((entryPrice - close) / initRiskAbs)
    bool dynSlTrendOk = pos == 1 ? trendUpSafe : trendDnSafe
    bool dynSlConfOk = na(confGate) ? false : confGate >= dynamicSlMinConf
    bool dynSlGateOk = (not dynamicSlRequireTrend or dynSlTrendOk) and (not dynamicSlRequireConf or dynSlConfOk)

    if dynSlGateOk
        float widenAtr = 0.0
        if dynamicSlWidenUntilR > 0 and runRNow >= 0 and runRNow < dynamicSlWidenUntilR
            widenAtr := dynamicSlMaxWidenATR * (1.0 - (runRNow / dynamicSlWidenUntilR))
        float tightenAtr = runRNow >= dynamicSlTightenStartR ? math.min(dynamicSlMaxTightenATR, (runRNow - dynamicSlTightenStartR) * dynamicSlTightenATRPerR) : 0.0
        float netAdjAtr = widenAtr - tightenAtr
        float targetSlMul = math.max(0.1, baseSlMul + netAdjAtr)
        float dynamicStopPx = pos == 1 ? (entryPrice - targetSlMul * entryAtr) : (entryPrice + targetSlMul * entryAtr)

        bool allowWidenNow = na(trailPx)
        if pos == 1
            if dynamicStopPx > stopPx
                stopPx := dynamicStopPx
            else if dynamicStopPx < stopPx and allowWidenNow
                stopPx := dynamicStopPx
        else
            if dynamicStopPx < stopPx
                stopPx := dynamicStopPx
            else if dynamicStopPx > stopPx and allowWidenNow
                stopPx := dynamicStopPx

// Capturing exit reasons for debugging/transparency
string tempExitReason = ""

if pos == 1 and allowExitLong
    if useAtrRisk
        trailPx := f_update_trail(true, entryPrice, atr, stopPx, trailPx)
    [rHit, rMsg] = f_risk_exit_hit(true, stopPx, tpPx, trailPx)
    
    // TP Filtering (Hold Winner)
    if rHit and rMsg == "TP" and confGate >= exitConfTP
        rHit := false 
    
    // Check for Reversal Exit (ChoCH Down)
    // breakLong = bearish EMA break; isChoCH_Short = bearish structure reversal
    // v6.2.6: ChoCH exits now respect a minimum 2-bar grace.
    structHit = ((breakLong and canStructExit) or (isChoCH_Short and canChochExit))

    // ChoCh Filtering (Confirm Reversal)
    // Only exit if the Down Probability (pD) is high enough
    if structHit and not na(pD) and pD < exitConfChoCh
        structHit := false
    
    // Engulfing Contextual Exit (Option 1 - User Configurable)
    bool engExitHit = false
    bool engTightenHit = false
    if useEngulfExit and bearEngulf3
        if engulfExitMode == "Contextual Exit"
            if ((usiStackDir == -1) or usiBearState) or (outScore1 < -0.05) or not f_soft(fcGateLong)
                engExitHit := true
        else if engulfExitMode == "Tighten Risk"
            engTightenHit := true

    if engTightenHit
        float proposedStop = close - (engulfTightenMult * atr)
        stopPx := math.max(stopPx, proposedStop)
    
    bool riskExceptionHit = rHit and (rMsg == "SL" or rMsg == "TP")
    bool holdExceptionsOnly = entryOnlyExitHoldActive
    exitSignal := holdExceptionsOnly ? (riskExceptionHit or engExitHit) : (rHit or structHit or staleExit or engExitHit)
    if exitSignal
        tempExitReason := rHit ? rMsg : engExitHit ? "Engulfing" : staleExit ? "Stalemate" : structHit ? "Struct-Break" : "ChoCH"

if pos == -1 and allowExitShort
    if useAtrRisk

        trailPx := f_update_trail(false, entryPrice, atr, stopPx, trailPx)
    [rHit, rMsg] = f_risk_exit_hit(false, stopPx, tpPx, trailPx)
    
    // TP Filtering (Hold Winner)
    if rHit and rMsg == "TP" and confGate >= exitConfTP
        rHit := false 
    
    // Check for Reversal Exit (ChoCH Up)
    // breakShort = bullish EMA break; isChoCH_Long = bullish structure reversal
    // v6.2.6: ChoCH exits now respect a minimum 2-bar grace.
    structHit = ((breakShort and canStructExit) or (isChoCH_Long and canChochExit))

    // ChoCh Filtering (Confirm Reversal) - REMOVED for Bullish ChoCh per instruction
    // if structHit and not na(pU) and pU < exitConfChoCh
    //    structHit := false
    
    // Engulfing Contextual Exit (Option 1 - User Configurable)
    bool engExitHit = false
    bool engTightenHit = false
    if useEngulfExit and bullEngulf3
        if engulfExitMode == "Contextual Exit"
            if ((usiStackDir == 1) or usiBullState) or (outScore1 > 0.05) or not f_soft(fcGateShort)
                engExitHit := true
        else if engulfExitMode == "Tighten Risk"
            engTightenHit := true

    if engTightenHit
        float proposedStop = close + (engulfTightenMult * atr)
        stopPx := math.min(stopPx, proposedStop)

    bool riskExceptionHit = rHit and (rMsg == "SL" or rMsg == "TP")
    bool holdExceptionsOnly = entryOnlyExitHoldActive
    coverSignal := holdExceptionsOnly ? (riskExceptionHit or engExitHit) : (rHit or structHit or staleExit or engExitHit)
    if coverSignal
        tempExitReason := rHit ? rMsg : engExitHit ? "Engulfing" : staleExit ? "Stalemate" : structHit ? "Struct-Break" : "ChoCH"

// State Logic
// v6.2.10: Same-bar reversal support (see Indicator for full explanation).
// did* flags track state machine actions per bar (support COVERâ†’BUY on same bar).
// v6.2.13: Track whether position was entered via Neural Reversal so EXIT/COVER
//          labels can indicate "(REV)".
var bool lastEntryWasRev = false
var int  lastBuyBarIdx  = na   // v6.2.17: Track BUY bar_index for EXIT label debugging
var int  lastShortBarIdx = na  // v6.2.17: Track SHORT bar_index for COVER label debugging
var string lastExitReason = ""
// v6.2.14: Snapshot BEFORE phase-2 can overwrite it on same-bar reversal.
bool _wasRevEntry = lastEntryWasRev
bool didBuy   = false
bool didShort = false
bool didExit  = false
bool didCover = false

if barstate.isconfirmed
    didBuy   := false
    didShort := false
    didExit  := false
    didCover := false

    // Injection: USI Quantum Pulse (Muster A - Additional Entry Source)
    // If USI verifies a valid entry, force the signal true (OR logic).
    // Note: qFinalEntryBuy/Sell already respects 'useUsi' main toggle.
    // Tagging Mode B+: Exclusive (USI only) vs Co-Trigger (USI+Engine)
    bool _engineBuyPre   = buySignal
    bool _engineShortPre = shortSignal
    
    if qFinalEntryBuy
        buySignal := true
        if not _engineBuyPre
            _trigUsiBuy := true
        else
            _trigUsiCoBuy := true // Engine + USI agree
            
    if qFinalEntrySell
        shortSignal := true
        if not _engineShortPre
            _trigUsiSell := true
        else
            _trigUsiCoSell := true // Engine + USI agree

    // --- Phase 1: Process exits ---
    if exitSignal and pos == 1
        didExit := true
        pos := 0
        lastExitReason := tempExitReason
        entryPrice := na
        stopPx := na
        tpPx := na
        enTime     := time
        trailPx := na
        lastSignalBar := bar_index
        lastSignalTime := time
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        didCover := true
        pos := 0
        lastExitReason := tempExitReason
        entryPrice := na
        stopPx := na
        tpPx := na
        trailPx := na
        lastSignalBar := bar_index
        lastSignalTime := time
        lastSig := "COVER"

    // --- Phase 2: Process entries (including same-bar reversal after exit) ---
    // Guard: block same-direction re-entry (EXITâ†’BUY or COVERâ†’SHORT).
    // Only allow: normal entry (no Phase 1), COVERâ†’BUY, or EXITâ†’SHORT.
    if buySignal and pos == 0 and (allowSameBarBuyAfterCover or not didCover) and not didExit
        didBuy := true
        pos := 1
        entryPrice := close
        entryAtr   := atr
        enBar      := bar_index
        enTime     := time
        barsSinceEntry := 0  // reset for same-bar reversal
        lastEntryWasRev := isRevBuy  // v6.2.13
        lastBuyBarIdx := bar_index   // v6.2.17
        if useAtrRisk
            [newStop, newTp, newTrail] = f_set_risk_on_entry(true, entryPrice, atr)
            stopPx  := newStop
            tpPx    := useInfiniteTP ? na : newTp
            trailPx := newTrail
        // Cooldown semantics:
        // - AllSignals: entries also reset timer
        // - EntriesOnly: reset timer on BUY/SHORT only
        if cooldownTriggers == "AllSignals" or cooldownTriggers == "EntriesOnly"
            lastSignalBar  := bar_index
            lastSignalTime := time
        lastSig := "BUY"
    else if shortSignal and pos == 0 and (allowSameBarShortAfterExit or not didExit) and not didCover
        didShort := true
        pos := -1
        entryPrice := close
        entryAtr   := atr
        enBar      := bar_index
        enTime     := time
        barsSinceEntry := 0  // reset for same-bar reversal
        lastEntryWasRev := isRevShort  // v6.2.13
        lastShortBarIdx := bar_index   // v6.2.17
        if useAtrRisk
            [sStop, sTp, sTrail] = f_set_risk_on_entry(false, entryPrice, atr)
            stopPx  := sStop
            tpPx    := useInfiniteTP ? na : sTp
            trailPx := sTrail
        // Cooldown semantics:
        // - AllSignals: entries also reset timer
        // - EntriesOnly: reset timer on BUY/SHORT only
        if cooldownTriggers == "AllSignals" or cooldownTriggers == "EntriesOnly"
            lastSignalBar  := bar_index
            lastSignalTime := time
        lastSig := "SHORT"

buyEvent   = didBuy
shortEvent = didShort
exitEvent  = didExit
coverEvent = didCover

// Realtime preview pulses (intrabar labels/alerts) when close-only mode is disabled.
varip bool rtBuyPreviewSent = false
varip bool rtShortPreviewSent = false
varip bool rtExitPreviewSent = false
varip bool rtCoverPreviewSent = false
varip bool rtPreBuyPreviewSent = false
varip bool rtPreShortPreviewSent = false

if barstate.isnew
    rtBuyPreviewSent := false
    rtShortPreviewSent := false
    rtExitPreviewSent := false
    rtCoverPreviewSent := false
    rtPreBuyPreviewSent := false
    rtPreShortPreviewSent := false

bool buyPreviewPosOk = (pos == 0) or (pos == -1 and coverSignal and allowSameBarBuyAfterCover)
bool shortPreviewPosOk = (pos == 0) or (pos == 1 and exitSignal and allowSameBarShortAfterExit)
buyPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and buySignal and buyPreviewPosOk and not rtBuyPreviewSent
shortPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and shortSignal and shortPreviewPosOk and not rtShortPreviewSent
exitPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and exitSignal and pos == 1 and not rtExitPreviewSent
coverPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and coverSignal and pos == -1 and not rtCoverPreviewSent
preBuyPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and preBuyNow and not rtPreBuyPreviewSent
preShortPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and preShortNow and not rtPreShortPreviewSent

if buyPreviewPulse
    rtBuyPreviewSent := true
if shortPreviewPulse
    rtShortPreviewSent := true
if exitPreviewPulse
    rtExitPreviewSent := true
if coverPreviewPulse
    rtCoverPreviewSent := true
if preBuyPreviewPulse
    rtPreBuyPreviewSent := true
if preShortPreviewPulse
    rtPreShortPreviewSent := true

buyEventLive = buyEvent or buyPreviewPulse
shortEventLive = shortEvent or shortPreviewPulse
exitEventLive = exitEvent or exitPreviewPulse
coverEventLive = coverEvent or coverPreviewPulse
preBuyEventLive = preBuyPulse or preBuyPreviewPulse
preShortEventLive = preShortPulse or preShortPreviewPulse
revBuyEventLive = (buyEvent and isRevBuy) or (buyPreviewPulse and isRevBuy)
revShortEventLive = (shortEvent and isRevShort) or (shortPreviewPulse and isRevShort)

// Alerts
// Strict alert mode (entries only):
// - BUY/SHORT: 1-bar confirmation + conservative MTF/ChoCH checks
// - EXIT/COVER: no delay (same bar)
// - Automatically disabled during opening windows (LONG/SHORT configured mins)
strictAtrRank = f_pct_rank(atr / math.max(close, PRICE_EPS), strictAdaptiveLen)
strictMtfMarginEff = useAdaptiveStrictMargin ? f_clamp(strictMtfMargin + ((strictAtrRank - 0.5) * 2.0 * strictAdaptiveRange), 0.0, 0.20) : strictMtfMargin
strictSuppressByOpenWindow = openWindowBypassEntries and inRevOpenWindow
strictAlertsEnabled = not strictSuppressByOpenWindow
strictMtfLongOk = (not useMtfConfirm) or ((mtfScore > (SCORE_NEUTRAL_BAND + strictMtfMarginEff)) and (mtfScore[1] > (SCORE_NEUTRAL_BAND + strictMtfMarginEff)))
strictMtfShortOk = (not useMtfConfirm) or ((mtfScore < -(SCORE_NEUTRAL_BAND + strictMtfMarginEff)) and (mtfScore[1] < -(SCORE_NEUTRAL_BAND + strictMtfMarginEff)))
strictChochLongOk = (not isRevBuy[1]) or ((not na(barsSinceChoCH_L)) and (barsSinceChoCH_L <= strictChochConfirmBars) and not isChoCH_Short)
strictChochShortOk = (not isRevShort[1]) or ((not na(barsSinceChoCH_S)) and (barsSinceChoCH_S <= strictChochConfirmBars) and not isChoCH_Long)
buyEventStrict = barstate.isconfirmed and buyEvent[1] and strictMtfLongOk and strictChochLongOk
shortEventStrict = barstate.isconfirmed and shortEvent[1] and strictMtfShortOk and strictChochShortOk
revBuyEventStrict = barstate.isconfirmed and buyEvent[1] and isRevBuy[1] and strictMtfLongOk and strictChochLongOk
revShortEventStrict = barstate.isconfirmed and shortEvent[1] and isRevShort[1] and strictMtfShortOk and strictChochShortOk
strictWasEnabled = strictAlertsEnabled[1] == true
alertBuySameBar   = buyEventLive and not strictAlertsEnabled
alertShortSameBar = shortEventLive and not strictAlertsEnabled
alertRevBuySameBar   = revBuyEventLive and not strictAlertsEnabled
alertRevShortSameBar = revShortEventLive and not strictAlertsEnabled
alertBuyDelayed   = buyEventStrict and strictWasEnabled and strictAlertsEnabled
alertShortDelayed = shortEventStrict and strictWasEnabled and strictAlertsEnabled
alertRevBuyDelayed   = revBuyEventStrict and strictWasEnabled and strictAlertsEnabled
alertRevShortDelayed = revShortEventStrict and strictWasEnabled and strictAlertsEnabled

alertRevBuyCond   = alertRevBuySameBar or alertRevBuyDelayed
alertRevShortCond = alertRevShortSameBar or alertRevShortDelayed
alertBuyCond   = (alertBuySameBar or alertBuyDelayed) and not alertRevBuyCond
alertShortCond = (alertShortSameBar or alertShortDelayed) and not alertRevShortCond
alertExitCond  = exitEventLive
alertCoverCond = coverEventLive
alertPreBuyCond   = preBuyEventLive
alertPreShortCond = preShortEventLive
alertChochBullCond = isChoCH_Long
alertChochBearCond = isChoCH_Short
alertConsolidationCond = sidewaysVisual and not sidewaysVisual[1]

alertcondition((not useAlertCalls) and alertBuyCond,   title="BUY",   message="BUY {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertShortCond, title="SHORT", message="SHORT {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertRevBuyCond,   title="REV-BUY",   message="REV-BUY {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertRevShortCond, title="REV-SHORT", message="REV-SHORT {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertExitCond,  title="EXIT",  message="EXIT {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertCoverCond, title="COVER", message="COVER {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertPreBuyCond,   title="PRE-BUY",   message="PRE-BUY {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertPreShortCond, title="PRE-SHORT", message="PRE-SHORT {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertChochBullCond, title="ChoCH Bullish", message="ChoCH Bullish {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertChochBearCond, title="ChoCH Bearish", message="ChoCH Bearish {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and alertConsolidationCond, title="CONSOLIDATION", message="CONSOLIDATION {{ticker}} {{close}} {{time}}")

// v6.2.12: Watchlist stability â€” force bar_close frequency to reduce alert rate
// and prevent TradingView "limited functionality" throttling on multi-symbol watchlists.
// v6.2.21: Consolidated into a SINGLE alert() call per bar to stay within
//          TradingView's rate limits on large watchlists.
alertFreqSafe = signalOnCloseOnly ? alert.freq_once_per_bar_close : alert.freq_once_per_bar

if useAlertCalls and signalGateConfirmed and barstate.isrealtime
    // Collect all signals that fired on this bar into one message
    string[] _parts = array.new_string(0)
    if alertRevBuyCond
        array.push(_parts, "REV-BUY")
    else if alertBuyCond
        array.push(_parts, "BUY")
    if alertRevShortCond
        array.push(_parts, "REV-SHORT")
    else if alertShortCond
        array.push(_parts, "SHORT")
    if alertExitCond
        array.push(_parts, "EXIT")
    if alertCoverCond
        array.push(_parts, "COVER")
    if alertPreBuyCond
        array.push(_parts, "PRE-BUY")
    if alertPreShortCond
        array.push(_parts, "PRE-SHORT")
    if alertConsolidationCond
        array.push(_parts, "CONSOLIDATION")

    if array.size(_parts) > 0
        string labels = array.join(_parts, "+")
        string msg = ""
        if useJsonAlerts
            string firstLabel = array.get(_parts, 0)
            string action = (firstLabel == "BUY" or firstLabel == "REV-BUY") ? "buy" : ((firstLabel == "SHORT" or firstLabel == "REV-SHORT") ? "sell" : ((firstLabel == "EXIT" or firstLabel == "COVER") ? "exit" : "flat"))
            msg := f_tp_json(action, "ALERT", labels)
        else
            modeTxtAlert = strictAlertsEnabled ? "strict" : "normal"
            delayTxt = strictAlertsEnabled and (alertBuyCond or alertShortCond or alertRevBuyCond or alertRevShortCond) ? "1" : "0"
            msg := "SkippALGO " + labels + " | " + syminfo.ticker + " @ " + str.tostring(close, "#.##") + " | TF=" + timeframe.period + " | Conf=" + str.tostring(nz(confidence) * 100, "#.0") + "% | mode=" + modeTxtAlert + " | confirm_delay=" + delayTxt
        alert(msg, alertFreqSafe)

f_safe_label_text(txt) =>
    _max = 120
    str.length(txt) > _max ? str.substring(txt, 0, _max) : txt

labelRevBuy   = buyEvent and isRevBuy
labelRevShort = shortEvent and isRevShort
labelBuy      = buyEvent and not isRevBuy
labelShort    = shortEvent and not isRevShort
labelRevBuy   := labelRevBuy or (buyPreviewPulse and isRevBuy)
labelRevShort := labelRevShort or (shortPreviewPulse and isRevShort)
labelBuy      := labelBuy or (buyPreviewPulse and not isRevBuy)
labelShort    := labelShort or (shortPreviewPulse and not isRevShort)
labelExit  = exitEventLive
labelCover = coverEventLive

string _probTxt = not na(pU) ? str.tostring(pU * 100, "#.0") + "%" : "n/a"
string _probTxtD = not na(pD) ? str.tostring(pD * 100, "#.0") + "%" : "n/a"
string _confTxt = str.tostring(confidence * 100.0, "#.0") + "%"
string _revBuyBase = "REV-BUY\npU: " + _probTxt + "\nConf: " + _confTxt
string _revShortBase = "REV-SHORT\npD: " + _probTxtD + "\nConf: " + _confTxt
string _stdBuyTxt = "BUY\npU: " + _probTxt + "\nConf: " + _confTxt
string _stdShortTxt = "SHORT\npD: " + _probTxtD + "\nConf: " + _confTxt

var label[] _preLabels = array.new_label(0)
MAX_PRE_LABELS = 100
f_pre_label(x, y, txt, sty, txtCol, bgCol) =>
    lbl = label.new(x, y, f_safe_label_text(txt), style=sty, textcolor=txtCol, color=bgCol, size=size.small)
    array.push(_preLabels, lbl)
    if array.size(_preLabels) > MAX_PRE_LABELS
        label.delete(array.shift(_preLabels))

var label[] _entryLabels = array.new_label(0)
MAX_ENTRY_LABELS = 150
f_entry_label(x, y, txt, sty, txtCol, bgCol) =>
    lbl = label.new(x, y, f_safe_label_text(txt), style=sty, textcolor=txtCol, color=bgCol)
    array.push(_entryLabels, lbl)
    if array.size(_entryLabels) > MAX_ENTRY_LABELS
        label.delete(array.shift(_entryLabels))

var label[] _exitLabels = array.new_label(0)
MAX_EXIT_LABELS = 300
f_exit_label(x, y, txt, sty, txtCol, bgCol) =>
    lbl = label.new(x, y, f_safe_label_text(txt), style=sty, textcolor=txtCol, color=bgCol)
    array.push(_exitLabels, lbl)
    if array.size(_exitLabels) > MAX_EXIT_LABELS
        label.delete(array.shift(_exitLabels))

if preBuyEventLive
    string _gapTxt = not na(preGapATR_L) ? str.tostring(preGapATR_L, "#.##") + " ATR" : "â€”"
    string _pTxt   = not na(pU) ? str.tostring(pU * 100, "#.0") + "%" : "n/a"
    string _cTxt   = str.tostring(confidence * 100.0, "#.0") + "%"
    if showPreEntryLabels
        f_pre_label(bar_index, low, "PRE-BUY\nGap: " + _gapTxt + "\npU: " + _pTxt + "\nConf: " + _cTxt, label.style_label_up, color.black, color.new(color.yellow, 0))

if preShortEventLive
    string _gapTxt = not na(preGapATR_S) ? str.tostring(preGapATR_S, "#.##") + " ATR" : "â€”"
    string _pTxt   = not na(pD) ? str.tostring(pD * 100, "#.0") + "%" : "n/a"
    string _cTxt   = str.tostring(confidence * 100.0, "#.0") + "%"
    if showPreEntryLabels
        f_pre_label(bar_index, high, "PRE-SHORT\nGap: " + _gapTxt + "\npD: " + _pTxt + "\nConf: " + _cTxt, label.style_label_down, color.black, color.new(color.orange, 0))

if showLongLabels and labelRevBuy
    f_entry_label(bar_index, low, _revBuyBase, label.style_label_up, color.black, color.new(color.aqua, 0))
if showShortLabels and labelRevShort
    f_entry_label(bar_index, high, _revShortBase, label.style_label_down, color.black, color.new(color.fuchsia, 0))
if showLongLabels and labelBuy
    f_entry_label(bar_index, low, _stdBuyTxt, label.style_label_up, color.white, color.new(color.green, 0))
if showShortLabels and labelShort
    f_entry_label(bar_index, high, _stdShortTxt, label.style_label_down, color.white, color.new(color.red, 0))

plotchar(showChochPing and chochPingLong, title="ChoCH Ping (Long)", char="?", location=location.belowbar, color=color.new(color.yellow, 0), size=size.tiny)
plotchar(showChochPing and chochPingShort, title="ChoCH Ping (Short)", char="?", location=location.abovebar, color=color.new(color.yellow, 0), size=size.tiny)

if showLongLabels and labelExit
    string entryTag  = _wasRevEntry ? " â† REV-BUY" : " â† BUY"
    string exitSuffix = didShort ? " â†’ SHORT" : ""
    int _buyAgo = na(lastBuyBarIdx) ? 0 : (bar_index - lastBuyBarIdx)
    string buyAgoTxt = " (" + str.tostring(_buyAgo) + " bars ago)"
    f_exit_label(bar_index, high, "EXIT" + entryTag + "\n" + buyAgoTxt + exitSuffix + "\n" + lastExitReason + "\nHeld " + str.tostring(barsSinceEntry) + " bars", label.style_label_down, color.white, color.new(color.red, 0))

if showShortLabels and labelCover
    string entryTag  = _wasRevEntry ? " â† REV-SHORT" : " â† SHORT"
    string coverSuffix = didBuy ? " â†’ BUY" : ""
    int _shortAgo = na(lastShortBarIdx) ? 0 : (bar_index - lastShortBarIdx)
    string shortAgoTxt = " (" + str.tostring(_shortAgo) + " bars ago)"
    f_exit_label(bar_index, low, "COVER" + entryTag + "\n" + shortAgoTxt + coverSuffix + "\n" + lastExitReason + "\nHeld " + str.tostring(barsSinceEntry) + " bars", label.style_label_up, color.white, color.new(color.green, 0))

plot(useAtrRisk and pos == 1 ? stopPx : na,  title="Stop (Long)",  linewidth=1, color=color.new(color.red, 0))
plot(useAtrRisk and not useInfiniteTP and pos == 1 ? tpPx   : na,  title="TP (Long)",    linewidth=1, color=color.new(color.green, 0))
plot(useAtrRisk and pos == 1 ? trailPx: na,  title="Trail (Long)", linewidth=1, color=color.new(color.orange, 0))

plot(useAtrRisk and pos == -1 ? stopPx : na, title="Stop (Short)", linewidth=1, color=color.new(color.red, 0))
plot(useAtrRisk and not useInfiniteTP and pos == -1 ? tpPx   : na, title="TP (Short)",   linewidth=1, color=color.new(color.green, 0))
plot(useAtrRisk and pos == -1 ? trailPx: na, title="Trail (Short)",linewidth=1, color=color.new(color.orange, 0))

// Lightweight eval HUD (last bar only): exposes runtime success-rate on chart.
var label evalHudLbl = na
if barstate.islast
    if not na(evalHudLbl)
        label.delete(evalHudLbl)
    evalHudCol = evalSuccessN >= evalMinEvents ? color.new(color.green, 75) : color.new(color.orange, 75)
    chochPresetTxt = chochSaferPresetEff ? "Fast+Safer" : chochFastPresetEff ? "Fast" : "Manual"
    chochHudTxt = " | ChoCH=" + chochPresetTxt + " (" + chochSignalModeEff + "," + breakoutSourceEff + ",R=" + str.tostring(swingREff) + ")"
    evalHudLbl := label.new(bar_index, high + nz(atr) * 0.6, evalSuccessHudTxt + chochHudTxt, style=label.style_label_left, textcolor=color.white, color=evalHudCol, size=size.tiny)

barcolor(showEngulfingBarColors ? (bullEngulf3 ? color.yellow : bearEngulf3 ? color.white : na) : na)
vwtBgColor = vwtTrendDirection == 1 ? color.new(color.lime, vwtBgTransparency) : vwtTrendDirection == -1 ? color.new(color.red, vwtBgTransparency) : na
bgcolor(showVwtTrendBackground ? vwtBgColor : na, title="VWT trend background")
alertcondition((not useAlertCalls) and bullEngulf3, title="Bullish Engulfing (3 prior opposite)", message="ENG3 BULL {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and bearEngulf3, title="Bearish Engulfing (3 prior opposite)", message="ENG3 BEAR {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and bullEngulfStd, title="Bullish Engulfing (Standard)", message="ENG BULL {{ticker}} {{close}} {{time}}")
alertcondition((not useAlertCalls) and bearEngulfStd, title="Bearish Engulfing (Standard)", message="ENG BEAR {{ticker}} {{close}} {{time}}")

// v6.1.3: TradersPost JSON Payload Generator (Strategy version)
f_tp_json(action, orderId, legacyMsg) =>
    if useJsonAlerts
        str.format('{{"ticker": "{0}", "action": "{1}", "orderId": "{2}", "uniqueId": "{0}-{3}-{4}-{2}", "price": {5}, "contracts": {6}, "sentiment": "{7}", "mode": "{8}", "confirm_delay": {9} }}', 
            syminfo.ticker, 
            action, 
            orderId, 
            timeframe.period, 
            str.tostring(timenow), 
            str.tostring(close, "#.##"), 
            str.tostring(math.abs(strategy.position_size)),
            pos == 1 ? "bullish" : pos == -1 ? "bearish" : "flat",
            strictAlertsEnabled ? "strict" : "normal",
            (strictAlertsEnabled and (alertBuyCond or alertShortCond or alertRevBuyCond or alertRevShortCond) ? 1 : 0)
        )
    else
        legacyMsg

if buyEvent
    string msgUsi = _trigUsiBuy ? " | USI BUY" : (_trigUsiCoBuy ? " | USI+ENG BUY" : "")
    string cmt = "Brier=" + str.tostring(curBrier, "#.##") + msgUsi
    strategy.entry("L", strategy.long, comment=cmt, alert_message=f_tp_json("buy", "L", "BUY " + syminfo.ticker + " " + str.tostring(close, "#.##") + " " + timeframe.period))
    if useAtrRisk and not na(stopPx) and (useInfiniteTP or not na(tpPx))
        strategy.exit("Exit L", "L", stop=stopPx, limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit L", "EXIT L " + syminfo.ticker))

if shortEvent
    string msgUsi = _trigUsiSell ? " | USI SELL" : (_trigUsiCoSell ? " | USI+ENG SELL" : "")
    string cmt = "Brier=" + str.tostring(curBrier, "#.##") + msgUsi
    strategy.entry("S", strategy.short, comment=cmt, alert_message=f_tp_json("sell", "S", "SHORT " + syminfo.ticker + " " + str.tostring(close, "#.##") + " " + timeframe.period))


    if useAtrRisk and not na(stopPx) and (useInfiniteTP or not na(tpPx))

        strategy.exit("Exit S", "S", stop=stopPx, limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit S", "EXIT S " + syminfo.ticker))

if useAtrRisk and pos != 0 and not na(stopPx)
    if pos == 1 and not na(trailPx)
        strategy.exit("Exit L", "L", stop=math.max(stopPx, trailPx), limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit L", "TRAIL EXIT L " + syminfo.ticker))
    if pos == -1 and not na(trailPx)
        strategy.exit("Exit S", "S", stop=math.min(stopPx, trailPx), limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit S", "TRAIL EXIT S " + syminfo.ticker))

if exitEvent
    strategy.close("L", comment="Exit Signal", alert_message=f_tp_json("close", "L", "EXIT " + syminfo.ticker + " " + str.tostring(close, "#.##")))
if coverEvent
    strategy.close("S", comment="Cover Signal", alert_message=f_tp_json("close", "S", "COVER " + syminfo.ticker + " " + str.tostring(close, "#.##")))


//====================
// Calibration Export Alert
//====================
// Token budget safeguard: disable heavy calibration export payload logic in strategy build.
if exportCalibration and barstate.isconfirmed and barstate.isrealtime and (bar_index % exportInterval == 0)
    // Keep a lightweight heartbeat alert to preserve export workflow hook.
    alert(str.format('{{"ticker":"{0}","horizon":"{1}","bar_index":{2},"mode":"light"}}', syminfo.ticker, exportHorizon, str.tostring(bar_index)), alert.freq_once_per_bar)

//====================
