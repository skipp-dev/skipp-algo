// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6
// SkippALGO Strategy (Deep Upgrade v6.1)
// - Synchronized with Main Indicator v6.1
// - Target Profiles (Fixed, KReturn, KATR, TPorSL)
// - Ensemble Score (Algo + Pullback + Regime)
// - 2D Binning (Score x Volatility)
// - Platt Scaling (SGD Probability Calibration)
strategy("SkippALGO Strategy (Deep Upgrade v6.1)", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_labels_count=500, max_lines_count=500)

//====================
// Inputs â€” Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

//====================
// Constants â€” Avoid Magic Numbers
//====================
// Volatility regime thresholds
VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

// Statistical constants
Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)

// Rolling buffer recalculation interval (prevent FP drift)
ROLL_RECALC_INTERVAL = 500

// Sideways/choppy market detection thresholds
SIDEWAYS_EMA_THRESH = 0.005   // Max EMA diff ratio for sideways
SIDEWAYS_ATR_THRESH = 0.015   // Max ATR norm for sideways

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels  = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers   = input.bool(true, "Show SET markers")
showTable        = input.bool(true, "Show Outlook/Forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

//====================
// Inputs â€” Forecast Calibration Enhancements (Deep Upgrade v6.1)
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])
pHdrN = fcDisplay == "Edge pp (N)" ? "Edge(N)" : "Up%(N)"
pHdr1 = fcDisplay == "Edge pp (N)" ? "Edge(1)" : "Up%(1)"
atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)

//====================
// Inputs â€” Forecast 3-way (Up/Flat/Down)
//====================
grp_tri = "Forecast 3-way (Up/Flat/Down)"
use3Way = input.bool(true, "3-way probs: Up/Flat/Down", group=grp_tri)

deadbandFast = input.float(0.10, "Deadband Ã— ATR (Fast <=5m)", step=0.01, group=grp_tri)
deadbandMid  = input.float(0.10, "Deadband Ã— ATR (Mid <=1h)",  step=0.01, group=grp_tri)
deadbandSlow = input.float(0.10, "Deadband Ã— ATR (Slow >1h)",  step=0.01, group=grp_tri)

flatPriorFast = input.float(0.42, "Warmup prior: Flat (Fast)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorMid  = input.float(0.30, "Warmup prior: Flat (Mid)",  step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorSlow = input.float(0.22, "Warmup prior: Flat (Slow)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)

tiltMaxFast = input.float(0.10, "Warmup tilt max (Fast)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxMid  = input.float(0.12, "Warmup tilt max (Mid)",  step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxSlow = input.float(0.15, "Warmup tilt max (Slow)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)

dirMinProb = input.float(0.34, "Direction shown if max prob â‰¥", step=0.01, minval=0.34, maxval=0.90, group=grp_tri)

fcTblModel = input.string("N", "Forecast columns", options=["N","1","Both"], group=grp_tri)

calibratorMode = input.string("Vector", "3-way calibrator", options=["Off","Temp","Vector"], group=grp_tri)
lrCal = input.float(0.01, "Calibrator LR", step=0.001, minval=0.0001, group=grp_tri)
tempMin = input.float(0.5, "Temp min", step=0.1, minval=0.1, group=grp_tri)
tempMax = input.float(5.0, "Temp max", step=0.1, minval=0.5, group=grp_tri)
vecAMin = input.float(0.25, "Vec A min", step=0.05, minval=0.05, group=grp_tri)
vecAMax = input.float(3.0, "Vec A max", step=0.05, minval=0.5, group=grp_tri)
vecBMin = input.float(-2.0, "Vec B min", step=0.1, group=grp_tri)
vecBMax = input.float(2.0, "Vec B max", step=0.1, group=grp_tri)
cal3AutoFallback = input.bool(true, "3-way auto fallback (weak bins)", group=grp_tri)
cal3MinSamples  = input.int(120, "3-way min samples for calibrator", minval=10, maxval=5000, group=grp_tri)
useBullBearCal = input.bool(true, "Separate bull/bear calibrators", group=grp_tri)
countDecay = input.float(1.0, "Count decay (1.0=none)", minval=0.80, maxval=1.0, step=0.01, group=grp_tri)
kShrinkReg = input.int(5, "Regime shrinkage k", minval=0, maxval=1000, group=grp_tri)

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpATRM    = input.float(0.80, "Path TP", step=0.05, group=grp_mid)
slATRM    = input.float(0.50, "Path SL", step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.20, "Path TP", step=0.05, group=grp_slow)
slATRS    = input.float(0.80, "Path SL", step=0.05, group=grp_slow)

// Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"], group="Policy")
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"], group="Policy")

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")

// --- Phase 4: Online Calibration ---
grp_cal = "Calibration Settings (Phase 4)"
usePlatt = input.bool(true, "Use Platt Scaling (Online SGD)", group=grp_cal)
lrPlatt  = input.float(0.005, "Learning Rate (SGD)", minval=0.001, maxval=0.1, step=0.001, group=grp_cal)

// Bins & Smoothing
predBinsN = input.int(3, "Pred bins (N) stable", minval=2, maxval=9, group="Engine")
predBins1 = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3, group="Engine")
dim2Bins  = 3 // Volatility Low/Mid/Hi

// Quantile binning (score dimension)
useQuantileBins = input.bool(true, "Use quantile bins (score)", group="Engine")
quantileWindow = input.int(500, "Quantile window (samples)", minval=100, maxval=5000, group="Engine")
quantileUpdate = input.int(50, "Quantile update interval (bars)", minval=10, maxval=1000, group="Engine")
quantileMinSamples = input.int(200, "Quantile min samples", minval=50, maxval=5000, group="Engine")

alphaN = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1, group="Engine")
alpha1 = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1, group="Engine")
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000, tooltip="Higher = pull bin probability closer to global TF average", group="Engine")

calMinSamples = input.int(40, "Min samples per bin (activate)", minval=5, maxval=1000, group="Engine")

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01, group="Signals")
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01, group="Signals")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7"], group="Maintenance")
resetNow   = input.bool(false, "Reset selected calibration NOW", group="Maintenance")

//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F6", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")
relFilterModel = input.string("N", "Filter Model", options=["N", "1"], tooltip="N=Multi-factor, 1=Single-factor")

// Evidence / coverage gating
evidenceGate = input.bool(false, "Evidence gate (block weak bins)")
evidenceMinTotal = input.int(120, "Evidence min total samples", minval=1, maxval=10000)
abstainGate = input.bool(true, "Abstain on weak decisions")
abstainMinEdge = input.float(0.08, "Abstain min edge (pp)", minval=0.0, maxval=0.50, step=0.01)

//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ConfErr/Drift)")
evalWhichHead   = input.string("N", "Evaluate head", options=["N","1"])  // N=stable bins, 1=reactive bins

evalInBackground = input.bool(true, "Eval in background (when Eval section hidden)")

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"])

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

evalBucketCount = use3Way ? evalBuckets * 3 : evalBuckets

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)

//====================
// Inputs â€” Calibration Diagnostics (Debug Panel)
//====================
grp_diag = "ðŸ”§ Calibration Diagnostics"
showDiagPanel   = input.bool(false, "Show Calibration Debug Panel", group=grp_diag, tooltip="Displays Platt params, convergence, bin samples")
diagHorizon     = input.string("F1", "Diagnostic Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_diag)
diagModel       = input.string("N", "Diagnostic Model", options=["N","1"], group=grp_diag, tooltip="N=Multi-factor, 1=Single-factor")

//====================
// Inputs â€” Calibration Export (Webhook)
//====================
grp_export = "ðŸ“¤ Calibration Export"
exportCalibration = input.bool(false, "Enable Calibration Export Alert", group=grp_export, tooltip="Fires alert with JSON calibration state")
exportInterval    = input.int(100, "Export Every N Bars", minval=10, maxval=1000, group=grp_export)
exportHorizon     = input.string("F1", "Export Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_export)

//====================
// Calibration storage â€” TfState UDT (replaces 100+ global arrays)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    float[] cntN
    float[] upN
    float[] dnN
    float[] cnt1
    float[] up1
    float[] dn1
    float[] cntN_bull
    float[] upN_bull
    float[] dnN_bull
    float[] cntN_bear
    float[] upN_bear
    float[] dnN_bear
    float[] cnt1_bull
    float[] up1_bull
    float[] dn1_bull
    float[] cnt1_bear
    float[] up1_bear
    float[] dn1_bear
    // Queues
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    int[]   qBias
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    float[] qPUpN
    float[] qPFlN
    float[] qPDnN
    float[] qPUp1
    float[] qPFl1
    float[] qPDn1
    float[] qZUpN
    float[] qZFlN
    float[] qZDnN
    float[] qZUp1
    float[] qZFl1
    float[] qZDn1
    // Stats
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    float[] tempN
    float[] temp1
    float[] vecAN
    float[] vecBN
    float[] vecA1
    float[] vecB1
    // Evaluation N
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    // Evaluation 1
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1

// Helper to initialize TfState
f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
            array.new_int(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
            array.new_int(),
            array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.from(1.0, 0.0), array.from(1.0, 0.0),
    array.from(1.0), array.from(1.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
      // Eval N
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float(),
      // Eval 1
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float()
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)

//====================
// Table colors (navy + soft-blue frame)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

//====================
// Quantile bin buffers (score dimension)
//====================
var float[] qScoreBuf = array.new_float()
var float[] qCutsN = array.new_float(int(math.max(predBinsN - 1, 0)), na)
var float[] qCuts1 = array.new_float(int(math.max(predBins1 - 1, 0)), na)

//====================
// Helpers
//====================
// --- Sum int array (total resolved samples across all bins)
f_sum_int_array(a) =>
    float s = 0.0
    for i = 0 to array.size(a) - 1
        s += array.get(a, i)
    s

// --- Update quantile cutpoints (score dimension)
f_fill_cuts(sorted, cuts, bins) =>
    cutCount = bins - 1
    if cutCount > 0
        n = array.size(sorted)
        for i = 0 to cutCount - 1
            frac = (i + 1.0) / bins
            idx = int(math.floor(frac * (n - 1)))
            array.set(cuts, i, array.get(sorted, idx))

// Forecast binning (fallback: fixed width)
f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = int(math.floor(u * bins))
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b

f_update_quantiles(score) =>
    if useQuantileBins and (showTable or showEvalSection)
        array.push(qScoreBuf, score)
        if array.size(qScoreBuf) > quantileWindow
            array.shift(qScoreBuf)
        if bar_index % quantileUpdate == 0 and array.size(qScoreBuf) >= quantileMinSamples
            tmp = array.copy(qScoreBuf)
            array.sort(tmp, order.ascending)
            f_fill_cuts(tmp, qCutsN, predBinsN)
            f_fill_cuts(tmp, qCuts1, predBins1)

f_bin_quantile(score, cuts, bins) =>
    if (not useQuantileBins) or array.size(cuts) == 0 or na(array.get(cuts, 0))
        f_bin(score, bins)
    else
        b = 0
        for i = 0 to array.size(cuts) - 1
            if score <= array.get(cuts, i)
                b := i
                break
            else
                b := i + 1
        math.max(0, math.min(bins - 1, b))

f_regime_bin(trendScore) =>
    trendScore > 0.5 ? 2 : trendScore < -0.5 ? 0 : 1

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

// @function Clamp value to arbitrary [lo, hi] range
// @param val Value to clamp
// @param lo Minimum bound
// @param hi Maximum bound
// @returns Clamped value
f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" : tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  : tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "â€”" : v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") : v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") : v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") : str.tostring(v, "#")

f_chance_word() =>
    anyWin = fcTargetF == "PathTPvsSL" or fcTargetM == "PathTPvsSL" or fcTargetS == "PathTPvsSL"
    anyWin ? "Win" : "Up"

f_ci95_halfwidth(p, n) =>
    n <= 0 ? na : Z_95 * math.sqrt(p * (1.0 - p) / n)

f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= 0.05 ? "strong" : hw <= 0.10 ? "ok" : "weak"
    lbl

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    trend = emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = sec <= 300 // <= 5m
    isMid  = sec <= 3600 // <= 1h
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     isFast ? tpATRF    : isMid ? tpATRM    : tpATRS, 
     isFast ? slATRF    : isMid ? slATRM    : slATRS]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    // Clamp output to prevent extreme values
    math.max(-10.0, math.min(10.0, math.log(pc / (1.0 - pc))))

f_sigmoid(x) =>
    // Prevent overflow for extreme x values
    x < -500 ? 0.0 : x > 500 ? 1.0 : 1.0 / (1.0 + math.exp(-x))

f_platt_prob(pRaw, a, b) =>
    usePlatt ? f_sigmoid(a * f_logit(pRaw) + b) : pRaw

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Bias -1 (Bear): mirror logic; Bias 0 (neutral): return 0
    bias == 1 ? (c > ef ? 0.5 : c > es ? 1.0 : -1.0) : bias == -1 ? (c < ef ? 0.5 : c < es ? 1.0 : -1.0) : 0.0

// @function Computes trend regime score (bull/bear/sideways)
// @param emaF Fast EMA value
// @param emaS Slow EMA value
// @param atrNorm ATR normalized by close (for sideways detection)
// @returns Score in [-1, 1]: +1=bull, -1=bear, 0=sideways/choppy
f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / nz(emaS, 1)
    // Strong trend: EMAs diverging significantly (>0.5% gap)
    // Sideways: EMAs close together AND low volatility
    isSideways = math.abs(emaDiff) < SIDEWAYS_EMA_THRESH and atrNorm < SIDEWAYS_ATR_THRESH
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

f_ensemble(sA, sB, sC, wA, wB, wC) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Regime Score (-1..1)
    num = wA * sA + wB * sB + wC * sC
    den = wA + wB + wC
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Vol Regime Score (-1..1)
    // sD: Trend Regime Score (-1..1): bull/bear/sideways
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// --- Phase 2 Helpers: 2D Binning ---
// @function Computes 2D bin index from score and trend regime
// @param score Ensemble score in [-1, 1]
// @param trendScore Trend regime score in [-1, 1]
// @param binsScore Number of bins for score dimension
// @param binsReg Number of bins for regime dimension (typically 3)
// @param cutsArr Quantile cutpoints for score dimension
// @returns Flattened bin index
f_bin2D(score, trendScore, binsScore, binsReg, cutsArr) =>
    bS = f_bin_quantile(score, cutsArr, binsScore)
    bR = f_regime_bin(trendScore)
    int(bS * binsReg + bR)

f_db_mult(tf) =>
    sec = timeframe.in_seconds(tf)
    sec <= 300 ? deadbandFast : sec <= 3600 ? deadbandMid : deadbandSlow

f_outcome3(delta, db) =>
    delta > db ? 1 : delta < -db ? -1 : 0

f_bias_from_score(score) =>
    score >= 0 ? 1 : -1

f_decay_counts(cntArr, upArr, dnArr, decay) =>
    if decay < 0.9999
        for i = 0 to array.size(cntArr) - 1
            array.set(cntArr, i, array.get(cntArr, i) * decay)
            array.set(upArr,  i, array.get(upArr,  i) * decay)
            array.set(dnArr,  i, array.get(dnArr,  i) * decay)

f_cal_update3(cntArr, upArr, dnArr, bin, outcome) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    d0 = array.get(dnArr,  bin)
    array.set(cntArr, bin, n0 + 1.0)
    array.set(upArr,  bin, u0 + (outcome == 1 ? 1.0 : 0.0))
    array.set(dnArr,  bin, d0 + (outcome == -1 ? 1.0 : 0.0))

f_prob3(u, f, d, n, alpha) =>
    denom = n + 3.0 * alpha
    if denom == 0.0
        [0.3333, 0.3334, 0.3333]
    else
        [(u + alpha) / denom, (f + alpha) / denom, (d + alpha) / denom]

f_cal_cur3(cntArr, upArr, dnArr, bin, alpha, shrinkK, shrinkReg) =>
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    d = array.get(dnArr,  bin)
    f = math.max(0, n - u - d)

    [pUb_t, pFb_t, pDb_t] = f_prob3(u, f, d, n, alpha)
    pUb = pUb_t
    pFb = pFb_t
    pDb = pDb_t

    volBin = bin % dim2Bins
    binsScore = int(array.size(cntArr) / dim2Bins)
    nReg = 0.0
    uReg = 0.0
    dReg = 0.0
    for i = 0 to binsScore - 1
        idx = i * dim2Bins + volBin
        nReg += array.get(cntArr, idx)
        uReg += array.get(upArr,  idx)
        dReg += array.get(dnArr,  idx)
    fReg = math.max(0, nReg - uReg - dReg)
    [pUr_t, pFr_t, pDr_t] = f_prob3(uReg, fReg, dReg, nReg, alpha)
    pUr = pUr_t
    pFr = pFr_t
    pDr = pDr_t

    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    dBase = array.sum(dnArr)
    fBase = math.max(0, nBase - uBase - dBase)
    [pU0_t, pF0_t, pD0_t] = f_prob3(uBase, fBase, dBase, nBase, alpha)
    pU0 = pU0_t
    pF0 = pF0_t
    pD0 = pD0_t

    wReg = (shrinkReg <= 0) ? 1.0 : (n / (n + shrinkReg + 0.0))
    pUreg = wReg * pUb + (1.0 - wReg) * pUr
    pFreg = wReg * pFb + (1.0 - wReg) * pFr
    pDreg = wReg * pDb + (1.0 - wReg) * pDr

    w = (shrinkK <= 0) ? 1.0 : (nReg / (nReg + shrinkK + 0.0))
    pU = w * pUreg + (1.0 - w) * pU0
    pF = w * pFreg + (1.0 - w) * pF0
    pD = w * pDreg + (1.0 - w) * pD0

    s = pU + pF + pD
    if s == 0.0
        [0.3333, 0.3334, 0.3333, n]
    else
        [pU / s, pF / s, pD / s, n]

f_safe_log(p) =>
    math.log(math.max(PROB_EPS, p))

f_softmax3(zU, zF, zD) =>
    zMax = math.max(zU, math.max(zF, zD))
    eU = math.exp(zU - zMax)
    eF = math.exp(zF - zMax)
    eD = math.exp(zD - zMax)
    s = eU + eF + eD
    if s == 0.0
        [0.3333, 0.3334, 0.3333]
    else
        [eU / s, eF / s, eD / s]

f_can_cal3(nBin) =>
    calibratorMode != "Off" and (not cal3AutoFallback or nBin >= cal3MinSamples)

f_cal_apply(zU, zF, zD, tempArr, aArr, bArr) =>
    zUo = zU
    zFo = zF
    zDo = zD
    if calibratorMode == "Temp"
        t = array.get(tempArr, 0)
        t := t <= 0.0 ? 1.0 : t
        zUo := zU / t
        zFo := zF / t
        zDo := zD / t
    else if calibratorMode == "Vector"
        aU = array.get(aArr, 0)
        aF = array.get(aArr, 1)
        aD = array.get(aArr, 2)
        bU = array.get(bArr, 0)
        bF = array.get(bArr, 1)
        bD = array.get(bArr, 2)
        zUo := aU * zU + bU
        zFo := aF * zF + bF
        zDo := aD * zD + bD
    f_softmax3(zUo, zFo, zDo)

f_brier3(pU, pF, pD, outcome) =>
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0
    ((pU - yU) * (pU - yU) + (pF - yF) * (pF - yF) + (pD - yD) * (pD - yD)) / 3.0

f_logloss3(pU, pF, pD, outcome) =>
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD
    -math.log(f_clamp(pTrue, 0.0001, 0.9999))

f_prior3(tf, outScore) =>
    sec = timeframe.in_seconds(tf)
    baseFlat = sec <= 300 ? flatPriorFast : sec <= 3600 ? flatPriorMid : flatPriorSlow
    tiltMax  = sec <= 300 ? tiltMaxFast  : sec <= 3600 ? tiltMaxMid  : tiltMaxSlow

    baseSide = (1.0 - baseFlat) * 0.5
    tilt = f_clamp(outScore, -1.0, 1.0) * tiltMax

    pU = f_clamp(baseSide + tilt, 0.0, 1.0)
    pD = f_clamp(baseSide - tilt, 0.0, 1.0)
    pF = f_clamp(baseFlat, 0.0, 1.0)

    s = pU + pF + pD
    if s == 0.0
        [0.3333, 0.3334, 0.3333]
    else
        [pU / s, pF / s, pD / s]

f_samp_label(enabled, total) =>
    not enabled ? "off" : total < calMinSamples ? "â€¦" : total < calMinSamples * 3 ? "ok" : "strong"

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

f_tf_pack(tf) =>
    request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(close == 0 ? 0.0 : ta.atr(atrLen) / close, volRankLen)], // Added Phase 2 Vol Rank
        barmerge.gaps_off,
        barmerge.lookahead_off
    )

f_score_tf(tf) =>
    [c_t, ef_t, es_t, r_t] = request.security(
            syminfo.tickerid,
            tf,
            [close,
             ta.ema(close, emaFastLen),
             ta.ema(close, emaSlowLen),
             ta.rsi(close, rsiStateLen)],
            barmerge.gaps_off,
            barmerge.lookahead_off
        )
    c = c_t
    ef = ef_t
    es = es_t
    r = r_t
    f_state_score(c, ef, es, r)

// @function Computes Laplace-smoothed probability with division safety
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter (default typically 1.0)
// @returns Probability in (0, 1), defaults to 0.5 if denominator is zero
f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_update(cntArr, upArr, bin, isUp) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    array.set(cntArr, bin, n0 + 1.0)
    array.set(upArr,  bin, u0 + (isUp ? 1.0 : 0.0))

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Bin raw
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "â€”" : n < calMinSamples ? "â€¦" : pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) : n < calMinSamples ? color.new(color.white, 60) : pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_pupText(pUp, n, canCal) =>
    not canCal ? "OFF" : n == 0 ? "â€”" : n < calMinSamples ? "Warm " + str.tostring(n) + "/" + str.tostring(calMinSamples) : fcDisplay == "Edge pp (N)" ? ((pUp - 0.5) * 100.0 > 0 ? "+" + str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")" : str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")") : "Up " + str.tostring(pUp * 100.0, "#.0") + "% (" + str.tostring(n) + ")"

f_epsClamp(p) =>
    eps = 1e-6
    math.max(eps, math.min(1.0 - eps, p))

f_brier(p, y) =>
    d = p - y
    d * d

f_logloss(p, y) =>
    pc = f_epsClamp(p)
    -(y * math.log(pc) + (1.0 - y) * math.log(1.0 - pc))

f_roll_add(buf, sumArr, v, maxLen) =>
    array.push(buf, v)
    array.set(sumArr, 0, array.get(sumArr, 0) + v)
    if array.size(buf) > maxLen
        old = array.shift(buf)
        array.set(sumArr, 0, array.get(sumArr, 0) - old)
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(buf) > 0
        array.set(sumArr, 0, array.sum(buf))

f_bucket(p, B) =>
    b = int(math.floor(p * B))
    b < 0 ? 0 : b > (B - 1) ? (B - 1) : b

f_cal_roll_update(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, p, y, maxLen) =>
    B = array.size(calCnt)
    bi = f_bucket(p, B)

    array.push(bBuf, bi)
    array.push(pBuf, p)
    array.push(yBuf, y)

    array.set(calCnt,  bi, array.get(calCnt,  bi) + 1)
    array.set(calSumP, bi, array.get(calSumP, bi) + p)
    array.set(calSumY, bi, array.get(calSumY, bi) + y)

    if array.size(bBuf) > maxLen
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_cal_roll_update3(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, pU, pF, pD, outcome, maxLen) =>
    B = evalBuckets
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0

    biU = f_bucket(pU, B)
    biF = f_bucket(pF, B)
    biD = f_bucket(pD, B)

    idxU = 0 * B + biU
    idxF = 1 * B + biF
    idxD = 2 * B + biD

    array.push(bBuf, idxU), array.push(pBuf, pU), array.push(yBuf, yU)
    array.push(bBuf, idxF), array.push(pBuf, pF), array.push(yBuf, yF)
    array.push(bBuf, idxD), array.push(pBuf, pD), array.push(yBuf, yD)

    array.set(calCnt,  idxU, array.get(calCnt,  idxU) + 1)
    array.set(calSumP, idxU, array.get(calSumP, idxU) + pU)
    array.set(calSumY, idxU, array.get(calSumY, idxU) + yU)

    array.set(calCnt,  idxF, array.get(calCnt,  idxF) + 1)
    array.set(calSumP, idxF, array.get(calSumP, idxF) + pF)
    array.set(calSumY, idxF, array.get(calSumY, idxF) + yF)

    array.set(calCnt,  idxD, array.get(calCnt,  idxD) + 1)
    array.set(calSumP, idxD, array.get(calSumP, idxD) + pD)
    array.set(calSumY, idxD, array.get(calSumY, idxD) + yD)

    maxLen3 = maxLen * 3
    while array.size(bBuf) > maxLen3
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_eval_stats_one(brierBuf, sumBrier, logBuf, sumLog, ySBuf, sumYS, yLBuf, sumYL, calCnt, calSumP, calSumY) =>
    nScore = array.size(brierBuf)
    brierAvg = nScore == 0 ? na : array.get(sumBrier, 0) / nScore
    logAvg   = nScore == 0 ? na : array.get(sumLog,   0) / nScore

    nS = array.size(ySBuf)
    nL = array.size(yLBuf)
    wS = nS == 0 ? na : array.get(sumYS, 0) / nS
    wL = nL == 0 ? na : array.get(sumYL, 0) / nL
    drift = (na(wS) or na(wL)) ? na : (wS - wL)

    ece = float(na)
    maxErr = float(na)
    B = evalBuckets
    sizeCnt = array.size(calCnt)
    if sizeCnt == B
        tot = 0
        for i = 0 to sizeCnt - 1
            tot += array.get(calCnt, i)
        if tot > 0
            e = 0.0
            m = 0.0
            for i = 0 to sizeCnt - 1
                c = array.get(calCnt, i)
                if c > 0
                    ap = array.get(calSumP, i) / c
                    ay = array.get(calSumY, i) / c
                    err = math.abs(ap - ay)
                    e += err * (c / tot)
                    m := math.max(m, err)
            ece := e
            maxErr := m
    else if sizeCnt == B * 3
        eTot = 0.0
        mTot = 0.0
        for cls = 0 to 2
            totC = 0
            for i = 0 to B - 1
                totC += array.get(calCnt, cls * B + i)
            if totC > 0
                eC = 0.0
                mC = 0.0
                for i = 0 to B - 1
                    idx = cls * B + i
                    c = array.get(calCnt, idx)
                    if c > 0
                        ap = array.get(calSumP, idx) / c
                        ay = array.get(calSumY, idx) / c
                        err = math.abs(ap - ay)
                        eC += err * (c / totC)
                        mC := math.max(mC, err)
                eTot += eC
                mTot := math.max(mTot, mC)
        ece := eTot / 3.0
        maxErr := mTot

    [brierAvg, logAvg, ece, maxErr, wS, wL, drift, nScore]

f_eval_update_one(p, y,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: run if Eval section visible OR background eval enabled,
    // AND we're in history+live mode or on a realtime bar.
    canEval = (showEvalSection or evalInBackground) and ((evalMode == "History+Live") or barstate.isrealtime)
    if canEval
        pc = f_epsClamp(p)

        f_roll_add(brierBuf, sumBrier, f_brier(pc, y), evalRollScore)
        f_roll_add(logBuf,   sumLog,   f_logloss(pc, y), evalRollScore)

        f_roll_add(ySBuf, sumYS, y, evalRollShort)
        f_roll_add(yLBuf, sumYL, y, evalRollLong)

        f_cal_roll_update(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pc, y, evalRollScore)

f_eval_update_one3(pU, pF, pD, outcome,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: run if Eval section visible OR background eval enabled
    canEval = (showEvalSection or evalInBackground) and ((evalMode == "History+Live") or barstate.isrealtime)
    if canEval
        b3 = f_brier3(pU, pF, pD, outcome)
        ll = f_logloss3(pU, pF, pD, outcome)
        yUp = outcome == 1 ? 1.0 : 0.0

        f_roll_add(brierBuf, sumBrier, b3, evalRollScore)
        f_roll_add(logBuf,   sumLog,   ll, evalRollScore)

        f_roll_add(ySBuf, sumYS, yUp, evalRollShort)
        f_roll_add(yLBuf, sumYL, yUp, evalRollLong)

        f_cal_roll_update3(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pU, pF, pD, outcome, evalRollScore)

f_eval_on_resolve(TfState st, pPredN, pPred1, isUp) =>
    y = isUp ? 1.0 : 0.0

    f_eval_update_one(pPredN, y, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
    f_eval_update_one(pPred1, y, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY) =>
    [bAvg_t, lAvg_t, ece_t, _mErr_t, wS_t, wL_t, drift_t, nScore_t] = f_eval_stats_one(evBrier, evSumBrier, evLog, evSumLog, evYS, evSumYS, evYL, evSumYL, evCalCnt, evCalSumP, evCalSumY)
    bAvg = bAvg_t
    lAvg = lAvg_t
    ece = ece_t
    _mErr = _mErr_t
    wS = wS_t
    wL = wL_t
    drift = drift_t
    nScore = nScore_t
    if nScore < evalMinEvents
        [float(na), float(na), float(na), float(na), float(nScore)]
    else
        driftPP = na(drift) ? na : drift * 100.0
        [bAvg, lAvg, ece, driftPP, float(nScore)]

// Table Helpers
f_colLowerBetter(val, goodThr, badThr) =>
    na(val) ? color.new(color.gray, 60) : val < goodThr ? color.new(color.lime, 30) : val > badThr ? color.new(color.red, 30) : color.new(color.yellow, 30)

f_ppSigned(val) =>
    na(val) ? "â€”" : (val > 0 ? "+" : "") + str.tostring(val, "#.1") + "pp"

f_rowEval(tbl, tid, titleStr, evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY, rIdx) =>
    [bs_t, ll_t, ece_t, drift_t, n_t] = f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY)
    bs = bs_t
    ll = ll_t
    ece = ece_t
    drift = drift_t
    n = n_t
    
    // Header
    table.cell(tbl, 0, rIdx, titleStr, text_halign=text.align_left, text_size=size.small, bgcolor=color.new(color.gray, 90))
    
    if na(bs)
        table.cell(tbl, 1, rIdx, "Wait (" + str.tostring(n, "#") + ")", text_size=size.small)
    else
        // Brier
        // scale: typically 0.25 is max entropy. <0.20 is good. <0.15 is great.
        // Let's color based on general intuition
        cBs = f_colLowerBetter(bs, 0.18, 0.23)
        table.cell(tbl, 1, rIdx, str.tostring(bs, "#.3f"), bgcolor=cBs, text_size=size.small)
        
        // LogL
        // scale: ~0.693 is rand. <0.60 is good.
        cLl = f_colLowerBetter(ll, 0.55, 0.65)
        table.cell(tbl, 2, rIdx, str.tostring(ll, "#.3f"), bgcolor=cLl, text_size=size.small)
        
        // ECE
        cEce = f_colLowerBetter(ece, 0.05, 0.10)
        table.cell(tbl, 3, rIdx, str.tostring(ece*100, "#.1")+"%", bgcolor=cEce, text_size=size.small)
        
        // Drift
        cDr = math.abs(drift) > driftWarnPP ? color.new(color.red, 30) : color.new(color.gray, 90)
        table.cell(tbl, 4, rIdx, f_ppSigned(drift), bgcolor=cDr, text_size=size.small)


f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0.0), array.fill(st.upN, 0.0), array.fill(st.dnN, 0.0)
    array.fill(st.cnt1, 0.0), array.fill(st.up1, 0.0), array.fill(st.dn1, 0.0)
    array.fill(st.cntN_bull, 0.0), array.fill(st.upN_bull, 0.0), array.fill(st.dnN_bull, 0.0)
    array.fill(st.cntN_bear, 0.0), array.fill(st.upN_bear, 0.0), array.fill(st.dnN_bear, 0.0)
    array.fill(st.cnt1_bull, 0.0), array.fill(st.up1_bull, 0.0), array.fill(st.dn1_bull, 0.0)
    array.fill(st.cnt1_bear, 0.0), array.fill(st.up1_bear, 0.0), array.fill(st.dn1_bear, 0.0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    array.clear(st.qBias)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    array.clear(st.qPUpN)
    array.clear(st.qPFlN)
    array.clear(st.qPDnN)
    array.clear(st.qPUp1)
    array.clear(st.qPFl1)
    array.clear(st.qPDn1)
    array.clear(st.qZUpN)
    array.clear(st.qZFlN)
    array.clear(st.qZDnN)
    array.clear(st.qZUp1)
    array.clear(st.qZFl1)
    array.clear(st.qZDn1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)
    array.set(st.tempN, 0, 1.0)
    array.set(st.temp1, 0, 1.0)
    array.set(st.vecAN, 0, 1.0)
    array.set(st.vecAN, 1, 1.0)
    array.set(st.vecAN, 2, 1.0)
    array.set(st.vecBN, 0, 0.0)
    array.set(st.vecBN, 1, 0.0)
    array.set(st.vecBN, 2, 0.0)
    array.set(st.vecA1, 0, 1.0)
    array.set(st.vecA1, 1, 1.0)
    array.set(st.vecA1, 2, 1.0)
    array.set(st.vecB1, 0, 0.0)
    array.set(st.vecB1, 1, 0.0)
    array.set(st.vecB1, 2, 0.0)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN), array.clear(st.evSumBrierN), array.clear(st.evLogN), array.clear(st.evSumLogN), array.clear(st.evYS_N), array.clear(st.evSumYS_N), array.clear(st.evYL_N), array.clear(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1), array.clear(st.evSumBrier1), array.clear(st.evLog1), array.clear(st.evSumLog1), array.clear(st.evYS_1), array.clear(st.evSumYS_1), array.clear(st.evYL_1), array.clear(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// Process one TF calibration step (updates on new TF bar)
// @param _hid Horizon ID (1-7) - reserved for debugging/logging
f_process_tf(_hid, _tf, newTfBar, sA, 
             cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
             TfState st,
             fcTgt, kB, aThr, pH, tpA, slA,
             alphaNVal, alpha1Val, shrinkKVal, wStateVal, wPullbackVal, wRegimeVal, wTrendVal) =>

    if newTfBar
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = array.get(st.qAge,   i)
            entry_i = array.get(st.qEntry, i)
            atr_i   = array.get(st.qAtr,   i)
            mh_i    = array.get(st.qMaxH,  i)
            ml_i    = array.get(st.qMinL,  i)
            bN_i    = array.get(st.qBinN,  i)
            b1_i    = array.get(st.qBin1,  i)
            bias_i  = array.get(st.qBias,  i)

            // Stored at entry
            float probN_i = na
            float prob1_i = na
            float lgtN_i = na
            float lgt1_i = na
            float predN_i = na
            float pred1_i = na
            if not use3Way
                probN_i := array.get(st.qProbN,  i)
                prob1_i := array.get(st.qProb1,  i)
                lgtN_i  := array.get(st.qLogitN, i)
                lgt1_i  := array.get(st.qLogit1, i)
                predN_i := array.get(st.qPredN,  i)
                pred1_i := array.get(st.qPred1,  i)

            // 3-way stored probs/logits
            float pUpN_i = na
            float pFlN_i = na
            float pDnN_i = na
            float pUp1_i = na
            float pFl1_i = na
            float pDn1_i = na
            float zUpN_i = na
            float zFlN_i = na
            float zDnN_i = na
            float zUp1_i = na
            float zFl1_i = na
            float zDn1_i = na
            if use3Way
                pUpN_i := array.get(st.qPUpN, i)
                pFlN_i := array.get(st.qPFlN, i)
                pDnN_i := array.get(st.qPDnN, i)
                pUp1_i := array.get(st.qPUp1, i)
                pFl1_i := array.get(st.qPFl1, i)
                pDn1_i := array.get(st.qPDn1, i)
                zUpN_i := array.get(st.qZUpN, i)
                zFlN_i := array.get(st.qZFlN, i)
                zDnN_i := array.get(st.qZDnN, i)
                zUp1_i := array.get(st.qZUp1, i)
                zFl1_i := array.get(st.qZFl1, i)
                zDn1_i := array.get(st.qZDn1, i)

            resolved = false
            doUpdate = false
            isUp     = false
            int outcome = 0

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                    else
                        doUpdate := true
                        if use3Way
                            db = f_db_mult(_tf) * atr_i
                            delta = cNow - entry_i
                            outcome := f_outcome3(delta, db)
                            isUp := outcome == 1
                        else
                            retATR = (cNow - entry_i) / atr_i
                            isUp := retATR >= aThr
                            outcome := isUp ? 1 : -1

            else // PathTPvsSL
                tpPx = entry_i + tpA * atr_i
                slPx = entry_i - slA * atr_i
                winHit  = mh_i >= tpPx
                lossHit = ml_i <= slPx

                if winHit or lossHit
                    resolved := true
                    doUpdate := true
                    if winHit and lossHit
                        if pathTiePolicy == "Win"
                            isUp := true
                            outcome := 1
                        else if pathTiePolicy == "Neutral"
                            if use3Way
                                outcome := 0
                            else
                                doUpdate := false
                        else
                            isUp := false
                            outcome := -1
                    else
                        isUp := winHit and not lossHit
                        outcome := isUp ? 1 : -1

                else if age_i >= pH
                    resolved := true
                    if noHitPolicy == "Loss"
                        doUpdate := true
                        isUp := false
                        outcome := -1
                    else if use3Way and (noHitPolicy == "Neutral" or noHitPolicy == "Ignore")
                        doUpdate := true
                        outcome := 0
                    else
                        doUpdate := false

            if resolved
                if doUpdate
                    if not use3Way
                        outcome := isUp ? 1 : -1
                    if use3Way
                        f_decay_counts(st.cntN, st.upN, st.dnN, countDecay)
                        f_decay_counts(st.cnt1, st.up1, st.dn1, countDecay)
                    f_cal_update3(st.cntN, st.upN, st.dnN, bN_i, outcome)
                    f_cal_update3(st.cnt1, st.up1, st.dn1, b1_i, outcome)

                    if use3Way and useBullBearCal
                        useBull = bias_i >= 0
                        cntN_sel = useBull ? st.cntN_bull : st.cntN_bear
                        upN_sel  = useBull ? st.upN_bull  : st.upN_bear
                        dnN_sel  = useBull ? st.dnN_bull  : st.dnN_bear
                        cnt1_sel = useBull ? st.cnt1_bull : st.cnt1_bear
                        up1_sel  = useBull ? st.up1_bull  : st.up1_bear
                        dn1_sel  = useBull ? st.dn1_bull  : st.dn1_bear
                        f_decay_counts(cntN_sel, upN_sel, dnN_sel, countDecay)
                        f_decay_counts(cnt1_sel, up1_sel, dn1_sel, countDecay)
                        f_cal_update3(cntN_sel, upN_sel, dnN_sel, bN_i, outcome)
                        f_cal_update3(cnt1_sel, up1_sel, dn1_sel, b1_i, outcome)
                    
                    outcomeVal = isUp ? 1.0 : 0.0
                    
                    // --- Evaluation (Live Scoring) ---
                    // Score based on the final prediction we made (predN_i / pred1_i)
                    if use3Way
                        f_eval_update_one3(pUpN_i, pFlN_i, pDnN_i, outcome,
                            st.evBrierN, st.evSumBrierN,
                            st.evLogN, st.evSumLogN,
                            st.evYS_N, st.evSumYS_N,
                            st.evYL_N, st.evSumYL_N,
                            st.evCalCntN, st.evCalSumPN, st.evCalSumYN,
                            st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
                        f_eval_update_one3(pUp1_i, pFl1_i, pDn1_i, outcome,
                            st.evBrier1, st.evSumBrier1,
                            st.evLog1, st.evSumLog1,
                            st.evYS_1, st.evSumYS_1,
                            st.evYL_1, st.evSumYL_1,
                            st.evCalCnt1, st.evCalSumP1, st.evCalSumY1,
                            st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)
                    else
                        f_eval_on_resolve(st, predN_i, pred1_i, isUp)

                    if use3Way and calibratorMode != "Off"
                        nBinN_cur = array.get(st.cntN, bN_i)
                        nBin1_cur = array.get(st.cnt1, b1_i)
                        canCalN = not cal3AutoFallback or nBinN_cur >= cal3MinSamples
                        canCal1 = not cal3AutoFallback or nBin1_cur >= cal3MinSamples
                        yU = outcome == 1 ? 1.0 : 0.0
                        yF = outcome == 0 ? 1.0 : 0.0
                        yD = outcome == -1 ? 1.0 : 0.0

                        if calibratorMode == "Temp"
                            if canCalN
                                tN = array.get(st.tempN, 0)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(zUpN_i / tN, zFlN_i / tN, zDnN_i / tN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                gradN = ((pUNc - yU) * zUpN_i + (pFNc - yF) * zFlN_i + (pDNc - yD) * zDnN_i) / (tN * tN)
                                tN := f_clamp(tN - lrCal * gradN, tempMin, tempMax)
                                array.set(st.tempN, 0, tN)

                            if canCal1
                                t1 = array.get(st.temp1, 0)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(zUp1_i / t1, zFl1_i / t1, zDn1_i / t1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                grad1 = ((pU1c - yU) * zUp1_i + (pF1c - yF) * zFl1_i + (pD1c - yD) * zDn1_i) / (t1 * t1)
                                t1 := f_clamp(t1 - lrCal * grad1, tempMin, tempMax)
                                array.set(st.temp1, 0, t1)
                        else if calibratorMode == "Vector"
                            if canCalN
                                aUN = array.get(st.vecAN, 0)
                                aFN = array.get(st.vecAN, 1)
                                aDN = array.get(st.vecAN, 2)
                                bUN = array.get(st.vecBN, 0)
                                bFN = array.get(st.vecBN, 1)
                                bDN = array.get(st.vecBN, 2)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(aUN * zUpN_i + bUN, aFN * zFlN_i + bFN, aDN * zDnN_i + bDN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                aUN := f_clamp(aUN - lrCal * (pUNc - yU) * zUpN_i, vecAMin, vecAMax)
                                aFN := f_clamp(aFN - lrCal * (pFNc - yF) * zFlN_i, vecAMin, vecAMax)
                                aDN := f_clamp(aDN - lrCal * (pDNc - yD) * zDnN_i, vecAMin, vecAMax)
                                bUN := f_clamp(bUN - lrCal * (pUNc - yU), vecBMin, vecBMax)
                                bFN := f_clamp(bFN - lrCal * (pFNc - yF), vecBMin, vecBMax)
                                bDN := f_clamp(bDN - lrCal * (pDNc - yD), vecBMin, vecBMax)
                                array.set(st.vecAN, 0, aUN)
                                array.set(st.vecAN, 1, aFN)
                                array.set(st.vecAN, 2, aDN)
                                array.set(st.vecBN, 0, bUN)
                                array.set(st.vecBN, 1, bFN)
                                array.set(st.vecBN, 2, bDN)

                            if canCal1
                                aU1 = array.get(st.vecA1, 0)
                                aF1 = array.get(st.vecA1, 1)
                                aD1 = array.get(st.vecA1, 2)
                                bU1 = array.get(st.vecB1, 0)
                                bF1 = array.get(st.vecB1, 1)
                                bD1 = array.get(st.vecB1, 2)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(aU1 * zUp1_i + bU1, aF1 * zFl1_i + bF1, aD1 * zDn1_i + bD1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                aU1 := f_clamp(aU1 - lrCal * (pU1c - yU) * zUp1_i, vecAMin, vecAMax)
                                aF1 := f_clamp(aF1 - lrCal * (pF1c - yF) * zFl1_i, vecAMin, vecAMax)
                                aD1 := f_clamp(aD1 - lrCal * (pD1c - yD) * zDn1_i, vecAMin, vecAMax)
                                bU1 := f_clamp(bU1 - lrCal * (pU1c - yU), vecBMin, vecBMax)
                                bF1 := f_clamp(bF1 - lrCal * (pF1c - yF), vecBMin, vecBMax)
                                bD1 := f_clamp(bD1 - lrCal * (pD1c - yD), vecBMin, vecBMax)
                                array.set(st.vecA1, 0, aU1)
                                array.set(st.vecA1, 1, aF1)
                                array.set(st.vecA1, 2, aD1)
                                array.set(st.vecB1, 0, bU1)
                                array.set(st.vecB1, 1, bF1)
                                array.set(st.vecB1, 2, bD1)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    if not use3Way
                        nBinN_cur = array.get(st.cntN, bN_i)
                        if nBinN_cur >= calMinSamples
                            // Brier on raw prob
                            sqErrN = math.pow(outcomeVal - probN_i, 2)
                            curSumN = array.get(st.brierStatsN, 0)
                            curCntN = array.get(st.brierStatsN, 1)
                            array.set(st.brierStatsN, 0, curSumN + sqErrN)
                            array.set(st.brierStatsN, 1, curCntN + 1.0)
                            
                            // Platt SGD
                            if usePlatt
                                aN = array.get(st.plattN, 0)
                                bN = array.get(st.plattN, 1)
                                pAdj = f_sigmoid(aN * lgtN_i + bN)
                                err = pAdj - outcomeVal
                                da = err * lgtN_i
                                db = err
                                // Update
                                aN := math.max(0.1, math.min(5.0, aN - lrPlatt * da)) 
                                bN := math.max(-3.0, math.min(3.0, bN - lrPlatt * db))
                                array.set(st.plattN, 0, aN)
                                array.set(st.plattN, 1, bN)
                                
                                // LogLoss
                                pLL = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj))
                                ll = -(outcomeVal * math.log(pLL) + (1.0 - outcomeVal) * math.log(1.0 - pLL))
                                curSumLL = array.get(st.llStatsN, 0)
                                curCntLL = array.get(st.llStatsN, 1)
                                array.set(st.llStatsN, 0, curSumLL + ll)
                                array.set(st.llStatsN, 1, curCntLL + 1.0)
                        
                        // --- Phase 4: SGD Update & LogLoss (1) ---
                        sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                        curSum1 = array.get(st.brierStats1, 0)
                        curCnt1 = array.get(st.brierStats1, 1)
                        array.set(st.brierStats1, 0, curSum1 + sqErr1)
                        array.set(st.brierStats1, 1, curCnt1 + 1.0)

                        if usePlatt
                            pltA1 = array.get(st.platt1, 0)
                            pltB1 = array.get(st.platt1, 1)
                            pAdj1 = f_sigmoid(pltA1 * lgt1_i + pltB1)
                            err1 = pAdj1 - outcomeVal
                            da1 = err1 * lgt1_i
                            db1 = err1
                            pltA1 := math.max(0.1, math.min(5.0, pltA1 - lrPlatt * da1))
                            pltB1 := math.max(-3.0, math.min(3.0, pltB1 - lrPlatt * db1))
                            array.set(st.platt1, 0, pltA1)
                            array.set(st.platt1, 1, pltB1)
                            
                            pLL1 = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj1))
                            ll1 = -(outcomeVal * math.log(pLL1) + (1.0 - outcomeVal) * math.log(1.0 - pLL1))
                            curSumLL1 = array.get(st.llStats1, 0)
                            curCntLL1 = array.get(st.llStats1, 1)
                            array.set(st.llStats1, 0, curSumLL1 + ll1)
                            array.set(st.llStats1, 1, curCntLL1 + 1.0)

                if not use3Way
                    array.remove(st.qProbN, i)
                    array.remove(st.qProb1, i)
                    array.remove(st.qLogitN, i)
                    array.remove(st.qLogit1, i)
                    array.remove(st.qPredN, i)
                    array.remove(st.qPred1, i)
                if use3Way
                    array.remove(st.qPUpN, i)
                    array.remove(st.qPFlN, i)
                    array.remove(st.qPDnN, i)
                    array.remove(st.qPUp1, i)
                    array.remove(st.qPFl1, i)
                    array.remove(st.qPDn1, i)
                    array.remove(st.qZUpN, i)
                    array.remove(st.qZFlN, i)
                    array.remove(st.qZDnN, i)
                    array.remove(st.qZUp1, i)
                    array.remove(st.qZFl1, i)
                    array.remove(st.qZDn1, i)
                array.remove(st.qAge,   i)
                array.remove(st.qMaxH,  i)
                array.remove(st.qMinL,  i)
                array.remove(st.qAtr,   i)
                array.remove(st.qEntry, i)
                array.remove(st.qBinN,  i)
                array.remove(st.qBin1,  i)
                array.remove(st.qBias, i)
            i -= 1
        bias = emaFNow > emaSNow ? 1 : -1
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        // Epsilon 0.0001 prevents division by zero on penny stocks or exotic instruments with close near 0
        atrNorm = atrNow / math.max(cNow, 0.0001)
        sD = f_trend_regime(emaFNow, emaSNow, atrNorm)
        sEns = f_ensemble4(sA, sB, sC, sD, wStateVal, wPullbackVal, wRegimeVal, wTrendVal)
        f_update_quantiles(sEns)
        
        // --- Phase 2: 2D Binning ---
        bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, qCutsN)
        b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, qCuts1)

        biasFlag = useBullBearCal ? f_bias_from_score(sA) : 0
        cntN_sel = useBullBearCal ? (biasFlag >= 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        upN_sel  = useBullBearCal ? (biasFlag >= 0 ? st.upN_bull  : st.upN_bear)  : st.upN
        dnN_sel  = useBullBearCal ? (biasFlag >= 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
        cnt1_sel = useBullBearCal ? (biasFlag >= 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
        up1_sel  = useBullBearCal ? (biasFlag >= 0 ? st.up1_bull  : st.up1_bear)  : st.up1
        dn1_sel  = useBullBearCal ? (biasFlag >= 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1

        if use3Way
            [pUrawN_t, pFrawN_t, pDrawN_t, _nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaNVal, shrinkKVal, kShrinkReg)
            [pUraw1_t, pFraw1_t, pDraw1_t, _n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1Val, shrinkKVal, kShrinkReg)
            pUrawN = pUrawN_t
            pFrawN = pFrawN_t
            pDrawN = pDrawN_t
            _nN = _nN_t
            pUraw1 = pUraw1_t
            pFraw1 = pFraw1_t
            pDraw1 = pDraw1_t
            _n1 = _n1_t

            zUN = f_safe_log(pUrawN)
            zFN = f_safe_log(pFrawN)
            zDN = f_safe_log(pDrawN)
            zU1 = f_safe_log(pUraw1)
            zF1 = f_safe_log(pFraw1)
            zD1 = f_safe_log(pDraw1)

            useCalN = f_can_cal3(_nN)
            useCal1 = f_can_cal3(_n1)
            float pUN = na
            float pFN = na
            float pDN = na
            float pU1 = na
            float pF1 = na
            float pD1 = na
            if useCalN
                [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, st.tempN, st.vecAN, st.vecBN)
                pUN := tUN_t
                pFN := tFN_t
                pDN := tDN_t
            else
                pUN := pUrawN
                pFN := pFrawN
                pDN := pDrawN
            if useCal1
                [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, st.temp1, st.vecA1, st.vecB1)
                pU1 := tU1_t
                pF1 := tF1_t
                pD1 := tD1_t
            else
                pU1 := pUraw1
                pF1 := pFraw1
                pD1 := pDraw1

            array.push(st.qBinN,  bN)
            array.push(st.qBin1,  b1)
            array.push(st.qEntry, cNow)
            array.push(st.qAtr,   atrNow)

            array.push(st.qMaxH,  cNow)
            array.push(st.qMinL,  cNow)

            array.push(st.qAge,   0)
            array.push(st.qBias,  biasFlag)

            array.push(st.qPUpN, pUN)
            array.push(st.qPFlN, pFN)
            array.push(st.qPDnN, pDN)
            array.push(st.qPUp1, pU1)
            array.push(st.qPFl1, pF1)
            array.push(st.qPDn1, pD1)

            array.push(st.qZUpN, zUN)
            array.push(st.qZFlN, zFN)
            array.push(st.qZDnN, zDN)
            array.push(st.qZUp1, zU1)
            array.push(st.qZFl1, zF1)
            array.push(st.qZDn1, zD1)
        else
            // Capture current probabilities
            [pNowN_t, _nN_t] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
            [pNow1_t, _n1_t] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)
            pNowN = pNowN_t
            _nN = _nN_t
            pNow1 = pNow1_t
            _n1 = _n1_t

            // Logits (Phase 4)
            lgtN = f_logit(pNowN)
            lgt1 = f_logit(pNow1)

            // Platt Adjust (Display/Predict)
            aN = array.get(st.plattN, 0)
            bN_p = array.get(st.plattN, 1)
            pAdjN = f_sigmoid(aN * lgtN + bN_p)

            pltA1 = array.get(st.platt1, 0)
            pltB1_p = array.get(st.platt1, 1)
            pAdj1 = f_sigmoid(pltA1 * lgt1 + pltB1_p)

            // Use adjusted if Platt enabled, else raw
            pFinalN = usePlatt ? pAdjN : pNowN
            pFinal1 = usePlatt ? pAdj1 : pNow1

            array.push(st.qBinN,  bN)
            array.push(st.qBin1,  b1)
            array.push(st.qEntry, cNow)
            array.push(st.qAtr,   atrNow)

            array.push(st.qMaxH,  cNow)
            array.push(st.qMinL,  cNow)

            array.push(st.qAge,   0)
            array.push(st.qBias,  biasFlag)

            array.push(st.qProbN, pNowN)
            array.push(st.qProb1, pNow1)
            array.push(st.qLogitN, lgtN)
            array.push(st.qLogit1, lgt1)
            array.push(st.qPredN, pFinalN)
            array.push(st.qPred1, pFinal1)

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ? ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("300")) ? rsiLenFastTF : (not na(baseSecs) and baseSecs <= timeframe.in_seconds("3600")) ? rsiLenMidTF : rsiLenSlowTF) : rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime (protect against close=0 on exotic instruments)
atrRank = close == 0 ? 0.5 : f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? nz(volRankRaw, 0.5) : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // global per-bar
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)

    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier = config == "Standard" ? 1.00 : config == "Pro" ? 1.05 : config == "V2 Essential" ? 0.95 : config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30")) ? "Short" : (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown
gateLongNow  = (confidence >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidence >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice = zoneAnchor == "Entry" and not na(entryPrice) ? entryPrice : zoneAnchor == "VWAP" ? vwapVal : zoneAnchor == "MA200" ? sma200Val : zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "â€”"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)

f_getBrier(tfSel, modSel) =>
    float score = 0.5 // default safe
    
    // Select array pair stats
    float[] stats = na
    if tfSel == "F1"
        stats := (modSel == "N") ? tf1State.brierStatsN : tf1State.brierStats1
    else if tfSel == "F2"
        stats := (modSel == "N") ? tf2State.brierStatsN : tf2State.brierStats1
    else if tfSel == "F3"
        stats := (modSel == "N") ? tf3State.brierStatsN : tf3State.brierStats1
    else if tfSel == "F4"
        stats := (modSel == "N") ? tf4State.brierStatsN : tf4State.brierStats1
    else if tfSel == "F5"
        stats := (modSel == "N") ? tf5State.brierStatsN : tf5State.brierStats1
    else if tfSel == "F6"
        stats := (modSel == "N") ? tf6State.brierStatsN : tf6State.brierStats1
    else if tfSel == "F7"
        stats := (modSel == "N") ? tf7State.brierStatsN : tf7State.brierStats1
    
    if not na(stats)
        s = array.get(stats, 0)
        c = array.get(stats, 1)
        if c > 0
            score := s / c
    score

f_get_total_samples(tfSel, modSel) =>
    float total = 0.0
    float[] cnt = na
    if tfSel == "F1"
        cnt := (modSel == "N") ? tf1State.cntN : tf1State.cnt1
    else if tfSel == "F2"
        cnt := (modSel == "N") ? tf2State.cntN : tf2State.cnt1
    else if tfSel == "F3"
        cnt := (modSel == "N") ? tf3State.cntN : tf3State.cnt1
    else if tfSel == "F4"
        cnt := (modSel == "N") ? tf4State.cntN : tf4State.cnt1
    else if tfSel == "F5"
        cnt := (modSel == "N") ? tf5State.cntN : tf5State.cnt1
    else if tfSel == "F6"
        cnt := (modSel == "N") ? tf6State.cntN : tf6State.cnt1
    else if tfSel == "F7"
        cnt := (modSel == "N") ? tf7State.cntN : tf7State.cnt1

    if not na(cnt)
        total := array.sum(cnt)
    total

var float totN1 = na
var float totN2 = na
var float totN3 = na
var float totN4 = na
var float totN5 = na
var float totN6 = na
var float totN7 = na
var float tot11 = na
var float tot12 = na
var float tot13 = na
var float tot14 = na
var float tot15 = na
var float tot16 = na
var float tot17 = na

var float pUN1 = na
var float pFN1 = na
var float pDN1 = na
var float pUN2 = na
var float pFN2 = na
var float pDN2 = na
var float pUN3 = na
var float pFN3 = na
var float pDN3 = na
var float pUN4 = na
var float pFN4 = na
var float pDN4 = na
var float pUN5 = na
var float pFN5 = na
var float pDN5 = na
var float pUN6 = na
var float pFN6 = na
var float pDN6 = na
var float pUN7 = na
var float pFN7 = na
var float pDN7 = na

var float nN1 = na
var float nN2 = na
var float nN3 = na
var float nN4 = na
var float nN5 = na
var float nN6 = na
var float nN7 = na

var float pU11 = na
var float pF11 = na
var float pD11 = na
var float pU12 = na
var float pF12 = na
var float pD12 = na
var float pU13 = na
var float pF13 = na
var float pD13 = na
var float pU14 = na
var float pF14 = na
var float pD14 = na
var float pU15 = na
var float pF15 = na
var float pD15 = na
var float pU16 = na
var float pF16 = na
var float pD16 = na
var float pU17 = na
var float pF17 = na
var float pD17 = na

var float n11p = na
var float n12p = na
var float n13p = na
var float n14p = na
var float n15p = na
var float n16p = na
var float n17p = na

f_get_rel_vals(tfSel, modSel) =>
    float pU = na
    float pF = na
    float pD = na
    float nBin = na
    float total = na
    if modSel == "N"
        if tfSel == "F1"
            pU := pUN1, pF := pFN1, pD := pDN1, nBin := nN1, total := totN1
        else if tfSel == "F2"
            pU := pUN2, pF := pFN2, pD := pDN2, nBin := nN2, total := totN2
        else if tfSel == "F3"
            pU := pUN3, pF := pFN3, pD := pDN3, nBin := nN3, total := totN3
        else if tfSel == "F4"
            pU := pUN4, pF := pFN4, pD := pDN4, nBin := nN4, total := totN4
        else if tfSel == "F5"
            pU := pUN5, pF := pFN5, pD := pDN5, nBin := nN5, total := totN5
        else if tfSel == "F6"
            pU := pUN6, pF := pFN6, pD := pDN6, nBin := nN6, total := totN6
        else if tfSel == "F7"
            pU := pUN7, pF := pFN7, pD := pDN7, nBin := nN7, total := totN7
    else
        if tfSel == "F1"
            pU := pU11, pF := pF11, pD := pD11, nBin := n11p, total := tot11
        else if tfSel == "F2"
            pU := pU12, pF := pF12, pD := pD12, nBin := n12p, total := tot12
        else if tfSel == "F3"
            pU := pU13, pF := pF13, pD := pD13, nBin := n13p, total := tot13
        else if tfSel == "F4"
            pU := pU14, pF := pF14, pD := pD14, nBin := n14p, total := tot14
        else if tfSel == "F5"
            pU := pU15, pF := pF15, pD := pD15, nBin := n15p, total := tot15
        else if tfSel == "F6"
            pU := pU16, pF := pF16, pD := pD16, nBin := n16p, total := tot16
        else if tfSel == "F7"
            pU := pU17, pF := pF17, pD := pD17, nBin := n17p, total := tot17
    [pU, pF, pD, nBin, total]

f_decision_quality(pU, pF, pD, nBin, total) =>
    maxP = math.max(pU, math.max(pF, pD))
    minP = math.min(pU, math.min(pF, pD))
    midP = (pU + pF + pD) - maxP - minP
    edge = maxP - midP
    totalOk = (not evidenceGate) or (total >= evidenceMinTotal)
    ok = (not use3Way) ? true : (edge >= abstainMinEdge and nBin >= calMinSamples and totalOk)
    reason = (evidenceGate and total < evidenceMinTotal) ? "low total" : nBin < calMinSamples ? "weak bin" : edge < abstainMinEdge ? "low edge" : "ok"
    label = ok ? "OK" : "ABSTAIN (" + reason + ")"
    col = ok ? color.lime : color.orange
    [ok, label, col, edge]

curBrier = f_getBrier(relFilterTF, relFilterModel)
reliabilityOk = (not useRelFilter) or (curBrier <= maxBrier)
evidenceOk = (not evidenceGate) or (f_get_total_samples(relFilterTF, relFilterModel) >= evidenceMinTotal)

[pRelU_t, pRelF_t, pRelD_t, nRel_t, totRel_t] = f_get_rel_vals(relFilterTF, relFilterModel)
pRelU = pRelU_t
pRelF = pRelF_t
pRelD = pRelD_t
nRel = nRel_t
totRel = totRel_t
[decisionOk_t, decisionLabel_t, decisionColor_t, decisionEdge_t] = f_decision_quality(pRelU, pRelF, pRelD, nRel, totRel)
decisionOk = decisionOk_t
decisionLabel = decisionLabel_t
decisionColor = decisionColor_t
decisionEdge = decisionEdge_t
decisionEdgeTxt = (not use3Way or na(decisionEdge)) ? "â€”" : str.tostring(decisionEdge * 100.0, "#.1") + "pp"

allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose and reliabilityOk and evidenceOk and (not abstainGate or decisionOk)
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"

//====================
// Alerts
//====================
alertcondition(buySignal,   title="BUY",   message="BUY")
alertcondition(exitSignal,  title="EXIT",  message="EXIT")
alertcondition(shortSignal, title="SHORT", message="SHORT")
alertcondition(coverSignal, title="COVER", message="COVER")

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 25))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Outlook/Forecast packs (one security call per horizon TF)
//====================
[t1_t, c1_t, h1_t, l1_t, ef1_t, es1_t, r1_t, a1_t, vR1_t] = f_tf_pack(tfF1)
[t2_t, c2_t, h2_t, l2_t, ef2_t, es2_t, r2_t, a2_t, vR2_t] = f_tf_pack(tfF2)
[t3_t, c3_t, h3_t, l3_t, ef3_t, es3_t, r3_t, a3_t, vR3_t] = f_tf_pack(tfF3)
[t4_t, c4_t, h4_t, l4_t, ef4_t, es4_t, r4_t, a4_t, vR4_t] = f_tf_pack(tfF4)
[t5_t, c5_t, h5_t, l5_t, ef5_t, es5_t, r5_t, a5_t, vR5_t] = f_tf_pack(tfF5)
[t6_t, c6_t, h6_t, l6_t, ef6_t, es6_t, r6_t, a6_t, vR6_t] = f_tf_pack(tfF6)
[t7_t, c7_t, h7_t, l7_t, ef7_t, es7_t, r7_t, a7_t, vR7_t] = f_tf_pack(tfF7)
t1 = t1_t, c1 = c1_t, h1 = h1_t, l1 = l1_t, ef1 = ef1_t, es1 = es1_t, r1 = r1_t, a1 = a1_t, vR1 = vR1_t
t2 = t2_t, c2 = c2_t, h2 = h2_t, l2 = l2_t, ef2 = ef2_t, es2 = es2_t, r2 = r2_t, a2 = a2_t, vR2 = vR2_t
t3 = t3_t, c3 = c3_t, h3 = h3_t, l3 = l3_t, ef3 = ef3_t, es3 = es3_t, r3 = r3_t, a3 = a3_t, vR3 = vR3_t
t4 = t4_t, c4 = c4_t, h4 = h4_t, l4 = l4_t, ef4 = ef4_t, es4 = es4_t, r4 = r4_t, a4 = a4_t, vR4 = vR4_t
t5 = t5_t, c5 = c5_t, h5 = h5_t, l5 = l5_t, ef5 = ef5_t, es5 = es5_t, r5 = r5_t, a5 = a5_t, vR5 = vR5_t
t6 = t6_t, c6 = c6_t, h6 = h6_t, l6 = l6_t, ef6 = ef6_t, es6 = es6_t, r6 = r6_t, a6 = a6_t, vR6 = vR6_t
t7 = t7_t, c7 = c7_t, h7 = h7_t, l7 = l7_t, ef7 = ef7_t, es7 = es7_t, r7 = r7_t, a7 = a7_t, vR7 = vR7_t

// Get Target Params per TF
[fcT1_t, kB1_t, aT1_t, pH1_t, tp1_t, sl1_t] = f_get_params(tfF1)
[fcT2_t, kB2_t, aT2_t, pH2_t, tp2_t, sl2_t] = f_get_params(tfF2)
[fcT3_t, kB3_t, aT3_t, pH3_t, tp3_t, sl3_t] = f_get_params(tfF3)
[fcT4_t, kB4_t, aT4_t, pH4_t, tp4_t, sl4_t] = f_get_params(tfF4)
[fcT5_t, kB5_t, aT5_t, pH5_t, tp5_t, sl5_t] = f_get_params(tfF5)
[fcT6_t, kB6_t, aT6_t, pH6_t, tp6_t, sl6_t] = f_get_params(tfF6)
[fcT7_t, kB7_t, aT7_t, pH7_t, tp7_t, sl7_t] = f_get_params(tfF7)
fcT1 = fcT1_t, kB1 = kB1_t, aT1 = aT1_t, pH1 = pH1_t, tp1 = tp1_t, sl1 = sl1_t
fcT2 = fcT2_t, kB2 = kB2_t, aT2 = aT2_t, pH2 = pH2_t, tp2 = tp2_t, sl2 = sl2_t
fcT3 = fcT3_t, kB3 = kB3_t, aT3 = aT3_t, pH3 = pH3_t, tp3 = tp3_t, sl3 = sl3_t
fcT4 = fcT4_t, kB4 = kB4_t, aT4 = aT4_t, pH4 = pH4_t, tp4 = tp4_t, sl4 = sl4_t
fcT5 = fcT5_t, kB5 = kB5_t, aT5 = aT5_t, pH5 = pH5_t, tp5 = tp5_t, sl5 = sl5_t
fcT6 = fcT6_t, kB6 = kB6_t, aT6 = aT6_t, pH6 = pH6_t, tp6 = tp6_t, sl6 = sl6_t
fcT7 = fcT7_t, kB7 = kB7_t, aT7 = aT7_t, pH7 = pH7_t, tp7 = tp7_t, sl7 = sl7_t

chgT1 = ta.change(t1)
chgT2 = ta.change(t2)
chgT3 = ta.change(t3)
chgT4 = ta.change(t4)
chgT5 = ta.change(t5)
chgT6 = ta.change(t6)
chgT7 = ta.change(t7)

newF1 = not na(t1) and (chgT1 != 0)
newF2 = not na(t2) and (chgT2 != 0)
newF3 = not na(t3) and (chgT3 != 0)
newF4 = not na(t4) and (chgT4 != 0)
newF5 = not na(t5) and (chgT5 != 0)
newF6 = not na(t6) and (chgT6 != 0)
newF7 = not na(t7) and (chgT7 != 0)

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

[t1c_t, m1c_t, l1c_t] = f_state_tml(c1, ef1, es1, r1)
[t2c_t, m2c_t, l2c_t] = f_state_tml(c2, ef2, es2, r2)
[t3c_t, m3c_t, l3c_t] = f_state_tml(c3, ef3, es3, r3)
[t4c_t, m4c_t, l4c_t] = f_state_tml(c4, ef4, es4, r4)
[t5c_t, m5c_t, l5c_t] = f_state_tml(c5, ef5, es5, r5)
[t6c_t, m6c_t, l6c_t] = f_state_tml(c6, ef6, es6, r6)
[t7c_t, m7c_t, l7c_t] = f_state_tml(c7, ef7, es7, r7)
t1c = t1c_t, m1c = m1c_t, l1c = l1c_t
t2c = t2c_t, m2c = m2c_t, l2c = l2c_t
t3c = t3c_t, m3c = m3c_t, l3c = l3c_t
t4c = t4c_t, m4c = m4c_t, l4c = l4c_t
t5c = t5c_t, m5c = m5c_t, l5c = l5c_t
t6c = t6c_t, m6c = m6c_t, l6c = l6c_t
t7c = t7c_t, m7c = m7c_t, l7c = l7c_t

outSym(score) => score > 0.05 ? "â–²" : score < -0.05 ? "â–¼" : "âˆ’"
outCol(score) => score > 0.05 ? color.lime : score < -0.05 ? color.red : tblText

isBull1 = f_bias_from_score(outScore1) == 1
isBull2 = f_bias_from_score(outScore2) == 1
isBull3 = f_bias_from_score(outScore3) == 1
isBull4 = f_bias_from_score(outScore4) == 1
isBull5 = f_bias_from_score(outScore5) == 1
isBull6 = f_bias_from_score(outScore6) == 1
isBull7 = f_bias_from_score(outScore7) == 1

cntN1Arr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull : tf1State.cntN_bear) : tf1State.cntN
cnt11Arr = useBullBearCal ? (isBull1 ? tf1State.cnt1_bull : tf1State.cnt1_bear) : tf1State.cnt1
cntN2Arr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull : tf2State.cntN_bear) : tf2State.cntN
cnt12Arr = useBullBearCal ? (isBull2 ? tf2State.cnt1_bull : tf2State.cnt1_bear) : tf2State.cnt1
cntN3Arr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull : tf3State.cntN_bear) : tf3State.cntN
cnt13Arr = useBullBearCal ? (isBull3 ? tf3State.cnt1_bull : tf3State.cnt1_bear) : tf3State.cnt1
cntN4Arr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull : tf4State.cntN_bear) : tf4State.cntN
cnt14Arr = useBullBearCal ? (isBull4 ? tf4State.cnt1_bull : tf4State.cnt1_bear) : tf4State.cnt1
cntN5Arr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull : tf5State.cntN_bear) : tf5State.cntN
cnt15Arr = useBullBearCal ? (isBull5 ? tf5State.cnt1_bull : tf5State.cnt1_bear) : tf5State.cnt1
cntN6Arr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull : tf6State.cntN_bear) : tf6State.cntN
cnt16Arr = useBullBearCal ? (isBull6 ? tf6State.cnt1_bull : tf6State.cnt1_bear) : tf6State.cnt1
cntN7Arr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull : tf7State.cntN_bear) : tf7State.cntN
cnt17Arr = useBullBearCal ? (isBull7 ? tf7State.cnt1_bull : tf7State.cnt1_bear) : tf7State.cnt1

//====================
// Calibration storage â€” per horizon TF (Removed - moved to top)
//====================
// (Moved to top level state)

//====================
// Reset handling (rising edge) â€” per horizon F1..F7
//====================
var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All"
        f_reset_eval_all()
        f_reset_tf(tf1State)
        f_reset_tf(tf2State)
        f_reset_tf(tf3State)
        f_reset_tf(tf4State)
        f_reset_tf(tf5State)
        f_reset_tf(tf6State)
        f_reset_tf(tf7State)

    if resetWhich == "F1"
        f_reset_tf(tf1State)
    if resetWhich == "F2"
        f_reset_tf(tf2State)
    if resetWhich == "F3"
        f_reset_tf(tf3State)
    if resetWhich == "F4"
        f_reset_tf(tf4State)
    if resetWhich == "F5"
        f_reset_tf(tf5State)
    if resetWhich == "F6"
        f_reset_tf(tf6State)
    if resetWhich == "F7"
        f_reset_tf(tf7State)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed and (showTable or showEvalSection)
if doCal
    f_process_tf(1, tfF1, newF1, outScore1, c1, h1, l1, a1, vR1, ef1, es1, tf1State, fcT1, kB1, aT1, pH1, tp1, sl1, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(2, tfF2, newF2, outScore2, c2, h2, l2, a2, vR2, ef2, es2, tf2State, fcT2, kB2, aT2, pH2, tp2, sl2, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(3, tfF3, newF3, outScore3, c3, h3, l3, a3, vR3, ef3, es3, tf3State, fcT3, kB3, aT3, pH3, tp3, sl3, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(4, tfF4, newF4, outScore4, c4, h4, l4, a4, vR4, ef4, es4, tf4State, fcT4, kB4, aT4, pH4, tp4, sl4, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(5, tfF5, newF5, outScore5, c5, h5, l5, a5, vR5, ef5, es5, tf5State, fcT5, kB5, aT5, pH5, tp5, sl5, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(6, tfF6, newF6, outScore6, c6, h6, l6, a6, vR6, ef6, es6, tf6State, fcT6, kB6, aT6, pH6, tp6, sl6, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(7, tfF7, newF7, outScore7, c7, h7, l7, a7, vR7, ef7, es7, tf7State, fcT7, kB7, aT7, pH7, tp7, sl7, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

f_get_disp_vals(_tf, sA, c, atrVal, ef, es, vr, TfState st) =>
    bias = ef > es ? 1 : -1
    sB = f_pullback_score(c, ef, es, bias)
    sC = vr >= VOL_THRESH_HIGH ? -1.0 : (vr <= VOL_THRESH_LOW ? 1.0 : 0.0)
    // Epsilon 0.0001 prevents division by zero on penny stocks or exotic instruments
    atrNorm = atrVal / math.max(c, 0.0001)
    sD = f_trend_regime(ef, es, atrNorm)
    sEns = f_ensemble4(sA, sB, sC, sD, wState, wPullback, wRegime, wTrend)
    bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, qCutsN)
    b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, qCuts1)
    biasSel = useBullBearCal ? f_bias_from_score(sA) : 0
    cntN_sel = useBullBearCal ? (biasSel >= 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
    upN_sel  = useBullBearCal ? (biasSel >= 0 ? st.upN_bull  : st.upN_bear)  : st.upN
    dnN_sel  = useBullBearCal ? (biasSel >= 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
    cnt1_sel = useBullBearCal ? (biasSel >= 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
    up1_sel  = useBullBearCal ? (biasSel >= 0 ? st.up1_bull  : st.up1_bear)  : st.up1
    dn1_sel  = useBullBearCal ? (biasSel >= 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1
    [pUN_t, pFN_t, pDN_t, nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaN, kShrink, kShrinkReg)
    [pU1_t, pF1_t, pD1_t, n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1, kShrink, kShrinkReg)
    pUN = pUN_t
    pFN = pFN_t
    pDN = pDN_t
    nN = nN_t
    pU1 = pU1_t
    pF1 = pF1_t
    pD1 = pD1_t
    n1 = n1_t
    useCalN = f_can_cal3(nN)
    useCal1 = f_can_cal3(n1)
    if useCalN
        zUN = f_safe_log(pUN)
        zFN = f_safe_log(pFN)
        zDN = f_safe_log(pDN)
        [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, st.tempN, st.vecAN, st.vecBN)
        pUN := tUN_t
        pFN := tFN_t
        pDN := tDN_t
    if useCal1
        zU1 = f_safe_log(pU1)
        zF1 = f_safe_log(pF1)
        zD1 = f_safe_log(pD1)
        [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, st.temp1, st.vecA1, st.vecB1)
        pU1 := tU1_t
        pF1 := tF1_t
        pD1 := tD1_t
    [pUN, pFN, pDN, nN, pU1, pF1, pD1, n1]

//====================
// Display values â€” N and 1 per horizon
//====================
[pUN1_t, pFN1_t, pDN1_t, nN1_t, pU11_t, pF11_t, pD11_t, n11p_t] = f_get_disp_vals(tfF1, outScore1, c1, a1, ef1, es1, vR1, tf1State)
[pUN2_t, pFN2_t, pDN2_t, nN2_t, pU12_t, pF12_t, pD12_t, n12p_t] = f_get_disp_vals(tfF2, outScore2, c2, a2, ef2, es2, vR2, tf2State)
[pUN3_t, pFN3_t, pDN3_t, nN3_t, pU13_t, pF13_t, pD13_t, n13p_t] = f_get_disp_vals(tfF3, outScore3, c3, a3, ef3, es3, vR3, tf3State)
[pUN4_t, pFN4_t, pDN4_t, nN4_t, pU14_t, pF14_t, pD14_t, n14p_t] = f_get_disp_vals(tfF4, outScore4, c4, a4, ef4, es4, vR4, tf4State)
[pUN5_t, pFN5_t, pDN5_t, nN5_t, pU15_t, pF15_t, pD15_t, n15p_t] = f_get_disp_vals(tfF5, outScore5, c5, a5, ef5, es5, vR5, tf5State)
[pUN6_t, pFN6_t, pDN6_t, nN6_t, pU16_t, pF16_t, pD16_t, n16p_t] = f_get_disp_vals(tfF6, outScore6, c6, a6, ef6, es6, vR6, tf6State)
[pUN7_t, pFN7_t, pDN7_t, nN7_t, pU17_t, pF17_t, pD17_t, n17p_t] = f_get_disp_vals(tfF7, outScore7, c7, a7, ef7, es7, vR7, tf7State)

pUN1 := pUN1_t, pFN1 := pFN1_t, pDN1 := pDN1_t, nN1 := nN1_t, pU11 := pU11_t, pF11 := pF11_t, pD11 := pD11_t, n11p := n11p_t
pUN2 := pUN2_t, pFN2 := pFN2_t, pDN2 := pDN2_t, nN2 := nN2_t, pU12 := pU12_t, pF12 := pF12_t, pD12 := pD12_t, n12p := n12p_t
pUN3 := pUN3_t, pFN3 := pFN3_t, pDN3 := pDN3_t, nN3 := nN3_t, pU13 := pU13_t, pF13 := pF13_t, pD13 := pD13_t, n13p := n13p_t
pUN4 := pUN4_t, pFN4 := pFN4_t, pDN4 := pDN4_t, nN4 := nN4_t, pU14 := pU14_t, pF14 := pF14_t, pD14 := pD14_t, n14p := n14p_t
pUN5 := pUN5_t, pFN5 := pFN5_t, pDN5 := pDN5_t, nN5 := nN5_t, pU15 := pU15_t, pF15 := pF15_t, pD15 := pD15_t, n15p := n15p_t
pUN6 := pUN6_t, pFN6 := pFN6_t, pDN6 := pDN6_t, nN6 := nN6_t, pU16 := pU16_t, pF16 := pF16_t, pD16 := pD16_t, n16p := n16p_t
pUN7 := pUN7_t, pFN7 := pFN7_t, pDN7 := pDN7_t, nN7 := nN7_t, pU17 := pU17_t, pF17 := pF17_t, pD17 := pD17_t, n17p := n17p_t

// --- Total resolved samples per TF (across all bins)
totN1 := f_sum_int_array(cntN1Arr)
totN2 := f_sum_int_array(cntN2Arr)
totN3 := f_sum_int_array(cntN3Arr)
totN4 := f_sum_int_array(cntN4Arr)
totN5 := f_sum_int_array(cntN5Arr)
totN6 := f_sum_int_array(cntN6Arr)
totN7 := f_sum_int_array(cntN7Arr)

tot11 := f_sum_int_array(cnt11Arr)
tot12 := f_sum_int_array(cnt12Arr)
tot13 := f_sum_int_array(cnt13Arr)
tot14 := f_sum_int_array(cnt14Arr)
tot15 := f_sum_int_array(cnt15Arr)
tot16 := f_sum_int_array(cnt16Arr)
tot17 := f_sum_int_array(cnt17Arr)

// calibration â€œenabled for displayâ€ if forecast enabled + we have any resolved samples in that TF
canF1N = enableForecast and (totN1 > 0)
canF2N = enableForecast and (totN2 > 0)
canF3N = enableForecast and (totN3 > 0)
canF4N = enableForecast and (totN4 > 0)
canF5N = enableForecast and (totN5 > 0)
canF6N = enableForecast and (totN6 > 0)
canF7N = enableForecast and (totN7 > 0)

canF11 = enableForecast and (tot11 > 0)
canF12 = enableForecast and (tot12 > 0)
canF13 = enableForecast and (tot13 > 0)
canF14 = enableForecast and (tot14 > 0)
canF15 = enableForecast and (tot15 > 0)
canF16 = enableForecast and (tot16 > 0)
canF17 = enableForecast and (tot17 > 0)


//====================
// Table helpers MUST be global (cannot be defined inside if-block)
//====================
var table gT = na
if na(gT)
    tblCols = 10
    tblRows = 16
    gT := table.new(position.middle_right, tblCols, tblRows, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

f_bin_quality(pTop, nBin) =>
    if nBin <= 0
        ["warmup", tblTextDim]
    else if nBin < calMinSamples
        ["warmup", tblTextDim]
    else
        hw = f_ci95_halfwidth(pTop, nBin)
        lbl = na(hw) ? "warmup" : hw <= 0.05 ? "strong" : hw <= 0.10 ? "ok" : "weak"
        col = na(hw) ? tblTextDim : hw <= 0.05 ? color.lime : hw <= 0.10 ? color.yellow : color.orange
        [lbl, col]

f_rowTF(_tf, score, tC, mC, lC, rV,
        pUN, pFN, pDN, nBin,
        rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(_tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 1, rRow, outSym(score),  text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, rRow, str.tostring(tC) + "/" + str.tostring(mC) + "/" + str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    enabled = enableForecast
    useCalN = enabled and (nBin >= calMinSamples)
    [pUprio_t, pFprio_t, pDprio_t] = f_prior3(_tf, score)
    pUprio = pUprio_t
    pFprio = pFprio_t
    pDprio = pDprio_t
    pU = useCalN ? pUN : pUprio
    pF = useCalN ? pFN : pFprio
    pD = useCalN ? pDN : pDprio

    maxP = math.max(pU, math.max(pF, pD))
    dirSym = maxP < dirMinProb ? "Â·" : (pU == maxP ? "â–²" : pD == maxP ? "â–¼" : "â– ")
    dirCol = pU == maxP ? color.lime : pD == maxP ? color.red : color.yellow

    table.cell(gT, 5, rRow, dirSym, text_color=dirCol, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 6, rRow, str.tostring(pU * 100, "#.0") + "%", text_color=color.lime, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 7, rRow, str.tostring(pF * 100, "#.0") + "%", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 8, rRow, str.tostring(pD * 100, "#.0") + "%", text_color=color.red, bgcolor=tblCell, text_size=size.tiny)

    [qLbl_t, qCol_t] = f_bin_quality(maxP, nBin)
    qLbl = qLbl_t
    qCol = qCol_t
    nTxt = "n=" + str.tostring(nBin) + " " + qLbl
    table.cell(gT, 9, rRow, nTxt, text_color=qCol, bgcolor=tblCell, text_size=size.tiny)

f_fmtBrier(stats) =>
    s = array.get(stats, 0)
    c = array.get(stats, 1)
    val = c > 0 ? s / c : na
    txt = na(val) ? "â€”" : str.tostring(val, "#.###")
    col = na(val) ? tblTextDim : val < 0.20 ? color.green : val < 0.25 ? color.lime : val < 0.30 ? color.yellow : color.red
    [txt, col]

f_fmtCnt(stats) =>
    c = array.get(stats, 1)
    [str.tostring(c, "#"), c < 10 ? tblTextDim : tblText]

f_rowRel(tf, statsN, stats1, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    
    [tBN_t, cBN_t] = f_fmtBrier(statsN)
    tBN = tBN_t
    cBN = cBN_t
    table.cell(gT, 1, rRow, tBN, text_color=cBN, bgcolor=tblCell, text_size=size.tiny)
    
    [tB1_t, cB1_t] = f_fmtBrier(stats1)
    tB1 = tB1_t
    cB1 = cB1_t
    table.cell(gT, 2, rRow, tB1, text_color=cB1, bgcolor=tblCell, text_size=size.tiny)
    
    [tcN_t, ccN_t] = f_fmtCnt(statsN)
    tcN = tcN_t
    ccN = ccN_t
    table.cell(gT, 3, rRow, tcN, text_color=ccN, bgcolor=tblCell, text_size=size.tiny)
    
    [tc1_t, cc1_t] = f_fmtCnt(stats1)
    tc1 = tc1_t
    cc1 = cc1_t
    table.cell(gT, 4, rRow, tc1, text_color=cc1, bgcolor=tblCell, text_size=size.tiny)

//====================
// Table (5 columns) â€” rendered on confirmed bars (stable)
//====================
mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow
c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblText

targetDesc = "Multi-Profile (See Settings). Fast: " + fcTargetF + ", Mid: " + fcTargetM + ", Slow: " + fcTargetS

if showTable and barstate.islast
    tblCols = 10
    table.clear(gT, 0, 0, tblCols - 1, 15)

    // Status rows
    table.cell(gT, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(gT, 2, 0, "Decision", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 0, decisionLabel, text_color=decisionColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, 0, decisionEdgeTxt, text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 5, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 6, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 7, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 8, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 9, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 2, volStr,   text_color=c_vol,      bgcolor=tblCell,   text_size=size.tiny)

    table.cell(gT, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 3, strengthStr, text_color=c_strength, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    // Outlook header + forecast columns
    table.cell(gT, 0, 8, "Outlook", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 8, "Bias",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 2, 8, "Score",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 8, "T/M/L",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 4, 8, "RSI",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 5, 8, "Dir",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 6, 8, "Up%",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 7, 8, "Flat%",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 8, 8, "Down%",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 9, 8, "nCur",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    f_rowTF(tfF1, outScore1, t1c, m1c, l1c, r1, pUN1, pFN1, pDN1, nN1, 9)
    f_rowTF(tfF2, outScore2, t2c, m2c, l2c, r2, pUN2, pFN2, pDN2, nN2, 10)
    f_rowTF(tfF3, outScore3, t3c, m3c, l3c, r3, pUN3, pFN3, pDN3, nN3, 11)
    f_rowTF(tfF4, outScore4, t4c, m4c, l4c, r4, pUN4, pFN4, pDN4, nN4, 12)
    f_rowTF(tfF5, outScore5, t5c, m5c, l5c, r5, pUN5, pFN5, pDN5, nN5, 13)
    f_rowTF(tfF6, outScore6, t6c, m6c, l6c, r6, pUN6, pFN6, pDN6, nN6, 14)
    f_rowTF(tfF7, outScore7, t7c, m7c, l7c, r7, pUN7, pFN7, pDN7, nN7, 15)


//====================
// Calibration Diagnostics Panel (Debug)
//====================
var table diagTbl = na
if showDiagPanel and na(diagTbl)
    diagTbl := table.new(position.top_right, 2, 18, bgcolor=color.new(color.black, 85), frame_color=color.gray, frame_width=1, border_color=color.gray, border_width=1)

// Helper to get selected TfState
f_get_diag_state() =>
    diagHorizon == "F1" ? tf1State : diagHorizon == "F2" ? tf2State : diagHorizon == "F3" ? tf3State : diagHorizon == "F4" ? tf4State : diagHorizon == "F5" ? tf5State : diagHorizon == "F6" ? tf6State : tf7State

if showDiagPanel and barstate.islast
    st = f_get_diag_state()

    isBullDiag = f_bias_from_score(diagHorizon == "F1" ? outScore1 : diagHorizon == "F2" ? outScore2 : diagHorizon == "F3" ? outScore3 : diagHorizon == "F4" ? outScore4 : diagHorizon == "F5" ? outScore5 : diagHorizon == "F6" ? outScore6 : outScore7) == 1
    
    // Select model arrays
    cntArr = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.cntN_bull : st.cntN_bear) : st.cntN) : (useBullBearCal ? (isBullDiag ? st.cnt1_bull : st.cnt1_bear) : st.cnt1)
    upArr  = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.upN_bull  : st.upN_bear)  : st.upN)  : (useBullBearCal ? (isBullDiag ? st.up1_bull  : st.up1_bear)  : st.up1)
    plattArr = diagModel == "N" ? st.plattN : st.platt1
    brierStats = diagModel == "N" ? st.brierStatsN : st.brierStats1
    llStats = diagModel == "N" ? st.llStatsN : st.llStats1
    
    // Platt params
    plattA = array.get(plattArr, 0)
    plattB = array.get(plattArr, 1)
    
    // Brier/LogLoss
    brierSum = array.get(brierStats, 0)
    brierCnt = array.get(brierStats, 1)
    brierAvg = brierCnt > 0 ? brierSum / brierCnt : na
    
    llSum = array.get(llStats, 0)
    llCnt = array.get(llStats, 1)
    llAvg = llCnt > 0 ? llSum / llCnt : na
    
    // Bin samples (total and per-bin distribution)
    totalSamples = array.sum(cntArr)
    numBins = array.size(cntArr)
    
    // Bin distribution (min/max/avg samples per bin)
    minBin = numBins > 0 ? array.min(cntArr) : 0
    maxBin = numBins > 0 ? array.max(cntArr) : 0
    avgBin = numBins > 0 ? totalSamples / numBins : 0
    
    // Win rate (overall calibrated base rate)
    totalUp = array.sum(upArr)
    baseRate = totalSamples > 0 ? totalUp * 100.0 / totalSamples : 50.0
    
    // Convergence check: Is Platt A stable (should be near 1.0 if well-calibrated)?
    plattStable = (plattA >= 0.7 and plattA <= 1.5) and (plattB >= -0.5 and plattB <= 0.5)
    convStatus = plattStable ? "âœ… Converged" : (plattA < 0.3 or plattA > 3.0) ? "âš ï¸ Unstable" : "ðŸ”„ Adjusting"
    convColor = plattStable ? color.lime : (plattA < 0.3 or plattA > 3.0) ? color.red : color.yellow
    
    // Quality grade
    qualityGrade = na(brierAvg) ? "â€”" : brierAvg < 0.18 ? "A (Excellent)" : brierAvg < 0.22 ? "B (Good)" : brierAvg < 0.25 ? "C (Baseline)" : brierAvg < 0.30 ? "D (Poor)" : "F (No Skill)"
    qualityColor = na(brierAvg) ? color.gray : brierAvg < 0.18 ? color.lime : brierAvg < 0.22 ? color.green : brierAvg < 0.25 ? color.yellow : brierAvg < 0.30 ? color.orange : color.red
    
    // Row 0: Header
    table.cell(diagTbl, 0, 0, "ðŸ”§ Calibration Diagnostics", text_color=color.white, bgcolor=color.new(color.blue, 70), text_size=size.small)
    table.cell(diagTbl, 1, 0, diagHorizon + " / " + diagModel, text_color=color.aqua, bgcolor=color.new(color.blue, 70), text_size=size.small)
    
    // Row 1: Platt A
    table.cell(diagTbl, 0, 1, "Platt A (slope)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 1, str.tostring(plattA, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 2: Platt B
    table.cell(diagTbl, 0, 2, "Platt B (intercept)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 2, str.tostring(plattB, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 3: Convergence status
    table.cell(diagTbl, 0, 3, "SGD Status", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 3, convStatus, text_color=convColor, text_size=size.tiny)
    
    // Row 4: Separator
    table.cell(diagTbl, 0, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 5: Brier Score
    table.cell(diagTbl, 0, 5, "Brier Score", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 5, na(brierAvg) ? "â€”" : str.tostring(brierAvg, "#.####"), text_color=na(brierAvg) ? color.gray : brierAvg < 0.25 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 6: LogLoss
    table.cell(diagTbl, 0, 6, "LogLoss", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 6, na(llAvg) ? "â€”" : str.tostring(llAvg, "#.####"), text_color=na(llAvg) ? color.gray : llAvg < 0.65 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 7: Quality Grade
    table.cell(diagTbl, 0, 7, "Quality Grade", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 7, qualityGrade, text_color=qualityColor, text_size=size.tiny)
    
    // Row 8: Separator
    table.cell(diagTbl, 0, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 9: Total samples
    table.cell(diagTbl, 0, 9, "Total Samples", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 9, str.tostring(totalSamples), text_color=totalSamples >= calMinSamples * numBins ? color.lime : color.yellow, text_size=size.tiny)

//====================
// Calibration Export Alert
//====================
f_get_export_state() =>
    exportHorizon == "F1" ? tf1State : exportHorizon == "F2" ? tf2State : exportHorizon == "F3" ? tf3State : exportHorizon == "F4" ? tf4State : exportHorizon == "F5" ? tf5State : exportHorizon == "F6" ? tf6State : tf7State

if exportCalibration and barstate.isconfirmed and barstate.isrealtime and (bar_index % exportInterval == 0)
    expSt = f_get_export_state()

    pAN = array.get(expSt.plattN, 0)
    pBN = array.get(expSt.plattN, 1)
    pA1 = array.get(expSt.platt1, 0)
    pB1 = array.get(expSt.platt1, 1)

    // Brier/LogLoss stats aligned to evalWhichHead
    useHeadN = evalWhichHead == "N"
    brierStats = useHeadN ? expSt.brierStatsN : expSt.brierStats1
    llStats = useHeadN ? expSt.llStatsN : expSt.llStats1
    cntArr = useHeadN ? expSt.cntN : expSt.cnt1

    brierSumN = array.get(brierStats, 0)
    brierCntN = array.get(brierStats, 1)
    brierAvgN = brierCntN > 0 ? brierSumN / brierCntN : 0

    llSumN = array.get(llStats, 0)
    llCntN = array.get(llStats, 1)
    llAvgN = llCntN > 0 ? llSumN / llCntN : 0

    totalSamplesN = array.sum(cntArr)

    // Build JSON payload (single line to avoid line continuation issues)
    jsonPayload = '{"ticker":"' + syminfo.ticker + '","horizon":"' + exportHorizon + '","bar_index":' + str.tostring(bar_index) + ',"timestamp":"' + str.tostring(timenow) + '","platt_N":{"a":' + str.tostring(pAN, "#.####") + ',"b":' + str.tostring(pBN, "#.####") + '},"platt_1":{"a":' + str.tostring(pA1, "#.####") + ',"b":' + str.tostring(pB1, "#.####") + '},"brier_avg":' + str.tostring(brierAvgN, "#.####") + ',"logloss_avg":' + str.tostring(llAvgN, "#.####") + ',"samples":' + str.tostring(totalSamplesN) + ',"resolutions":' + str.tostring(int(brierCntN)) + '}'

    alert(jsonPayload, alert.freq_once_per_bar)

//====================
// Trend Regime Export Alert (for monitoring)
//====================
// Epsilon 0.0001 prevents division by zero on penny stocks or exotic instruments
atrNormCur = atr / math.max(close, 0.0001)
curTrendRegime = f_trend_regime(emaF, emaS, atrNormCur)
trendLabel = curTrendRegime > 0.5 ? "BULL" : curTrendRegime < -0.5 ? "BEAR" : "SIDEWAYS"
alertcondition(curTrendRegime > 0.5 and curTrendRegime[1] <= 0.5, title="Regime: BULL", message="{{ticker}} entered BULL regime")
alertcondition(curTrendRegime < -0.5 and curTrendRegime[1] >= -0.5, title="Regime: BEAR", message="{{ticker}} entered BEAR regime")
alertcondition(math.abs(curTrendRegime) <= 0.5 and math.abs(curTrendRegime[1]) > 0.5, title="Regime: SIDEWAYS", message="{{ticker}} entered SIDEWAYS regime")

//====================
// Strategy Execution (Backtest Mode)
//====================
if buySignal
    strategy.entry("L", strategy.long, comment="Brier=" + str.tostring(curBrier, "#.##"))
if shortSignal
    strategy.entry("S", strategy.short, comment="Brier=" + str.tostring(curBrier, "#.##"))
if exitSignal
    strategy.close("L")
if coverSignal
    strategy.close("S")

