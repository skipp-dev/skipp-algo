// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6
// SkippALGO Strategy (Deep Upgrade v6.1)
// - Synchronized with Main Indicator v6.1
// - Target Profiles (Fixed, KReturn, KATR, TPorSL)
// - Ensemble Score (Algo + Pullback + Regime)
// - 2D Binning (Score x Volatility)
// - Platt Scaling (SGD Probability Calibration)
strategy("SkippALGO Strategy (Deep Upgrade v6.1)", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_labels_count=500, max_lines_count=500)

//====================
// Inputs â€” Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Hybrid", "Signal engine", options=["Hybrid","Breakout","Trend+Pullback","Loose"])
allowNeuralReversals = input.bool(true, "Allow Neural Reversals (ChoCH)", tooltip="Injects early reversal signals (Bearish/Bullish ChoCH) into the Engine logic. Uncheck to restrict entries to standard Engine triggers (Trend/Breakout) only.")

useForecastGateEntry = input.bool(true, "Entry gate: require forecast edge (3-way)")
entryFcTF    = input.string("F3", "Entry horizon", options=["F1","F2","F3","F4","F5","F6","F7"])
entryFcModel = input.string("N",  "Entry model", options=["N","1"])
minDirProb   = input.float(0.42, "Min dir prob (Up/Down)", minval=0.34, maxval=0.95, step=0.01)
minEdgePP    = input.float(0.10, "Min edge (pp) vs mid", minval=0.00, maxval=0.50, step=0.01)
requireRelOk = input.bool(false, "Entry gate: require bin reliability ok/strong")
requirePathTargetEntry = input.bool(true, "Entry gate: require PathTPvsSL target")
useChopAbstain = input.bool(true, "Chop abstain when Flat high")
flatAbstainThr = input.float(0.55, "Chop abstain: Flat prob â‰¥", minval=0.34, maxval=0.80, step=0.01)

requireSET   = input.bool(true, "Entry gate: require SET (CRSI confluence)")

pbLookback = input.int(12, "Pullback lookback", minval=2)
pbMinATR   = input.float(0.20, "Pullback min depth (ATR)", minval=0.0, step=0.05)
pbMaxATR   = input.float(1.50, "Pullback max depth (ATR)", minval=0.1, step=0.05)

useVolConfirm = input.bool(false, "Volume confirmation")
volLen   = input.int(20, "Volume SMA len", minval=2)
volMult  = input.float(1.20, "Volume mult", minval=0.1, step=0.05)

useAtrRisk = input.bool(true, "ATR Risk Model (Stops/TP/Trail)")
stopATR  = input.float(2.00, "Stop ATR (Initial)", minval=0.1, step=0.10, tooltip="Initial Hard Stop. Wide to survive entry noise.")
tpATR    = input.float(5.00, "Take Profit ATR (Initial)", minval=0.1, step=0.10)
useInfiniteTP = input.bool(false, "Infinite TP (Trailing Stop Only)", tooltip="Disables fixed Take Profit targets. Exits only via Stop Loss or Trailing Stop to capture large spikes.")
trailATR = input.float(2.50, "Trail ATR", minval=0.1, step=0.10)
trailAfterR = input.float(1.50, "Trail activates after R", minval=0.0, step=0.10)

// Breakeven
useBreakeven = input.bool(false, "+BE Trigger", tooltip="Move Stop to Breakeven when price reaches +N ATR profit.")
beTrigger    = input.float(1.5, "Move to BE at (ATR)", minval=0.1, step=0.1)
beOffset     = input.float(0.1, "BE Offset (ATR)", minval=0.0, step=0.05, tooltip="Small buffer above entry to cover fees.")

// Stalemate Exit
useStalemate = input.bool(false, "Stalemate Exit", tooltip="Exit if trade makes no progress after N bars.")
staleBars    = input.int(12, "Stalemate Check (Bars)", minval=1)
staleMinATR  = input.float(0.5, "Min Profit Required (ATR)", minval=0.0, step=0.1)

// Dynamic Risk Decay
useRiskDecay = input.bool(true, "Dynamic Risk Decay (Linear Tightening)", tooltip="Interpolates Stop/TP from Initial to Sustained values over N bars.")
decayStopATR = input.float(1.00, "Sustained Stop ATR", minval=0.1)
decayTpATR   = input.float(3.00, "Sustained TP ATR", minval=0.1)
decayBars    = input.int(6, "Decay Duration (Bars)", minval=1)

exitGraceBars = input.int(3, "Exit Grace Period (Bars)", minval=0, tooltip="Prevents structural exits (trend flips) for the first N bars after entry to avoid immediate wicks/noise.")

swingL = input.int(5, "Breakout swing left", minval=1, maxval=20)
swingR = input.int(3, "Breakout swing right", minval=1, maxval=20)
swingMaxAgeBars = input.int(0, "Breakout swing max age (bars)", minval=0, maxval=2000, tooltip="0 disables expiry of old swings")
breakoutSource = input.string("Close", "Breakout Source", options=["Close", "Wick"], tooltip="Determines if a breakout requires a candle Close or just a Wick cross.")

// Market Structure (BOS / ChoCH)
useStructureTags = input.bool(true, "Show BOS / ChoCH structure tags")
chochMinProb     = input.float(0.50, "ChoCH Min Confidence (Prob)", minval=0.34, maxval=0.95, step=0.01)
chochReqVol      = input.bool(true, "ChoCH Require Volume?")

enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// --- Signal Enhancement Filters ---
grp_sigfilt = "Signal Filters"
// C1 â€“ Pre-signal momentum gate
usePreMomentum = input.bool(false, "Pre-signal momentum gate", group=grp_sigfilt, tooltip="Require RSI alignment with trade direction")
preMomRsiHi    = input.int(65, "Pre-signal RSI high (long)", minval=55, maxval=80, group=grp_sigfilt)
preMomRsiLo    = input.int(35, "Pre-signal RSI low (short)", minval=20, maxval=45, group=grp_sigfilt)
// C3 â€“ EMA acceleration filter
useEmaAccel    = input.bool(false, "EMA acceleration filter", group=grp_sigfilt, tooltip="Check that EMA gap is expanding")
emaAccelLen    = input.int(5, "EMA accel lookback", minval=2, maxval=20, group=grp_sigfilt)
// C4 â€“ VWAP alignment filter
useVwap        = input.bool(false, "VWAP alignment filter", group=grp_sigfilt, tooltip="Long above VWAP, short below (intraday only)")
// D1 â€“ Smooth trend regime
useSmoothTrend = input.bool(false, "Smooth trend regime", group=grp_sigfilt, tooltip="Replace discrete trend with continuous [-1,1]")
// D2 â€“ ADX trend strength
useAdx         = input.bool(false, "ADX trend strength filter", group=grp_sigfilt, tooltip="Require ADX above threshold for trending entries")
adxLen         = input.int(14, "ADX length", minval=5, maxval=50, group=grp_sigfilt)
adxThresh      = input.float(20.0, "ADX min threshold", minval=5.0, maxval=50.0, step=1.0, group=grp_sigfilt)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting (weights are normalised at runtime; defaults sum to 1.10)
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

//====================
// Constants â€” Avoid Magic Numbers
//====================
SEC_5M  = 5 * 60
SEC_15M = 15 * 60
SEC_30M = 30 * 60
SEC_1H  = 60 * 60
SEC_4H  = 4 * 60 * 60

// Volatility regime thresholds
VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

// Statistical constants
Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)
LOGIT_CLAMP     = 20.0    // Clamp for logit to limit extreme values
PRICE_EPS       = 0.0001  // Epsilon for price/ATR divisions

// Rolling buffer recalculation interval (prevent FP drift)
ROLL_RECALC_INTERVAL = 500

// Sideways/choppy market detection thresholds
SIDEWAYS_EMA_THRESH = 0.005   // Max EMA diff ratio for sideways
SIDEWAYS_ATR_THRESH = 0.015   // Max ATR norm for sideways

// Score / trend thresholds
SCORE_NEUTRAL_BAND  = 0.05    // MTF & outSym neutral dead-zone
TREND_SMOOTH_THRESH = 0.3     // Smooth trend strength threshold

// Calibration quality thresholds
HW_STRONG           = 0.05    // CI half-width: strong calibration
HW_OK               = 0.10    // CI half-width: acceptable calibration
ECE_GOOD            = 0.05    // ECE: well-calibrated
ECE_FAIR            = 0.10    // ECE: fair calibration
BRIER_EXCELLENT     = 0.18    // Brier score: A grade
BRIER_GOOD          = 0.22    // Brier score: B grade
BRIER_BASELINE      = 0.25    // Brier score: C grade (random)
BRIER_POOR          = 0.30    // Brier score: D grade

// Platt scaling stability bounds
PLATT_A_LO          = 0.7     // Platt A lower bound (converged)
PLATT_A_HI          = 1.5     // Platt A upper bound (converged)
PLATT_B_BOUND       = 0.5     // Platt B abs bound (converged)
PLATT_A_UNSTABLE_LO = 0.3     // Platt A lower bound (unstable)
PLATT_A_UNSTABLE_HI = 3.0     // Platt A upper bound (unstable)

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels  = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showPreEntryLabels = input.bool(false, "Show PRE labels (PRE-BUY / PRE-SHORT)")
preWarnDistATR     = input.float(0.25, "PRE: proximity threshold (ATR)", minval=0.0, step=0.05, tooltip="Used for pre-warnings (Breakout / Trend+Pullback / Loose)")
preSetPulseOnly    = input.bool(true, "PRE: pulse-only SET", tooltip="When enabled, PRE labels require a fresh SET transition (pulse) instead of a steady SET state")
showSetMarkers   = input.bool(true, "Show SET markers")
setPulseOnly     = input.bool(true, "SET: pulse only", tooltip="When enabled, SET prints only on the transition into a SET state")
showTable        = input.bool(true, "Show Outlook/Forecast table")
ui_tableShowMode       = input.bool(true, "Table: show LIVE/CONFIRMED tag")
tableOnConfirmed = input.bool(true, "Table: update on confirmed bars only")
labelPriceMode    = input.string("Bar Extremes", "Label price", options=["Bar Extremes","Entry Price","Close"])

// Alerts
useAlertCalls       = input.bool(true, "Alerts: use alert() calls", tooltip="Strategy scripts ignore alertcondition(); use alert() instead (recommended ON)")
alertOnBarCloseOnly = input.bool(true,  "Alerts: bar close only")

// Trading Session Time Window
useSessionFilter = input.bool(false, "Session Filter (Time Window)")
sessionWin       = input.session("1530-2200", "Trading Session (Exch Time)", tooltip="Only enters new trades inside this window. Does not force exits.")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

//====================
// Automation Inputs (TradersPost / Webhooks)
//====================
grp_auto   = "Automation"
useJsonAlerts = input.bool(false, "Enable JSON Webhook Payloads", group=grp_auto, tooltip="Formats alerts as JSON for TradersPost or other bots. If disabled, sends human-readable text.")

//====================
// Inputs â€” Forecast Calibration Enhancements (Deep Upgrade v6.1)
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")
allowForecastOnNonFixed = input.bool(false, "Forecast: allow on non-fixed TFs", tooltip="If chart timeframe can't be resolved to seconds, allow forecast gating instead of disabling it")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])
pHdrN = fcDisplay == "Edge pp (N)" ? "Edge(N)" : "Up%(N)"
pHdr1 = fcDisplay == "Edge pp (N)" ? "Edge(1)" : "Up%(1)"
atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)

//====================
// Inputs â€” Forecast 3-way (Up/Flat/Down)
//====================
grp_tri = "Forecast 3-way (Up/Flat/Down)"
use3Way = input.bool(true, "3-way probs: Up/Flat/Down", group=grp_tri)

deadbandFast = input.float(0.15, "Deadband Ã— ATR (Fast <=5m)", minval=0.0, step=0.01, group=grp_tri)
deadbandMid  = input.float(0.10, "Deadband Ã— ATR (Mid <=1h)",  minval=0.0, step=0.01, group=grp_tri)
deadbandSlow = input.float(0.07, "Deadband Ã— ATR (Slow >1h)",  minval=0.0, step=0.01, group=grp_tri)

flatPriorFast = input.float(0.42, "Warmup prior: Flat (Fast)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorMid  = input.float(0.30, "Warmup prior: Flat (Mid)",  step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorSlow = input.float(0.22, "Warmup prior: Flat (Slow)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)

tiltMaxFast = input.float(0.10, "Warmup tilt max (Fast)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxMid  = input.float(0.12, "Warmup tilt max (Mid)",  step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxSlow = input.float(0.15, "Warmup tilt max (Slow)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)

dirMinProb = input.float(0.34, "Direction shown if max prob â‰¥", step=0.01, minval=0.34, maxval=0.90, group=grp_tri)

fcTblModel = input.string("N", "Forecast columns", options=["N","1","Both"], group=grp_tri)

calibratorMode = input.string("Vector", "3-way calibrator", options=["Off","Temp","Vector"], group=grp_tri)
lrCal = input.float(0.01, "Calibrator LR", step=0.001, minval=0.0001, group=grp_tri)
tempMin = input.float(0.5, "Temp min", step=0.1, minval=0.1, group=grp_tri)
tempMax = input.float(5.0, "Temp max", step=0.1, minval=0.5, group=grp_tri)
vecAMin = input.float(0.25, "Vec A min", step=0.05, minval=0.05, group=grp_tri)
vecAMax = input.float(3.0, "Vec A max", step=0.05, minval=0.5, group=grp_tri)
vecBMin = input.float(-2.0, "Vec B min", step=0.1, group=grp_tri)
vecBMax = input.float(2.0, "Vec B max", step=0.1, group=grp_tri)
cal3AutoFallback = input.bool(true, "3-way auto fallback (weak bins)", group=grp_tri)
cal3MinSamples  = input.int(120, "3-way min samples for calibrator", minval=10, maxval=5000, group=grp_tri)
calRegStrength  = input.float(0.002, "Calibrator stabilize strength", minval=0.0, step=0.001, group=grp_tri)
useBullBearCal = input.bool(true, "Separate bull/bear calibrators", group=grp_tri)
countDecay = input.float(0.9995, "Count decay (1.0=none)", minval=0.80, maxval=1.0, step=0.0005, group=grp_tri)
kShrinkReg = input.int(20, "Regime shrinkage k", minval=0, maxval=1000, group=grp_tri)

//====================
// Liquidity Concepts (SMC)
//====================
grp_smc = "Liquidity Concepts (SMC)"
useLiqSweep     = input.bool(true, "Filter Reversals by Liquidity Sweep", group=grp_smc, tooltip="Only take Reversal entries if a Liquidity Sweep (stop hunt) occurred recently.")
liqSweepLookback= input.int(10, "Sweep Lookback (Bars)", minval=1, group=grp_smc)
// useLiqTargets   = input.bool(false, "Avg Entry Targets (Future)", group=grp_smc) // Reserved for Phase 2

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", minval=0.01, step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", minval=0.01, step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", minval=0.01, step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", minval=0.01, step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpATRM    = input.float(0.80, "Path TP", minval=0.01, step=0.05, group=grp_mid)
slATRM    = input.float(1.00, "Path SL", minval=0.01, step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", minval=0.01, step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.00, "Path TP", minval=0.01, step=0.05, group=grp_slow)
slATRS    = input.float(1.00, "Path SL", minval=0.01, step=0.05, group=grp_slow)

// Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"], group="Policy")
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"], group="Policy")

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", minval=0.0, step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", minval=0.0, step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", minval=0.0, step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", minval=0.0, step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")
// B2 â€“ ROC factor in ensemble
wRoc      = input.float(0.0, "Weight: ROC factor", minval=0.0, step=0.1, group=grp_ens, tooltip="Rate of Change momentum (0=off)")
rocLen    = input.int(10, "ROC length", minval=2, maxval=50, group=grp_ens)
// B4 â€“ Volume in ensemble
wVol      = input.float(0.0, "Weight: Volume factor", minval=0.0, step=0.1, group=grp_ens, tooltip="Volume vs SMA ratio (0=off)")
volEnsLen = input.int(20, "Volume ensemble SMA len", minval=2, maxval=100, group=grp_ens)

// --- Phase 4: Online Calibration ---
grp_cal = "Calibration Settings (Phase 4)"
usePlatt = input.bool(true, "Use Platt Scaling (Online SGD)", group=grp_cal)
lrPlatt  = input.float(0.005, "Learning Rate (SGD)", minval=0.001, maxval=0.1, step=0.001, group=grp_cal)
// A2 â€“ SGD Momentum (Adam-lite)
useSgdMomentum = input.bool(false, "SGD momentum (Adam-lite)", group=grp_cal, tooltip="EMA of gradients for smoother convergence")
sgdBeta        = input.float(0.9, "SGD momentum beta", minval=0.5, maxval=0.99, step=0.01, group=grp_cal)

// Bins & Smoothing
predBinsN = input.int(4, "Pred bins (N) stable", minval=2, maxval=9, group="Engine")
predBins1 = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3, group="Engine")
dim2Bins  = 3 // Trend regime bins (bear/sideways/bull)

// Quantile binning (score dimension)
useQuantileBins = input.bool(true, "Use quantile bins (score)", group="Engine")
quantileWindow = input.int(500, "Quantile window (samples)", minval=100, maxval=5000, group="Engine")
quantileUpdate = input.int(25, "Quantile update interval (bars)", minval=10, maxval=1000, group="Engine")
quantileMinSamples = input.int(200, "Quantile min samples", minval=50, maxval=5000, group="Engine")
calibrateInBackground = input.bool(true, "Calibrate even if table hidden")

alphaN = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1, group="Engine")
alpha1 = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1, group="Engine")
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000, tooltip="Higher = pull bin probability closer to global TF average", group="Engine")

calMinSamples = input.int(40, "Min samples per bin (activate)", minval=5, maxval=1000, group="Engine")

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01, group="Signals")
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01, group="Signals")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7","ChartTF"], group="Maintenance")
resetNow   = input.bool(false, "Reset selected calibration NOW", group="Maintenance")


//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F3", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")
relFilterModel = input.string("N", "Filter Model", options=["N", "1"], tooltip="N=Multi-factor, 1=Single-factor")

// Evidence / coverage gating
evidenceGate = input.bool(false, "Evidence gate (block weak bins)")
evidenceMinTotal = input.int(120, "Evidence min total samples", minval=1, maxval=10000)
abstainGate = input.bool(true, "Abstain on weak decisions")
abstainMinEdge = input.float(0.08, "Abstain min edge (pp)", minval=0.0, maxval=0.50, step=0.01)

// Trade-gate thresholds (separate from calibration thresholds)
tradeMinBinSamples   = input.int(10, "Trade gate: min BIN samples", minval=0, maxval=200)
tradeMinTotalSamples = input.int(0,  "Trade gate: min TOTAL samples (0=off)", minval=0, maxval=20000)
rescueVolMult = input.float(1.5, "Rescue Mode: Min Volume (xSMA)", minval=1.0, maxval=50.0, step=0.1, tooltip="Volume ratio required to trigger Rescue Mode (bypasses gates).")
rescueImpulseATR = input.float(0.7, "Rescue Mode: Min Impulse (xATR)", minval=0.1, step=0.1, tooltip="Minimum candle body size (in ATR) to validate a Rescue Reversal.")


//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ConfErr/Drift)")
evalWhichHead   = input.string("N", "Evaluate head", options=["N","1"])  // N=stable bins, 1=reactive bins

evalInBackground = input.bool(true, "Eval in background (when Eval section hidden)")

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"])

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

evalBucketCount = use3Way ? evalBuckets * 3 : evalBuckets

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)
useEceGate      = input.bool(false, "Gate entries by ECE")
eceMax          = input.float(0.10, "Max ECE (gate)", minval=0.01, maxval=0.50, step=0.01)
useDriftGate    = input.bool(false, "Gate entries by drift")
driftMaxPP      = input.float(12.0, "Max drift (pp, gate)", minval=1.0, maxval=50.0, step=0.5)
useEvalPenalty  = input.bool(true, "Soft penalty on eval degrade")
eceWarn         = input.float(0.08, "ECE warn threshold", minval=0.01, maxval=0.50, step=0.01)
evalPenalty     = input.float(0.10, "Eval penalty (confidence)", minval=0.0, maxval=0.50, step=0.01)
// A5 â€“ ECE-triggered recalibration
useEceRecal     = input.bool(false, "ECE-triggered recal (boost LR)", tooltip="Temporarily boost Platt LR when ECE exceeds warn")
eceRecalBoost   = input.float(3.0, "ECE recal LR multiplier", minval=1.5, maxval=10.0, step=0.5)

//====================
// Inputs â€” Calibration Diagnostics (Debug Panel)
//====================
grp_diag = "ðŸ”§ Calibration Diagnostics"
showDiagPanel   = input.bool(false, "Show Calibration Debug Panel", group=grp_diag, tooltip="Displays Platt params, convergence, bin samples")
diagHorizon     = input.string("F1", "Diagnostic Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_diag)
diagModel       = input.string("N", "Diagnostic Model", options=["N","1"], group=grp_diag, tooltip="N=Multi-factor, 1=Single-factor")

//====================
// Inputs â€” Calibration Export (Webhook)
//====================
grp_export = "ðŸ“¤ Calibration Export"
exportCalibration = input.bool(false, "Enable Calibration Export Alert", group=grp_export, tooltip="Fires alert with JSON calibration state")
exportInterval    = input.int(100, "Export Every N Bars", minval=10, maxval=1000, group=grp_export)
exportHorizon     = input.string("F1", "Export Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_export)

//====================
// Inputs â€” Exit Filters
//====================
grp_exit = "Exit Filters (Confidence)"
exitConfChoCh = input.float(0.0, "Confirm ChoCh (Min Prob)", minval=0.0, maxval=1.0, step=0.05, group=grp_exit, tooltip="Only exit LONG positions on Bearish ChoCh if the reversal probability (pD) is above this level. Bullish ChoCh exits are not filtered.")
exitConfTP    = input.float(1.0, "Hold TP (Min Trend Conf)", minval=0.0, maxval=1.0, step=0.05, group=grp_exit, tooltip="Ignore TP levels allows winning trades to run if confidence remains above this level (1.0 = off).")

//====================
// Calibration storage â€” TfState UDT (replaces 100+ global arrays)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    float[] cntN
    float[] upN
    float[] dnN
    float[] cnt1
    float[] up1
    float[] dn1
    float[] cntN_bull
    float[] upN_bull
    float[] dnN_bull
    float[] cntN_bear
    float[] upN_bear
    float[] dnN_bear
    float[] cnt1_bull
    float[] up1_bull
    float[] dn1_bull
    float[] cnt1_bear
    float[] up1_bear
    float[] dn1_bear
    // Queues
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    int[]   qBias
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    float[] qPUpN
    float[] qPFlN
    float[] qPDnN
    float[] qPUp1
    float[] qPFl1
    float[] qPDn1
    float[] qZUpN
    float[] qZFlN
    float[] qZDnN
    float[] qZUp1
    float[] qZFl1
    float[] qZDn1
    // Stats
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    float[] tempN
    float[] temp1
    float[] vecAN
    float[] vecBN
    float[] vecA1
    float[] vecB1
    float[] tempN_bull
    float[] temp1_bull
    float[] vecAN_bull
    float[] vecBN_bull
    float[] vecA1_bull
    float[] vecB1_bull
    float[] tempN_bear
    float[] temp1_bear
    float[] vecAN_bear
    float[] vecBN_bear
    float[] vecA1_bear
    float[] vecB1_bear
    // Evaluation N
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    // Evaluation 1
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1
    // Raw (non-decayed) counts for CI/coverage
    float[] cntN_raw
    float[] upN_raw
    float[] dnN_raw
    float[] cnt1_raw
    float[] up1_raw
    float[] dn1_raw
    float[] cntN_bull_raw
    float[] upN_bull_raw
    float[] dnN_bull_raw
    float[] cntN_bear_raw
    float[] upN_bear_raw
    float[] dnN_bear_raw
    float[] cnt1_bull_raw
    float[] up1_bull_raw
    float[] dn1_bull_raw
    float[] cnt1_bear_raw
    float[] up1_bear_raw
    float[] dn1_bear_raw
    // A2 â€“ SGD Momentum buffers (Adam-lite)
    float[] momPlattN  // [mom_a, mom_b]
    float[] momPlatt1  // [mom_a, mom_b]
    // Quantile bins (per horizon)
    float[] qScoreBuf
    float[] qCutsN
    float[] qCuts1

// Helper to initialize TfState
// Arguments map 1-to-1 to UDT fields in declaration order.
// Section comments below match the UDT groupings.
f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
        // --- Decayed count grids: cntN/upN/dnN, cnt1/up1/dn1 ---
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        // --- Bull/bear count grids ---
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        // --- Rolling history buffers ---
            array.new_int(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
            array.new_int(),
        // --- Temperature / ensemble vectors ---
            array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
        // --- Platt scaling: brierStats, llStats, platt params ---
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.from(1.0, 0.0), array.from(1.0, 0.0),
    array.from(1.0), array.from(1.0),
        // --- Bull/bear Platt params ---
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0), array.from(1.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0), array.from(1.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
      // Eval N
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float(),
      // Eval 1
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
    array.new_int(), array.new_float(), array.new_float(),
    // Raw (non-decayed) counts
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        // --- A2: SGD momentum buffers ---
    array.new_float(2, 0.0), array.new_float(2, 0.0),
        // --- Quantile buffers ---
    array.new_float(), array.new_float(int(math.max(nBinsN - 1, 0)), na), array.new_float(int(math.max(nBins1 - 1, 0)), na)
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)

//====================
// Table colors (navy + soft-blue frame)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

//====================
// Helpers
//====================
// --- Sum int array (total resolved samples across all bins)
f_sum_int_array(a) =>
    float s = 0.0
    for i = 0 to array.size(a) - 1
        s += array.get(a, i)
    s

// --- Safe array removal helpers
f_safe_remove_float(float[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

f_safe_remove_int(int[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

// --- Safe array access helpers
f_safe_get_float(float[] arr, int idx, float fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

f_safe_get_int(int[] arr, int idx, int fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

// --- TF selector helpers (avoid long ternary chains)
// Pine Script lacks generics, so one copy per return type is required.
f_sel_tf_str(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

f_sel_tf_float(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

f_sel_tf_bool(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

f_sel_tf_farr(tfSel, v1, v2, v3, v4, v5, v6, v7) =>
    tfSel == "F1" ? v1 : tfSel == "F2" ? v2 : tfSel == "F3" ? v3 : tfSel == "F4" ? v4 : tfSel == "F5" ? v5 : tfSel == "F6" ? v6 : v7

// --- Update quantile cutpoints (score dimension)
f_fill_cuts(sorted, cuts, bins) =>
    cutCount = bins - 1
    if cutCount > 0
        n = array.size(sorted)
        for i = 0 to cutCount - 1
            frac = (i + 1.0) / bins
            idx = int(math.floor(frac * (n - 1)))
            array.set(cuts, i, array.get(sorted, idx))

// Forecast binning (fallback: fixed width)
f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = int(math.floor(u * bins))
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b

// Quantile cutpoints are recalculated every `quantileUpdate` bars once
// `quantileMinSamples` scores have been collected. Until then, uniform
// (equal-width) binning is used as the warm-up fallback.
f_update_quantiles(TfState st, score) =>
    if useQuantileBins and (calibrateInBackground or showTable or showEvalSection)
        array.push(st.qScoreBuf, score)
        if array.size(st.qScoreBuf) > quantileWindow
            array.shift(st.qScoreBuf)
        if bar_index % quantileUpdate == 0 and array.size(st.qScoreBuf) >= quantileMinSamples
            tmp = array.copy(st.qScoreBuf)
            array.sort(tmp, order.ascending)
            f_fill_cuts(tmp, st.qCutsN, predBinsN)
            f_fill_cuts(tmp, st.qCuts1, predBins1)

f_bin_quantile(score, cuts, bins) =>
    if (not useQuantileBins) or array.size(cuts) == 0 or na(array.get(cuts, 0))
        f_bin(score, bins)
    else
        b = 0
        for i = 0 to array.size(cuts) - 1
            if score <= array.get(cuts, i)
                b := i
                break
            else
                b := i + 1
        math.max(0, math.min(bins - 1, b))

f_regime_bin(trendScore) =>
    trendScore > 0.5 ? 2 : trendScore < -0.5 ? 0 : 1

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

// @function Clamp value to arbitrary [lo, hi] range
// @param val Value to clamp
// @param lo Minimum bound
// @param hi Maximum bound
// @returns Clamped value
f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_min_sec(a, b) =>
    na(a) ? b : na(b) ? a : math.min(a, b)

f_forecast_allowed() =>
    baseSec = timeframe.in_seconds(timeframe.period)
    s1 = timeframe.in_seconds(tfF1)
    s2 = timeframe.in_seconds(tfF2)
    s3 = timeframe.in_seconds(tfF3)
    s4 = timeframe.in_seconds(tfF4)
    s5 = timeframe.in_seconds(tfF5)
    s6 = timeframe.in_seconds(tfF6)
    s7 = timeframe.in_seconds(tfF7)
    minSec = f_min_sec(s1, f_min_sec(s2, f_min_sec(s3, f_min_sec(s4, f_min_sec(s5, f_min_sec(s6, s7))))))
    if na(baseSec) or na(minSec)
        allowForecastOnNonFixed
    else
        baseSec <= minSec

f_tf_from_horizon(h) =>
    if h == "F1"
        tfF1
    else if h == "F2"
        tfF2
    else if h == "F3"
        tfF3
    else if h == "F4"
        tfF4
    else if h == "F5"
        tfF5
    else if h == "F6"
        tfF6
    else
        tfF7

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" : tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  : tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "â€”" : v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") : v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") : v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") : str.tostring(v, "#")

f_chance_word() =>
    anyWin = fcTargetF == "PathTPvsSL" or fcTargetM == "PathTPvsSL" or fcTargetS == "PathTPvsSL"
    anyWin ? "Win" : "Up"

// Map a TF into your "Fast/Mid/Slow" profiles.
f_profile(tf) =>
    s = timeframe.in_seconds(tf)
    not na(s) and s <= SEC_5M ? "Fast" : not na(s) and s <= SEC_1H ? "Mid" : "Slow"

// Pick which target is active for that TF profile.
f_target_for_tf(tf) =>
    prof = f_profile(tf)
    prof == "Fast" ? fcTargetF : prof == "Mid" ? fcTargetM : fcTargetS

// Short, human label for the target (what "Win" means on that row)
f_target_label(tf) =>
    t = f_target_for_tf(tf)
    t == "NextBar" ? "Next-up" : t == "KBarReturn" ? "Up-close" : t == "KBarATR" ? "ATR-hit" : t == "PathTPvsSL" ? "TP-first" : "Win"

// Uncertainty band in percentage points using a binomial approx (â‰ˆ95% band).
f_unc_pp(p, n) =>
    n <= 0 ? na : Z_95 * math.sqrt(math.max(p * (1.0 - p), 0.0) / n) * 100.0

// Sample-strength label derived from CURRENT BIN sample size (nBin).
f_strength_label_fc(nBin) =>
    nBin < calMinSamples ? "weak" : nBin < calMinSamples * 4 ? "ok" : "strong"

// Format probability range text like "34â€“46%" (bounded to 0..100)
f_prob_range_text(p, nBin) =>
    if nBin < calMinSamples or nBin <= 0
        "build n" + str.tostring(nBin)
    else
        band = f_unc_pp(p, nBin) / 100.0
        lo = math.max(0.0, p - band)
        hi = math.min(1.0, p + band)
        str.tostring(lo * 100.0, "#.0") + "â€“" + str.tostring(hi * 100.0, "#.0") + "%"

// Full target description for footer (per profile)
f_target_profile_desc(profile) =>
    t = profile == "Fast" ? fcTargetF : profile == "Mid" ? fcTargetM : fcTargetS
    k = profile == "Fast" ? kBarsF    : profile == "Mid" ? kBarsM    : kBarsS
    a = profile == "Fast" ? atrThrF   : profile == "Mid" ? atrThrM   : atrThrS
    h = profile == "Fast" ? pathHF    : profile == "Mid" ? pathHM    : pathHS
    tp = profile == "Fast" ? tpATRF   : profile == "Mid" ? tpATRM    : tpATRS
    sl = profile == "Fast" ? slATRF   : profile == "Mid" ? slATRM    : slATRS
    t == "NextBar" ? "NextBar" :
     t == "KBarReturn" ? "K" + str.tostring(k) :
     t == "KBarATR" ? "K" + str.tostring(k) + " " + str.tostring(a, "#.#") + "A" :
     t == "PathTPvsSL" ? "P" + str.tostring(h) + " " + str.tostring(tp, "#.#") + "/" + str.tostring(sl, "#.#") :
     "Target"

f_target_footer_text() =>
    "F=" + f_target_profile_desc("Fast") + " M=" + f_target_profile_desc("Mid") + " S=" + f_target_profile_desc("Slow")

f_ci95_halfwidth(p, n) =>
    if na(p) or na(n) or n <= 0
        na
    else
        z2 = Z_95 * Z_95
        den = 1.0 + z2 / n
        half = (Z_95 * math.sqrt((p * (1.0 - p) / n) + (z2 / (4.0 * n * n)))) / den
        half

f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= HW_STRONG ? "strong" : hw <= HW_OK ? "ok" : "weak"
    lbl

// D1 â€“ Continuous trend strength [-1, 1] (smooth alternative to discrete f_trend_regime)
f_trend_strength(emaF, emaS) =>
    emaDiff = (emaF - emaS) / math.max(nz(emaS, 1), PRICE_EPS)
    math.max(-1.0, math.min(1.0, emaDiff / math.max(SIDEWAYS_EMA_THRESH, PRICE_EPS)))

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    // B1 â€“ Continuous trend: smooth EMA gap vs binary
    trend = useSmoothTrend ? f_trend_strength(emaF_tf, emaS_tf) : (emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0)
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = (not na(sec)) and sec <= SEC_5M // <= 5m
    isMid  = (not na(sec)) and sec <= SEC_1H // <= 1h
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     isFast ? tpATRF    : isMid ? tpATRM    : tpATRS, 
     isFast ? slATRF    : isMid ? slATRM    : slATRS]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    // Clamp output to prevent extreme values
    math.max(-LOGIT_CLAMP, math.min(LOGIT_CLAMP, math.log(pc / (1.0 - pc))))

f_sigmoid(x) =>
    // Prevent overflow for extreme x values
    x < -500 ? 0.0 : x > 500 ? 1.0 : 1.0 / (1.0 + math.exp(-x))

f_platt_prob(pRaw, a, b) =>
    usePlatt ? f_sigmoid(a * f_logit(pRaw) + b) : pRaw

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Bias -1 (Bear): mirror logic; Bias 0 (neutral): return 0
    bias == 1 ? (c > ef ? 0.5 : c > es ? 1.0 : -1.0) : bias == -1 ? (c < ef ? 0.5 : c < es ? 1.0 : -1.0) : 0.0

// @function Computes trend regime score (bull/bear/sideways)
// @param emaF Fast EMA value
// @param emaS Slow EMA value
// @param atrNorm ATR normalized by close (for sideways detection)
// @returns Score in [-1, 1]: +1=bull, -1=bear, 0=sideways/choppy
f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / math.max(nz(emaS, 1), PRICE_EPS)
    // Strong trend: EMAs diverging significantly (>0.5% gap)
    // Sideways: EMAs close together AND low volatility
    isSideways = math.abs(emaDiff) < SIDEWAYS_EMA_THRESH and atrNorm < SIDEWAYS_ATR_THRESH
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

f_ensemble(sA, sB, sC, wA, wB, wC) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Regime Score (-1..1)
    num = wA * sA + wB * sB + wC * sC
    den = wA + wB + wC
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Vol Regime Score (-1..1)
    // sD: Trend Regime Score (-1..1): bull/bear/sideways
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// B2 â€“ ROC (Rate of Change) score: momentum via price change [-1, 1]
f_roc_score(c, rocL) =>
    roc = ta.roc(c, rocL)
    r = na(roc) ? 0.0 : roc
    // Normalise: Â±5% => Â±1
    math.max(-1.0, math.min(1.0, r / 5.0))

// B4 â€“ Volume score: above/below SMA [-1, 1]
f_vol_score(vol, volSmaLen) =>
    if na(vol) or vol == 0
        0.0
    else
        sma = ta.sma(vol, volSmaLen)
        ratio = na(sma) or sma == 0.0 ? 0.0 : (vol / sma - 1.0)
        math.max(-1.0, math.min(1.0, ratio))

// Extended ensemble with 6 factors (state + pullback + vol regime + trend + ROC + volume)
f_ensemble6(sA, sB, sC, sD, sE, sF, wA, wB, wC, wD, wE, wF) =>
    num = wA * sA + wB * sB + wC * sC + wD * sD + wE * sE + wF * sF
    den = wA + wB + wC + wD + wE + wF
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// --- Phase 2 Helpers: 2D Binning ---
// @function Computes 2D bin index from score and trend regime
// @param score Ensemble score in [-1, 1]
// @param trendScore Trend regime score in [-1, 1]
// @param binsScore Number of bins for score dimension
// @param binsReg Number of bins for regime dimension (typically 3)
// @param cutsArr Quantile cutpoints for score dimension
// @returns Flattened bin index
f_bin2D(score, trendScore, binsScore, binsReg, cutsArr) =>
    bS = f_bin_quantile(score, cutsArr, binsScore)
    bR = f_regime_bin(trendScore)
    idx = int(bS * binsReg + bR)
    maxIdx = binsScore * binsReg - 1
    idx < 0 ? 0 : idx > maxIdx ? maxIdx : idx

f_db_mult(tf) =>
    sec = timeframe.in_seconds(tf)
    na(sec) ? deadbandSlow : sec <= SEC_5M ? deadbandFast : sec <= SEC_1H ? deadbandMid : deadbandSlow

f_outcome3(delta, db) =>
    delta > db ? 1 : delta < -db ? -1 : 0

f_bias_from_score(score) =>
    score > 0 ? 1 : score < 0 ? -1 : 0

f_is_bull_bias(score, emaF_tf, emaS_tf) =>
    b = f_bias_from_score(score)
    b == 0 ? (emaF_tf >= emaS_tf) : b == 1

f_decay_counts(cntArr, upArr, dnArr, decay) =>
    if decay < 0.9999
        for i = 0 to array.size(cntArr) - 1
            array.set(cntArr, i, array.get(cntArr, i) * decay)
            array.set(upArr,  i, array.get(upArr,  i) * decay)
            array.set(dnArr,  i, array.get(dnArr,  i) * decay)

f_cal_update3(cntArr, upArr, dnArr, bin, outcome) =>
    if na(bin) or array.size(cntArr) == 0
        na
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
        n0 = array.get(cntArr, b)
        u0 = array.get(upArr,  b)
        d0 = array.get(dnArr,  b)
        array.set(cntArr, b, n0 + 1.0)
        array.set(upArr,  b, u0 + (outcome == 1 ? 1.0 : 0.0))
        array.set(dnArr,  b, d0 + (outcome == -1 ? 1.0 : 0.0))

f_prob3(u, f, d, n, alpha) =>
    denom = n + 3.0 * alpha
    if denom == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [(u + alpha) / denom, (f + alpha) / denom, (d + alpha) / denom]

f_cal_cur3(cntArr, upArr, dnArr, bin, alpha, shrinkK, shrinkReg) =>
    if na(bin) or array.size(cntArr) == 0
        [float(na), float(na), float(na), float(na)]
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b

        n = array.get(cntArr, b)
        u = array.get(upArr,  b)
        d = array.get(dnArr,  b)
        f = math.max(0, n - u - d)

        [pUb_t, pFb_t, pDb_t] = f_prob3(u, f, d, n, alpha)
        pUb = pUb_t
        pFb = pFb_t
        pDb = pDb_t

        regBin = b % dim2Bins
        binsScore = int(array.size(cntArr) / dim2Bins)
        nReg = 0.0
        uReg = 0.0
        dReg = 0.0
        for i = 0 to binsScore - 1
            idx = i * dim2Bins + regBin
            nReg += array.get(cntArr, idx)
            uReg += array.get(upArr,  idx)
            dReg += array.get(dnArr,  idx)
        fReg = math.max(0, nReg - uReg - dReg)
        [pUr_t, pFr_t, pDr_t] = f_prob3(uReg, fReg, dReg, nReg, alpha)
        pUr = pUr_t
        pFr = pFr_t
        pDr = pDr_t

        nBase = array.sum(cntArr)
        uBase = array.sum(upArr)
        dBase = array.sum(dnArr)
        fBase = math.max(0, nBase - uBase - dBase)
        [pU0_t, pF0_t, pD0_t] = f_prob3(uBase, fBase, dBase, nBase, alpha)
        pU0 = pU0_t
        pF0 = pF0_t
        pD0 = pD0_t

        wReg = (shrinkReg <= 0) ? 1.0 : (n / (n + shrinkReg + 0.0))
        pUreg = wReg * pUb + (1.0 - wReg) * pUr
        pFreg = wReg * pFb + (1.0 - wReg) * pFr
        pDreg = wReg * pDb + (1.0 - wReg) * pDr

        w = (shrinkK <= 0) ? 1.0 : (nReg / (nReg + shrinkK + 0.0))
        pU = w * pUreg + (1.0 - w) * pU0
        pF = w * pFreg + (1.0 - w) * pF0
        pD = w * pDreg + (1.0 - w) * pD0

        s = pU + pF + pD
        if s == 0.0
            [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, n]
        else
            [pU / s, pF / s, pD / s, n]

f_safe_log(p) =>
    math.log(math.max(PROB_EPS, p))

f_softmax3(zU, zF, zD) =>
    zMax = math.max(zU, math.max(zF, zD))
    eU = math.exp(zU - zMax)
    eF = math.exp(zF - zMax)
    eD = math.exp(zD - zMax)
    s = eU + eF + eD
    if s == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [eU / s, eF / s, eD / s]

f_can_cal3(nBin) =>
    calibratorMode != "Off" and (not cal3AutoFallback or nBin >= cal3MinSamples)

f_cal_apply(zU, zF, zD, tempArr, aArr, bArr) =>
    zUo = zU
    zFo = zF
    zDo = zD
    if calibratorMode == "Temp"
        t = array.get(tempArr, 0)
        t := t <= 0.0 ? 1.0 : t
        zUo := zU / t
        zFo := zF / t
        zDo := zD / t
    else if calibratorMode == "Vector"
        aU = array.get(aArr, 0)
        aF = array.get(aArr, 1)
        aD = array.get(aArr, 2)
        bU = array.get(bArr, 0)
        bF = array.get(bArr, 1)
        bD = array.get(bArr, 2)
        zUo := aU * zU + bU
        zFo := aF * zF + bF
        zDo := aD * zD + bD
    f_softmax3(zUo, zFo, zDo)

f_epsClamp(p) =>
    eps = PROB_EPS
    math.max(eps, math.min(1.0 - eps, p))

f_brier3(pU, pF, pD, outcome) =>
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0
    ((pU - yU) * (pU - yU) + (pF - yF) * (pF - yF) + (pD - yD) * (pD - yD)) / 3.0

f_logloss3(pU, pF, pD, outcome) =>
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD
    -math.log(f_epsClamp(pTrue))

f_prior3(tf, outScore) =>
    sec = timeframe.in_seconds(tf)
    isFast = (not na(sec)) and sec <= SEC_5M
    isMid  = (not na(sec)) and sec <= SEC_1H
    baseFlat = isFast ? flatPriorFast : isMid ? flatPriorMid : flatPriorSlow
    tiltMax  = isFast ? tiltMaxFast  : isMid ? tiltMaxMid  : tiltMaxSlow

    baseSide = (1.0 - baseFlat) * 0.5
    tilt = f_clamp(outScore, -1.0, 1.0) * tiltMax

    pU = f_clamp(baseSide + tilt, 0.0, 1.0)
    pD = f_clamp(baseSide - tilt, 0.0, 1.0)
    pF = f_clamp(baseFlat, 0.0, 1.0)

    s = pU + pF + pD
    if s == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [pU / s, pF / s, pD / s]

f_blend_prior(pU, pF, pD, pUpr, pFpr, pDpr, nRaw) =>
    eff = na(nRaw) ? 0.0 : nRaw
    w = calMinSamples <= 0 ? 1.0 : math.min(1.0, math.max(0.0, eff / calMinSamples))
    [pU * w + pUpr * (1.0 - w),
     pF * w + pFpr * (1.0 - w),
     pD * w + pDpr * (1.0 - w)]

f_samp_label(enabled, total) =>
    not enabled ? "off" : total < calMinSamples ? "â€¦" : total < calMinSamples * 3 ? "ok" : "strong"

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

f_tf_pack(tf) =>
    [t, c, h, l, ef, es, r, a, vr] = request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(ta.atr(atrLen) / math.max(close, PRICE_EPS), volRankLen)],
        barmerge.gaps_off,
        barmerge.lookahead_off
    )
    // NOTE: barstate.isconfirmed moved outside request.security() to avoid
    //       TradingView repainting warning that blocks alert creation.
    [t, c, h, l, ef, es, r, a, vr, barstate.isconfirmed]

f_score_tf(c, ef, es, r) =>
    f_state_score(c, ef, es, r)

// @function Computes Laplace-smoothed probability with division safety
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter (default typically 1.0)
// @returns Probability in (0, 1), defaults to 0.5 if denominator is zero
f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_update(cntArr, upArr, bin, isUp) =>
    if na(bin) or array.size(cntArr) == 0
        na
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
        n0 = array.get(cntArr, b)
        u0 = array.get(upArr,  b)
        array.set(cntArr, b, n0 + 1.0)
        array.set(upArr,  b, u0 + (isUp ? 1.0 : 0.0))

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Bin raw
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "â€”" : n < calMinSamples ? "â€¦" : pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) : n < calMinSamples ? color.new(color.white, 60) : pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_pupText(pUp, n, canCal) =>
    not canCal ? "OFF" : n == 0 ? "â€”" : n < calMinSamples ? "Warm " + str.tostring(n) + "/" + str.tostring(calMinSamples) : fcDisplay == "Edge pp (N)" ? ((pUp - 0.5) * 100.0 > 0 ? "+" + str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")" : str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")") : "Up " + str.tostring(pUp * 100.0, "#.0") + "% (" + str.tostring(n) + ")"

f_brier(p, y) =>
    d = p - y
    d * d

f_logloss(p, y) =>
    pc = f_epsClamp(p)
    -(y * math.log(pc) + (1.0 - y) * math.log(1.0 - pc))

f_roll_add(buf, sumArr, v, maxLen) =>
    array.push(buf, v)
    array.set(sumArr, 0, array.get(sumArr, 0) + v)
    if array.size(buf) > maxLen
        old = array.shift(buf)
        array.set(sumArr, 0, array.get(sumArr, 0) - old)
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(buf) > 0
        array.set(sumArr, 0, array.sum(buf))

// @function Reset single-element sum arrays safely
// @param sumArr Single-element array holding running sum
f_reset_sum1(sumArr) =>
    if array.size(sumArr) == 0
        array.push(sumArr, 0.0)
    else
        array.set(sumArr, 0, 0.0)

f_bucket(p, B) =>
    b = int(math.floor(p * B))
    b < 0 ? 0 : b > (B - 1) ? (B - 1) : b

f_cal_roll_update(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, p, y, maxLen) =>
    B = array.size(calCnt)
    bi = f_bucket(p, B)

    array.push(bBuf, bi)
    array.push(pBuf, p)
    array.push(yBuf, y)

    array.set(calCnt,  bi, array.get(calCnt,  bi) + 1)
    array.set(calSumP, bi, array.get(calSumP, bi) + p)
    array.set(calSumY, bi, array.get(calSumY, bi) + y)

    if array.size(bBuf) > maxLen
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_cal_roll_update3(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, pU, pF, pD, outcome, maxLen) =>
    B = evalBuckets
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0

    biU = f_bucket(pU, B)
    biF = f_bucket(pF, B)
    biD = f_bucket(pD, B)

    idxU = 0 * B + biU
    idxF = 1 * B + biF
    idxD = 2 * B + biD

    array.push(bBuf, idxU), array.push(pBuf, pU), array.push(yBuf, yU)
    array.push(bBuf, idxF), array.push(pBuf, pF), array.push(yBuf, yF)
    array.push(bBuf, idxD), array.push(pBuf, pD), array.push(yBuf, yD)

    array.set(calCnt,  idxU, array.get(calCnt,  idxU) + 1)
    array.set(calSumP, idxU, array.get(calSumP, idxU) + pU)
    array.set(calSumY, idxU, array.get(calSumY, idxU) + yU)

    array.set(calCnt,  idxF, array.get(calCnt,  idxF) + 1)
    array.set(calSumP, idxF, array.get(calSumP, idxF) + pF)
    array.set(calSumY, idxF, array.get(calSumY, idxF) + yF)

    array.set(calCnt,  idxD, array.get(calCnt,  idxD) + 1)
    array.set(calSumP, idxD, array.get(calSumP, idxD) + pD)
    array.set(calSumY, idxD, array.get(calSumY, idxD) + yD)

    maxLen3 = maxLen * 3
    while array.size(bBuf) > maxLen3
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_eval_stats_one(brierBuf, sumBrier, logBuf, sumLog, ySBuf, sumYS, yLBuf, sumYL, calCnt, calSumP, calSumY) =>
    nScore = array.size(brierBuf)
    brierAvg = nScore == 0 ? na : array.get(sumBrier, 0) / nScore
    logAvg   = nScore == 0 ? na : array.get(sumLog,   0) / nScore

    nS = array.size(ySBuf)
    nL = array.size(yLBuf)
    wS = nS == 0 ? na : array.get(sumYS, 0) / nS
    wL = nL == 0 ? na : array.get(sumYL, 0) / nL
    drift = (na(wS) or na(wL)) ? na : (wS - wL)

    ece = float(na)
    maxErr = float(na)
    B = evalBuckets
    sizeCnt = array.size(calCnt)
    if sizeCnt == B
        tot = 0
        for i = 0 to sizeCnt - 1
            tot += array.get(calCnt, i)
        if tot > 0
            e = 0.0
            m = 0.0
            for i = 0 to sizeCnt - 1
                c = array.get(calCnt, i)
                if c > 0
                    ap = array.get(calSumP, i) / c
                    ay = array.get(calSumY, i) / c
                    err = math.abs(ap - ay)
                    e += err * (c / tot)
                    m := math.max(m, err)
            ece := e
            maxErr := m
    else if sizeCnt == B * 3
        eTot = 0.0
        mTot = 0.0
        for cls = 0 to 2
            totC = 0
            for i = 0 to B - 1
                totC += array.get(calCnt, cls * B + i)
            if totC > 0
                eC = 0.0
                mC = 0.0
                for i = 0 to B - 1
                    idx = cls * B + i
                    c = array.get(calCnt, idx)
                    if c > 0
                        ap = array.get(calSumP, idx) / c
                        ay = array.get(calSumY, idx) / c
                        err = math.abs(ap - ay)
                        eC += err * (c / totC)
                        mC := math.max(mC, err)
                eTot += eC
                mTot := math.max(mTot, mC)
        ece := eTot / 3.0
        maxErr := mTot

    [brierAvg, logAvg, ece, maxErr, wS, wL, drift, nScore]

f_eval_update_one(p, y,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: run if Eval section visible OR background eval enabled
    canEval = (showEvalSection or evalInBackground) and barstate.isconfirmed
    if canEval
        pc = f_epsClamp(p)

        f_roll_add(brierBuf, sumBrier, f_brier(pc, y), evalRollScore)
        f_roll_add(logBuf,   sumLog,   f_logloss(pc, y), evalRollScore)

        f_roll_add(ySBuf, sumYS, y, evalRollShort)
        f_roll_add(yLBuf, sumYL, y, evalRollLong)

        f_cal_roll_update(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pc, y, evalRollScore)

f_eval_update_one3(pU, pF, pD, outcome,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: run if Eval section visible OR background eval enabled
    canEval = (showEvalSection or evalInBackground) and barstate.isconfirmed
    if canEval
        b3 = f_brier3(pU, pF, pD, outcome)
        ll = f_logloss3(pU, pF, pD, outcome)
        yUp = outcome == 1 ? 1.0 : 0.0

        f_roll_add(brierBuf, sumBrier, b3, evalRollScore)
        f_roll_add(logBuf,   sumLog,   ll, evalRollScore)

        f_roll_add(ySBuf, sumYS, yUp, evalRollShort)
        f_roll_add(yLBuf, sumYL, yUp, evalRollLong)

        f_cal_roll_update3(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pU, pF, pD, outcome, evalRollScore)

f_eval_on_resolve(TfState st, pPredN, pPred1, isUp) =>
    y = isUp ? 1.0 : 0.0

    f_eval_update_one(pPredN, y, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
    f_eval_update_one(pPred1, y, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY) =>
    [bAvg_t, lAvg_t, ece_t, _mErr_t, wS_t, wL_t, drift_t, nScore_t] = f_eval_stats_one(evBrier, evSumBrier, evLog, evSumLog, evYS, evSumYS, evYL, evSumYL, evCalCnt, evCalSumP, evCalSumY)
    bAvg = bAvg_t
    lAvg = lAvg_t
    ece = ece_t
    _mErr = _mErr_t
    wS = wS_t
    wL = wL_t
    drift = drift_t
    nScore = nScore_t
    if nScore < evalMinEvents
        [float(na), float(na), float(na), float(na), float(nScore)]
    else
        driftPP = na(drift) ? na : drift * 100.0
        [bAvg, lAvg, ece, driftPP, float(nScore)]

// Table Helpers
f_colLowerBetter(val, goodThr, badThr) =>
    na(val) ? color.new(color.gray, 60) : val < goodThr ? color.new(color.lime, 30) : val > badThr ? color.new(color.red, 30) : color.new(color.yellow, 30)

f_ppSigned(val) =>
    na(val) ? "â€”" : (val > 0 ? "+" : "") + str.tostring(val, "#.1") + "pp"

f_rowEval(tbl, tid, titleStr, evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY, rIdx) =>
    [bs_t, ll_t, ece_t, drift_t, n_t] = f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY)
    bs = bs_t
    ll = ll_t
    ece = ece_t
    drift = drift_t
    n = n_t
    
    // Header
    table.cell(tbl, 0, rIdx, titleStr, text_halign=text.align_left, text_size=size.small, bgcolor=color.new(color.gray, 90))
    
    if na(bs)
        table.cell(tbl, 1, rIdx, "Wait (" + str.tostring(n, "#") + ")", text_size=size.small)
    else
        // Brier
        // scale: typically 0.25 is max entropy. <0.20 is good. <0.15 is great.
        // Let's color based on general intuition
        cBs = f_colLowerBetter(bs, 0.18, 0.23)
        table.cell(tbl, 1, rIdx, str.tostring(bs, "#.3f"), bgcolor=cBs, text_size=size.small)
        
        // LogL
        // scale: ~0.693 is rand. <0.60 is good.
        cLl = f_colLowerBetter(ll, 0.55, 0.65)
        table.cell(tbl, 2, rIdx, str.tostring(ll, "#.3f"), bgcolor=cLl, text_size=size.small)
        
        // ECE
        cEce = f_colLowerBetter(ece, ECE_GOOD, ECE_FAIR)
        table.cell(tbl, 3, rIdx, str.tostring(ece*100, "#.1")+"%", bgcolor=cEce, text_size=size.small)
        
        // Drift
        cDr = math.abs(drift) > driftWarnPP ? color.new(color.red, 30) : color.new(color.gray, 90)
        table.cell(tbl, 4, rIdx, f_ppSigned(drift), bgcolor=cDr, text_size=size.small)


f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0.0), array.fill(st.upN, 0.0), array.fill(st.dnN, 0.0)
    array.fill(st.cnt1, 0.0), array.fill(st.up1, 0.0), array.fill(st.dn1, 0.0)
    array.fill(st.cntN_bull, 0.0), array.fill(st.upN_bull, 0.0), array.fill(st.dnN_bull, 0.0)
    array.fill(st.cntN_bear, 0.0), array.fill(st.upN_bear, 0.0), array.fill(st.dnN_bear, 0.0)
    array.fill(st.cnt1_bull, 0.0), array.fill(st.up1_bull, 0.0), array.fill(st.dn1_bull, 0.0)
    array.fill(st.cnt1_bear, 0.0), array.fill(st.up1_bear, 0.0), array.fill(st.dn1_bear, 0.0)
    array.fill(st.cntN_raw, 0.0), array.fill(st.upN_raw, 0.0), array.fill(st.dnN_raw, 0.0)
    array.fill(st.cnt1_raw, 0.0), array.fill(st.up1_raw, 0.0), array.fill(st.dn1_raw, 0.0)
    array.fill(st.cntN_bull_raw, 0.0), array.fill(st.upN_bull_raw, 0.0), array.fill(st.dnN_bull_raw, 0.0)
    array.fill(st.cntN_bear_raw, 0.0), array.fill(st.upN_bear_raw, 0.0), array.fill(st.dnN_bear_raw, 0.0)
    array.fill(st.cnt1_bull_raw, 0.0), array.fill(st.up1_bull_raw, 0.0), array.fill(st.dn1_bull_raw, 0.0)
    array.fill(st.cnt1_bear_raw, 0.0), array.fill(st.up1_bear_raw, 0.0), array.fill(st.dn1_bear_raw, 0.0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    array.clear(st.qBias)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    array.clear(st.qPUpN)
    array.clear(st.qPFlN)
    array.clear(st.qPDnN)
    array.clear(st.qPUp1)
    array.clear(st.qPFl1)
    array.clear(st.qPDn1)
    array.clear(st.qZUpN)
    array.clear(st.qZFlN)
    array.clear(st.qZDnN)
    array.clear(st.qZUp1)
    array.clear(st.qZFl1)
    array.clear(st.qZDn1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)
    array.set(st.tempN, 0, 1.0)
    array.set(st.temp1, 0, 1.0)
    array.set(st.vecAN, 0, 1.0)
    array.set(st.vecAN, 1, 1.0)
    array.set(st.vecAN, 2, 1.0)
    array.set(st.vecBN, 0, 0.0)
    array.set(st.vecBN, 1, 0.0)
    array.set(st.vecBN, 2, 0.0)
    array.set(st.vecA1, 0, 1.0)
    array.set(st.vecA1, 1, 1.0)
    array.set(st.vecA1, 2, 1.0)
    array.set(st.vecB1, 0, 0.0)
    array.set(st.vecB1, 1, 0.0)
    array.set(st.vecB1, 2, 0.0)

    array.set(st.tempN_bull, 0, 1.0)
    array.set(st.temp1_bull, 0, 1.0)
    array.set(st.vecAN_bull, 0, 1.0)
    array.set(st.vecAN_bull, 1, 1.0)
    array.set(st.vecAN_bull, 2, 1.0)
    array.set(st.vecBN_bull, 0, 0.0)
    array.set(st.vecBN_bull, 1, 0.0)
    array.set(st.vecBN_bull, 2, 0.0)
    array.set(st.vecA1_bull, 0, 1.0)
    array.set(st.vecA1_bull, 1, 1.0)
    array.set(st.vecA1_bull, 2, 1.0)
    array.set(st.vecB1_bull, 0, 0.0)
    array.set(st.vecB1_bull, 1, 0.0)
    array.set(st.vecB1_bull, 2, 0.0)

    array.set(st.tempN_bear, 0, 1.0)
    array.set(st.temp1_bear, 0, 1.0)
    array.set(st.vecAN_bear, 0, 1.0)
    array.set(st.vecAN_bear, 1, 1.0)
    array.set(st.vecAN_bear, 2, 1.0)
    array.set(st.vecBN_bear, 0, 0.0)
    array.set(st.vecBN_bear, 1, 0.0)
    array.set(st.vecBN_bear, 2, 0.0)
    array.set(st.vecA1_bear, 0, 1.0)
    array.set(st.vecA1_bear, 1, 1.0)
    array.set(st.vecA1_bear, 2, 1.0)
    array.set(st.vecB1_bear, 0, 0.0)
    array.set(st.vecB1_bear, 1, 0.0)
    array.set(st.vecB1_bear, 2, 0.0)

    array.clear(st.qScoreBuf)
    array.fill(st.qCutsN, na)
    array.fill(st.qCuts1, na)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN)
    f_reset_sum1(st.evSumBrierN)
    array.clear(st.evLogN)
    f_reset_sum1(st.evSumLogN)
    array.clear(st.evYS_N)
    f_reset_sum1(st.evSumYS_N)
    array.clear(st.evYL_N)
    f_reset_sum1(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1)
    f_reset_sum1(st.evSumBrier1)
    array.clear(st.evLog1)
    f_reset_sum1(st.evSumLog1)
    array.clear(st.evYS_1)
    f_reset_sum1(st.evSumYS_1)
    array.clear(st.evYL_1)
    f_reset_sum1(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// A5 â€“ ECE-triggered recalibration: boost Platt LR when model is poorly calibrated
var float prevEvalEce = na
lrPlattEff = lrPlatt
if useEceRecal and not na(prevEvalEce) and prevEvalEce >= eceWarn
    lrPlattEff := math.min(lrPlatt * eceRecalBoost, 0.05)

// Process one TF calibration step (updates on TF close)
// @param _hid Horizon ID (1-7) - reserved for debugging/logging
f_process_tf(_hid, _tf, tfBarConfirmed, sA, 
             cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
             TfState st,
             fcTgt, kB, aThr, pH, tpA, slA,
             alphaNVal, alpha1Val, shrinkKVal, wStateVal, wPullbackVal, wRegimeVal, wTrendVal) =>

    if tfBarConfirmed
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = f_safe_get_int(st.qAge,   i, 0)
            entry_i = f_safe_get_float(st.qEntry, i, na)
            atr_i   = f_safe_get_float(st.qAtr,   i, na)
            mh_i    = f_safe_get_float(st.qMaxH,  i, na)
            ml_i    = f_safe_get_float(st.qMinL,  i, na)
            bN_i    = f_safe_get_int(st.qBinN,  i, 0)
            b1_i    = f_safe_get_int(st.qBin1,  i, 0)
            bias_i  = f_safe_get_int(st.qBias,  i, 0)

            // Stored at entry
            float probN_i = na
            float prob1_i = na
            float lgtN_i = na
            float lgt1_i = na
            float predN_i = na
            float pred1_i = na
            if not use3Way
                probN_i := f_safe_get_float(st.qProbN,  i, na)
                prob1_i := f_safe_get_float(st.qProb1,  i, na)
                lgtN_i  := f_safe_get_float(st.qLogitN, i, na)
                lgt1_i  := f_safe_get_float(st.qLogit1, i, na)
                predN_i := f_safe_get_float(st.qPredN,  i, na)
                pred1_i := f_safe_get_float(st.qPred1,  i, na)

            // 3-way stored probs/logits
            float pUpN_i = na
            float pFlN_i = na
            float pDnN_i = na
            float pUp1_i = na
            float pFl1_i = na
            float pDn1_i = na
            float zUpN_i = na
            float zFlN_i = na
            float zDnN_i = na
            float zUp1_i = na
            float zFl1_i = na
            float zDn1_i = na
            if use3Way
                pUpN_i := f_safe_get_float(st.qPUpN, i, na)
                pFlN_i := f_safe_get_float(st.qPFlN, i, na)
                pDnN_i := f_safe_get_float(st.qPDnN, i, na)
                pUp1_i := f_safe_get_float(st.qPUp1, i, na)
                pFl1_i := f_safe_get_float(st.qPFl1, i, na)
                pDn1_i := f_safe_get_float(st.qPDn1, i, na)
                zUpN_i := f_safe_get_float(st.qZUpN, i, na)
                zFlN_i := f_safe_get_float(st.qZFlN, i, na)
                zDnN_i := f_safe_get_float(st.qZDnN, i, na)
                zUp1_i := f_safe_get_float(st.qZUp1, i, na)
                zFl1_i := f_safe_get_float(st.qZFl1, i, na)
                zDn1_i := f_safe_get_float(st.qZDn1, i, na)

            resolved = false
            doUpdate = false
            isUp     = false
            int outcome = 0

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                    else
                        doUpdate := true
                        if use3Way
                            db = f_db_mult(_tf) * atr_i
                            delta = cNow - entry_i
                            outcome := f_outcome3(delta, db)
                            isUp := outcome == 1
                        else
                            retATR = (cNow - entry_i) / atr_i
                            isUp := retATR >= aThr
                            outcome := isUp ? 1 : -1

            else // PathTPvsSL (directional by stored bias)
                if bias_i == 0
                    if age_i >= pH
                        resolved := true
                        doUpdate := false
                else if na(atr_i) or atr_i <= 0.0
                    if age_i >= pH
                        resolved := true
                        doUpdate := false
                else
                    dir = bias_i > 0 ? 1 : -1
                    tpPx = dir == 1 ? (entry_i + tpA * atr_i) : (entry_i - tpA * atr_i)
                    slPx = dir == 1 ? (entry_i - slA * atr_i) : (entry_i + slA * atr_i)
                    winHit  = dir == 1 ? (mh_i >= tpPx) : (ml_i <= tpPx)
                    lossHit = dir == 1 ? (ml_i <= slPx) : (mh_i >= slPx)

                    if winHit or lossHit
                        resolved := true
                        doUpdate := true
                        if winHit and lossHit
                            if pathTiePolicy == "Win"
                                outcome := dir
                            else if pathTiePolicy == "Neutral"
                                if use3Way
                                    outcome := 0
                                else
                                    doUpdate := false
                            else
                                outcome := -dir
                            isUp := outcome == 1
                        else
                            outcome := winHit ? dir : -dir
                            isUp := outcome == 1

                    else if age_i >= pH
                        resolved := true
                        if noHitPolicy == "Loss"
                            doUpdate := true
                            outcome := -dir
                            isUp := outcome == 1
                        else if use3Way and noHitPolicy == "Neutral"
                            doUpdate := true
                            outcome := 0
                        else
                            doUpdate := false

            if resolved
                if doUpdate
                    if not use3Way
                        outcome := isUp ? 1 : -1
                    if use3Way
                        f_decay_counts(st.cntN, st.upN, st.dnN, countDecay)
                        f_decay_counts(st.cnt1, st.up1, st.dn1, countDecay)
                    f_cal_update3(st.cntN, st.upN, st.dnN, bN_i, outcome)
                    f_cal_update3(st.cnt1, st.up1, st.dn1, b1_i, outcome)
                    f_cal_update3(st.cntN_raw, st.upN_raw, st.dnN_raw, bN_i, outcome)
                    f_cal_update3(st.cnt1_raw, st.up1_raw, st.dn1_raw, b1_i, outcome)

                    if use3Way and useBullBearCal and bias_i != 0
                        useBull = bias_i > 0
                        cntN_sel = useBull ? st.cntN_bull : st.cntN_bear
                        upN_sel  = useBull ? st.upN_bull  : st.upN_bear
                        dnN_sel  = useBull ? st.dnN_bull  : st.dnN_bear
                        cnt1_sel = useBull ? st.cnt1_bull : st.cnt1_bear
                        up1_sel  = useBull ? st.up1_bull  : st.up1_bear
                        dn1_sel  = useBull ? st.dn1_bull  : st.dn1_bear
                        cntN_raw_sel = useBull ? st.cntN_bull_raw : st.cntN_bear_raw
                        upN_raw_sel  = useBull ? st.upN_bull_raw  : st.upN_bear_raw
                        dnN_raw_sel  = useBull ? st.dnN_bull_raw  : st.dnN_bear_raw
                        cnt1_raw_sel = useBull ? st.cnt1_bull_raw : st.cnt1_bear_raw
                        up1_raw_sel  = useBull ? st.up1_bull_raw  : st.up1_bear_raw
                        dn1_raw_sel  = useBull ? st.dn1_bull_raw  : st.dn1_bear_raw
                        f_decay_counts(cntN_sel, upN_sel, dnN_sel, countDecay)
                        f_decay_counts(cnt1_sel, up1_sel, dn1_sel, countDecay)
                        f_cal_update3(cntN_sel, upN_sel, dnN_sel, bN_i, outcome)
                        f_cal_update3(cnt1_sel, up1_sel, dn1_sel, b1_i, outcome)
                        f_cal_update3(cntN_raw_sel, upN_raw_sel, dnN_raw_sel, bN_i, outcome)
                        f_cal_update3(cnt1_raw_sel, up1_raw_sel, dn1_raw_sel, b1_i, outcome)
                    
                    outcomeVal = isUp ? 1.0 : 0.0
                    
                    // --- Evaluation (Live Scoring) ---
                    // Score based on the final prediction we made (predN_i / pred1_i)
                    if use3Way
                        f_eval_update_one3(pUpN_i, pFlN_i, pDnN_i, outcome,
                            st.evBrierN, st.evSumBrierN,
                            st.evLogN, st.evSumLogN,
                            st.evYS_N, st.evSumYS_N,
                            st.evYL_N, st.evSumYL_N,
                            st.evCalCntN, st.evCalSumPN, st.evCalSumYN,
                            st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
                        f_eval_update_one3(pUp1_i, pFl1_i, pDn1_i, outcome,
                            st.evBrier1, st.evSumBrier1,
                            st.evLog1, st.evSumLog1,
                            st.evYS_1, st.evSumYS_1,
                            st.evYL_1, st.evSumYL_1,
                            st.evCalCnt1, st.evCalSumP1, st.evCalSumY1,
                            st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)
                    else
                        f_eval_on_resolve(st, predN_i, pred1_i, isUp)

                    if use3Way and calibratorMode != "Off"
                        nBinN_cur = array.get(st.cntN, bN_i)
                        nBin1_cur = array.get(st.cnt1, b1_i)
                        canCalN = not cal3AutoFallback or nBinN_cur >= cal3MinSamples
                        canCal1 = not cal3AutoFallback or nBin1_cur >= cal3MinSamples
                        regW_N = calRegStrength * (cal3MinSamples <= 0 ? 0.0 : math.max(0.0, 1.0 - math.min(1.0, nBinN_cur / cal3MinSamples)))
                        regW_1 = calRegStrength * (cal3MinSamples <= 0 ? 0.0 : math.max(0.0, 1.0 - math.min(1.0, nBin1_cur / cal3MinSamples)))
                        yU = outcome == 1 ? 1.0 : 0.0
                        yF = outcome == 0 ? 1.0 : 0.0
                        yD = outcome == -1 ? 1.0 : 0.0
                        tempN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
                        temp1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
                        vecAN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
                        vecBN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
                        vecA1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
                        vecB1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1

                        if calibratorMode == "Temp"
                            if canCalN
                                tN = array.get(tempN_sel, 0)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(zUpN_i / tN, zFlN_i / tN, zDnN_i / tN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                gradN = ((pUNc - yU) * zUpN_i + (pFNc - yF) * zFlN_i + (pDNc - yD) * zDnN_i) / (tN * tN)
                                tN := f_clamp(tN - lrCal * gradN - regW_N * (tN - 1.0), tempMin, tempMax)
                                array.set(tempN_sel, 0, tN)

                            if canCal1
                                t1 = array.get(temp1_sel, 0)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(zUp1_i / t1, zFl1_i / t1, zDn1_i / t1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                grad1 = ((pU1c - yU) * zUp1_i + (pF1c - yF) * zFl1_i + (pD1c - yD) * zDn1_i) / (t1 * t1)
                                t1 := f_clamp(t1 - lrCal * grad1 - regW_1 * (t1 - 1.0), tempMin, tempMax)
                                array.set(temp1_sel, 0, t1)
                        else if calibratorMode == "Vector"
                            if canCalN
                                aUN = array.get(vecAN_sel, 0)
                                aFN = array.get(vecAN_sel, 1)
                                aDN = array.get(vecAN_sel, 2)
                                bUN = array.get(vecBN_sel, 0)
                                bFN = array.get(vecBN_sel, 1)
                                bDN = array.get(vecBN_sel, 2)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(aUN * zUpN_i + bUN, aFN * zFlN_i + bFN, aDN * zDnN_i + bDN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                aUN := f_clamp(aUN - lrCal * (pUNc - yU) * zUpN_i - regW_N * (aUN - 1.0), vecAMin, vecAMax)
                                aFN := f_clamp(aFN - lrCal * (pFNc - yF) * zFlN_i - regW_N * (aFN - 1.0), vecAMin, vecAMax)
                                aDN := f_clamp(aDN - lrCal * (pDNc - yD) * zDnN_i - regW_N * (aDN - 1.0), vecAMin, vecAMax)
                                bUN := f_clamp(bUN - lrCal * (pUNc - yU) - regW_N * bUN, vecBMin, vecBMax)
                                bFN := f_clamp(bFN - lrCal * (pFNc - yF) - regW_N * bFN, vecBMin, vecBMax)
                                bDN := f_clamp(bDN - lrCal * (pDNc - yD) - regW_N * bDN, vecBMin, vecBMax)
                                array.set(vecAN_sel, 0, aUN)
                                array.set(vecAN_sel, 1, aFN)
                                array.set(vecAN_sel, 2, aDN)
                                array.set(vecBN_sel, 0, bUN)
                                array.set(vecBN_sel, 1, bFN)
                                array.set(vecBN_sel, 2, bDN)

                            if canCal1
                                aU1 = array.get(vecA1_sel, 0)
                                aF1 = array.get(vecA1_sel, 1)
                                aD1 = array.get(vecA1_sel, 2)
                                bU1 = array.get(vecB1_sel, 0)
                                bF1 = array.get(vecB1_sel, 1)
                                bD1 = array.get(vecB1_sel, 2)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(aU1 * zUp1_i + bU1, aF1 * zFl1_i + bF1, aD1 * zDn1_i + bD1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                aU1 := f_clamp(aU1 - lrCal * (pU1c - yU) * zUp1_i - regW_1 * (aU1 - 1.0), vecAMin, vecAMax)
                                aF1 := f_clamp(aF1 - lrCal * (pF1c - yF) * zFl1_i - regW_1 * (aF1 - 1.0), vecAMin, vecAMax)
                                aD1 := f_clamp(aD1 - lrCal * (pD1c - yD) * zDn1_i - regW_1 * (aD1 - 1.0), vecAMin, vecAMax)
                                bU1 := f_clamp(bU1 - lrCal * (pU1c - yU) - regW_1 * bU1, vecBMin, vecBMax)
                                bF1 := f_clamp(bF1 - lrCal * (pF1c - yF) - regW_1 * bF1, vecBMin, vecBMax)
                                bD1 := f_clamp(bD1 - lrCal * (pD1c - yD) - regW_1 * bD1, vecBMin, vecBMax)
                                array.set(vecA1_sel, 0, aU1)
                                array.set(vecA1_sel, 1, aF1)
                                array.set(vecA1_sel, 2, aD1)
                                array.set(vecB1_sel, 0, bU1)
                                array.set(vecB1_sel, 1, bF1)
                                array.set(vecB1_sel, 2, bD1)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    if not use3Way
                        nBinN_cur = array.get(st.cntN, bN_i)
                        if nBinN_cur >= calMinSamples
                            // Brier on raw prob
                            sqErrN = math.pow(outcomeVal - probN_i, 2)
                            curSumN = array.get(st.brierStatsN, 0)
                            curCntN = array.get(st.brierStatsN, 1)
                            array.set(st.brierStatsN, 0, curSumN + sqErrN)
                            array.set(st.brierStatsN, 1, curCntN + 1.0)
                            
                            // Platt SGD
                            if usePlatt
                                aN = array.get(st.plattN, 0)
                                bN = array.get(st.plattN, 1)
                                pAdj = f_sigmoid(aN * lgtN_i + bN)
                                err = pAdj - outcomeVal
                                da = err * lgtN_i
                                db = err
                                // A2 â€“ Momentum: EMA of gradients
                                float effDa = da
                                float effDb = db
                                if useSgdMomentum
                                    mA = sgdBeta * array.get(st.momPlattN, 0) + (1.0 - sgdBeta) * da
                                    mB = sgdBeta * array.get(st.momPlattN, 1) + (1.0 - sgdBeta) * db
                                    array.set(st.momPlattN, 0, mA)
                                    array.set(st.momPlattN, 1, mB)
                                    effDa := mA
                                    effDb := mB
                                // Update
                                aN := math.max(0.1, math.min(5.0, aN - lrPlattEff * effDa)) 
                                bN := math.max(-3.0, math.min(3.0, bN - lrPlattEff * effDb))
                                array.set(st.plattN, 0, aN)
                                array.set(st.plattN, 1, bN)
                                
                                // LogLoss
                                pLL = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj))
                                ll = -(outcomeVal * math.log(pLL) + (1.0 - outcomeVal) * math.log(1.0 - pLL))
                                curSumLL = array.get(st.llStatsN, 0)
                                curCntLL = array.get(st.llStatsN, 1)
                                array.set(st.llStatsN, 0, curSumLL + ll)
                                array.set(st.llStatsN, 1, curCntLL + 1.0)
                        
                        // --- Phase 4: SGD Update & LogLoss (1) ---
                        sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                        curSum1 = array.get(st.brierStats1, 0)
                        curCnt1 = array.get(st.brierStats1, 1)
                        array.set(st.brierStats1, 0, curSum1 + sqErr1)
                        array.set(st.brierStats1, 1, curCnt1 + 1.0)

                        if usePlatt
                            pltA1 = array.get(st.platt1, 0)
                            pltB1 = array.get(st.platt1, 1)
                            pAdj1 = f_sigmoid(pltA1 * lgt1_i + pltB1)
                            err1 = pAdj1 - outcomeVal
                            da1 = err1 * lgt1_i
                            db1 = err1
                            // A2 â€“ Momentum: EMA of gradients (head 1)
                            float effDa1 = da1
                            float effDb1 = db1
                            if useSgdMomentum
                                mA1 = sgdBeta * array.get(st.momPlatt1, 0) + (1.0 - sgdBeta) * da1
                                mB1 = sgdBeta * array.get(st.momPlatt1, 1) + (1.0 - sgdBeta) * db1
                                array.set(st.momPlatt1, 0, mA1)
                                array.set(st.momPlatt1, 1, mB1)
                                effDa1 := mA1
                                effDb1 := mB1
                            pltA1 := math.max(0.1, math.min(5.0, pltA1 - lrPlattEff * effDa1))
                            pltB1 := math.max(-3.0, math.min(3.0, pltB1 - lrPlattEff * effDb1))
                            array.set(st.platt1, 0, pltA1)
                            array.set(st.platt1, 1, pltB1)
                            
                            pLL1 = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj1))
                            ll1 = -(outcomeVal * math.log(pLL1) + (1.0 - outcomeVal) * math.log(1.0 - pLL1))
                            curSumLL1 = array.get(st.llStats1, 0)
                            curCntLL1 = array.get(st.llStats1, 1)
                            array.set(st.llStats1, 0, curSumLL1 + ll1)
                            array.set(st.llStats1, 1, curCntLL1 + 1.0)

                if not use3Way
                    f_safe_remove_float(st.qProbN, i)
                    f_safe_remove_float(st.qProb1, i)
                    f_safe_remove_float(st.qLogitN, i)
                    f_safe_remove_float(st.qLogit1, i)
                    f_safe_remove_float(st.qPredN, i)
                    f_safe_remove_float(st.qPred1, i)
                if use3Way
                    f_safe_remove_float(st.qPUpN, i)
                    f_safe_remove_float(st.qPFlN, i)
                    f_safe_remove_float(st.qPDnN, i)
                    f_safe_remove_float(st.qPUp1, i)
                    f_safe_remove_float(st.qPFl1, i)
                    f_safe_remove_float(st.qPDn1, i)
                    f_safe_remove_float(st.qZUpN, i)
                    f_safe_remove_float(st.qZFlN, i)
                    f_safe_remove_float(st.qZDnN, i)
                    f_safe_remove_float(st.qZUp1, i)
                    f_safe_remove_float(st.qZFl1, i)
                    f_safe_remove_float(st.qZDn1, i)
                f_safe_remove_int(st.qAge,   i)
                f_safe_remove_float(st.qMaxH,  i)
                f_safe_remove_float(st.qMinL,  i)
                f_safe_remove_float(st.qAtr,   i)
                f_safe_remove_float(st.qEntry, i)
                f_safe_remove_int(st.qBinN,  i)
                f_safe_remove_int(st.qBin1,  i)
                f_safe_remove_int(st.qBias, i)
            i -= 1
        bias = emaFNow > emaSNow ? 1 : emaFNow < emaSNow ? -1 : 0
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        // Epsilon PRICE_EPS prevents division by zero on penny stocks or exotic instruments with close near 0
        atrNorm = atrNow / math.max(cNow, PRICE_EPS)
        sD = f_trend_regime(emaFNow, emaSNow, atrNorm)
        sEns = f_ensemble4(sA, sB, sC, sD, wStateVal, wPullbackVal, wRegimeVal, wTrendVal)
        if not na(sEns) and not na(sD)
            f_update_quantiles(st, sEns)
            
            // --- Phase 2: 2D Binning ---
            bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, st.qCutsN)
            b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, st.qCuts1)

            dirFlag = f_bias_from_score(sA)
            biasSel = f_bias_from_score(sA)
            if biasSel == 0
                biasSel := bias == 0 ? 1 : bias
            cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
            upN_sel  = useBullBearCal ? (biasSel > 0 ? st.upN_bull  : st.upN_bear)  : st.upN
            dnN_sel  = useBullBearCal ? (biasSel > 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
            cnt1_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
            up1_sel  = useBullBearCal ? (biasSel > 0 ? st.up1_bull  : st.up1_bear)  : st.up1
            dn1_sel  = useBullBearCal ? (biasSel > 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1

            tempN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
            temp1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
            vecAN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
            vecBN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
            vecA1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
            vecB1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1

            if use3Way
                [pUrawN_t, pFrawN_t, pDrawN_t, _nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaNVal, shrinkKVal, kShrinkReg)
                [pUraw1_t, pFraw1_t, pDraw1_t, _n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1Val, shrinkKVal, kShrinkReg)
                pUrawN = pUrawN_t
                pFrawN = pFrawN_t
                pDrawN = pDrawN_t
                _nN = _nN_t
                pUraw1 = pUraw1_t
                pFraw1 = pFraw1_t
                pDraw1 = pDraw1_t
                _n1 = _n1_t

                zUN = f_safe_log(pUrawN)
                zFN = f_safe_log(pFrawN)
                zDN = f_safe_log(pDrawN)
                zU1 = f_safe_log(pUraw1)
                zF1 = f_safe_log(pFraw1)
                zD1 = f_safe_log(pDraw1)

                useCalN = f_can_cal3(_nN)
                useCal1 = f_can_cal3(_n1)
                float pUN = na
                float pFN = na
                float pDN = na
                float pU1 = na
                float pF1 = na
                float pD1 = na
                if useCalN
                    [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, tempN_sel, vecAN_sel, vecBN_sel)
                    pUN := tUN_t
                    pFN := tFN_t
                    pDN := tDN_t
                else
                    pUN := pUrawN
                    pFN := pFrawN
                    pDN := pDrawN
                if useCal1
                    [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, temp1_sel, vecA1_sel, vecB1_sel)
                    pU1 := tU1_t
                    pF1 := tF1_t
                    pD1 := tD1_t
                else
                    pU1 := pUraw1
                    pF1 := pFraw1
                    pD1 := pDraw1

                array.push(st.qBinN,  bN)
                array.push(st.qBin1,  b1)
                array.push(st.qEntry, cNow)
                array.push(st.qAtr,   atrNow)

                array.push(st.qMaxH,  cNow)
                array.push(st.qMinL,  cNow)

                array.push(st.qAge,   0)
                array.push(st.qBias,  dirFlag)

                array.push(st.qPUpN, pUN)
                array.push(st.qPFlN, pFN)
                array.push(st.qPDnN, pDN)
                array.push(st.qPUp1, pU1)
                array.push(st.qPFl1, pF1)
                array.push(st.qPDn1, pD1)

                array.push(st.qZUpN, zUN)
                array.push(st.qZFlN, zFN)
                array.push(st.qZDnN, zDN)
                array.push(st.qZUp1, zU1)
                array.push(st.qZFl1, zF1)
                array.push(st.qZDn1, zD1)
            else
                // Capture current probabilities
                [pNowN_t, _nN_t] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
                [pNow1_t, _n1_t] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)
                pNowN = pNowN_t
                _nN = _nN_t
                pNow1 = pNow1_t
                _n1 = _n1_t

                // Logits (Phase 4)
                lgtN = f_logit(pNowN)
                lgt1 = f_logit(pNow1)

                // Platt Adjust (Display/Predict)
                aN = array.get(st.plattN, 0)
                bN_p = array.get(st.plattN, 1)
                pAdjN = f_sigmoid(aN * lgtN + bN_p)

                pltA1 = array.get(st.platt1, 0)
                pltB1_p = array.get(st.platt1, 1)
                pAdj1 = f_sigmoid(pltA1 * lgt1 + pltB1_p)

                // Use adjusted if Platt enabled, else raw
                pFinalN = usePlatt ? pAdjN : pNowN
                pFinal1 = usePlatt ? pAdj1 : pNow1

                array.push(st.qBinN,  bN)
                array.push(st.qBin1,  b1)
                array.push(st.qEntry, cNow)
                array.push(st.qAtr,   atrNow)

                array.push(st.qMaxH,  cNow)
                array.push(st.qMinL,  cNow)

                array.push(st.qAge,   0)
                array.push(st.qBias,  dirFlag)

                array.push(st.qProbN, pNowN)
                array.push(st.qProb1, pNow1)
                array.push(st.qLogitN, lgtN)
                array.push(st.qLogit1, lgt1)
                array.push(st.qPredN, pFinalN)
                array.push(st.qPred1, pFinal1)

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ? ((not na(baseSecs) and baseSecs <= SEC_5M) ? rsiLenFastTF : (not na(baseSecs) and baseSecs <= SEC_1H) ? rsiLenMidTF : rsiLenSlowTF) : rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime (protect against close=0 on exotic instruments)
atrRank = f_pct_rank(atr / math.max(close, PRICE_EPS), volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? nz(volRankRaw, 0.5) : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScoreDir = macroGateMode == "Off" ? 0.5 : emaF > emaS ? (1.0 - macroPct) : emaF < emaS ? macroPct : 0.5
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSevereSafe = math.max(ddSevere, ddMild + PRICE_EPS)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevereSafe - ddMild, PRICE_EPS))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // global per-bar
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    trendOk = dir == 1 ? (emaF > emaS and close > emaS) : (emaF < emaS and close < emaS)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier = config == "Standard" ? 1.00 : config == "Pro" ? 1.05 : config == "V2 Essential" ? 0.95 : config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScoreDir, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
var float entryAtr   = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice = zoneAnchor == "Entry" and not na(entryPrice) ? entryPrice : zoneAnchor == "VWAP" ? vwapVal : zoneAnchor == "MA200" ? sma200Val : zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setLongStrict = (setLong == true)
setShortStrict = (setShort == true)
setAnyStrict = setLongStrict or setShortStrict
setAnyPrevStrict = (setAnyStrict[1] == true)
setLongPrevStrict = (setLongStrict[1] == true)
setShortPrevStrict = (setShortStrict[1] == true)
setPulse  = barstate.isconfirmed and (setPulseOnly ? (setAnyStrict and not setAnyPrevStrict) : setAnyStrict)
setLongPulse = setPulseOnly ? (setLongStrict and not setLongPrevStrict) : setLongStrict
setShortPulse = setPulseOnly ? (setShortStrict and not setShortPrevStrict) : setShortStrict

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "â€”"

// C2 â€“ Adaptive cooldown: halve wait when model confidence is high
effectiveCooldown = (confidence >= 0.80) ? math.max(2, math.round(cooldownBars / 2)) : cooldownBars
cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > effectiveCooldown)

f_getBrier_raw(tfSel, modSel) =>
    float score = na

    TfState st = na
    if tfSel == "F1"
        st := tf1State
    else if tfSel == "F2"
        st := tf2State
    else if tfSel == "F3"
        st := tf3State
    else if tfSel == "F4"
        st := tf4State
    else if tfSel == "F5"
        st := tf5State
    else if tfSel == "F6"
        st := tf6State
    else if tfSel == "F7"
        st := tf7State

    if not na(st)
        if use3Way
            float[] buf = (modSel == "N") ? st.evBrierN : st.evBrier1
            float[] sum = (modSel == "N") ? st.evSumBrierN : st.evSumBrier1
            score := array.size(buf) == 0 ? na : array.get(sum, 0) / array.size(buf)
        else
            float[] stats = (modSel == "N") ? st.brierStatsN : st.brierStats1
            s = array.get(stats, 0)
            c = array.get(stats, 1)
            score := c > 0 ? s / c : na

    score

f_getBrier_disp(tfSel, modSel) =>
    nz(f_getBrier_raw(tfSel, modSel), 0.5)

f_get_total_samples(tfSel, modSel, useBull) =>
    float total = na
    float[] cnt = na
    useBullSel = (useBull == true)
    if tfSel == "F1"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf1State.cntN_bull_raw : tf1State.cntN_bear_raw) : (useBullSel ? tf1State.cnt1_bull_raw : tf1State.cnt1_bear_raw)) : ((modSel == "N") ? tf1State.cntN_raw : tf1State.cnt1_raw)
    else if tfSel == "F2"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf2State.cntN_bull_raw : tf2State.cntN_bear_raw) : (useBullSel ? tf2State.cnt1_bull_raw : tf2State.cnt1_bear_raw)) : ((modSel == "N") ? tf2State.cntN_raw : tf2State.cnt1_raw)
    else if tfSel == "F3"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf3State.cntN_bull_raw : tf3State.cntN_bear_raw) : (useBullSel ? tf3State.cnt1_bull_raw : tf3State.cnt1_bear_raw)) : ((modSel == "N") ? tf3State.cntN_raw : tf3State.cnt1_raw)
    else if tfSel == "F4"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf4State.cntN_bull_raw : tf4State.cntN_bear_raw) : (useBullSel ? tf4State.cnt1_bull_raw : tf4State.cnt1_bear_raw)) : ((modSel == "N") ? tf4State.cntN_raw : tf4State.cnt1_raw)
    else if tfSel == "F5"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf5State.cntN_bull_raw : tf5State.cntN_bear_raw) : (useBullSel ? tf5State.cnt1_bull_raw : tf5State.cnt1_bear_raw)) : ((modSel == "N") ? tf5State.cntN_raw : tf5State.cnt1_raw)
    else if tfSel == "F6"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf6State.cntN_bull_raw : tf6State.cntN_bear_raw) : (useBullSel ? tf6State.cnt1_bull_raw : tf6State.cnt1_bear_raw)) : ((modSel == "N") ? tf6State.cntN_raw : tf6State.cnt1_raw)
    else if tfSel == "F7"
        cnt := useBullBearCal ? ((modSel == "N") ? (useBullSel ? tf7State.cntN_bull_raw : tf7State.cntN_bear_raw) : (useBullSel ? tf7State.cnt1_bull_raw : tf7State.cnt1_bear_raw)) : ((modSel == "N") ? tf7State.cntN_raw : tf7State.cnt1_raw)

    if not na(cnt)
        total := array.sum(cnt)
    total

f_get_state_for_tf(tfSel) =>
    TfState st = na
    if tfSel == "F1"
        st := tf1State
    else if tfSel == "F2"
        st := tf2State
    else if tfSel == "F3"
        st := tf3State
    else if tfSel == "F4"
        st := tf4State
    else if tfSel == "F5"
        st := tf5State
    else if tfSel == "F6"
        st := tf6State
    else if tfSel == "F7"
        st := tf7State
    st

f_eval_metrics_for_tf(tfSel) =>
    st = f_get_state_for_tf(tfSel)
    if na(st)
        [float(na), float(na), float(na)]
    else
        if evalWhichHead == "N"
            [_bAvg, _lAvg, ece, _mErr, _wS, _wL, drift, nSc] = f_eval_stats_one(st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN)
            [ece, drift * 100.0, nSc]
        else
            [_bAvg, _lAvg, ece, _mErr, _wS, _wL, drift, nSc] = f_eval_stats_one(st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1)
            [ece, drift * 100.0, nSc]


// Rel-value arrays (source of truth for gate/table)
var float[] relPUN  = array.new_float(7, na)
var float[] relPFN  = array.new_float(7, na)
var float[] relPDN  = array.new_float(7, na)
var float[] relNN   = array.new_float(7, na)
var float[] relTotN = array.new_float(7, na)
var float[] relPU1  = array.new_float(7, na)
var float[] relPF1  = array.new_float(7, na)
var float[] relPD1  = array.new_float(7, na)
var float[] relN1   = array.new_float(7, na)
var float[] relTot1 = array.new_float(7, na)

f_tf_index(tfSel) =>
    tfSel == "F1" ? 0 : tfSel == "F2" ? 1 : tfSel == "F3" ? 2 : tfSel == "F4" ? 3 : tfSel == "F5" ? 4 : tfSel == "F6" ? 5 : 6

f_idx_to_tfsel(idx) =>
    idx == 0 ? "F1" : idx == 1 ? "F2" : idx == 2 ? "F3" : idx == 3 ? "F4" : idx == 4 ? "F5" : idx == 5 ? "F6" : "F7"

f_find_tf_idx(tf, tfArr) =>
    int idx = -1
    for i = 0 to array.size(tfArr) - 1
        if array.get(tfArr, i) == tf
            idx := i
            break
    idx

f_get_rel_vals(tfSel, modSel) =>
    float pU = na
    float pF = na
    float pD = na
    float nBin = na
    float total = na
    idx = f_tf_index(tfSel)
    if modSel == "N"
        pU := array.get(relPUN, idx)
        pF := array.get(relPFN, idx)
        pD := array.get(relPDN, idx)
        nBin := array.get(relNN, idx)
        total := array.get(relTotN, idx)
    else
        pU := array.get(relPU1, idx)
        pF := array.get(relPF1, idx)
        pD := array.get(relPD1, idx)
        nBin := array.get(relN1, idx)
        total := array.get(relTot1, idx)
    [pU, pF, pD, nBin, total]

f_edges3(pU, pF, pD) =>
    [pU - pF, pU - pD, pD - pF, pD - pU]

// Decision quality helper (used by forecast gate and decision banners)
f_decision_quality(pU, pF, pD, nBin, total) =>
    if not use3Way
        [false, "3-way off", color.gray, na]
    else
        // Handle warmup / NA safely
        if na(pU) or na(pF) or na(pD) or na(nBin) or na(total)
            [false, "n/a", color.orange, na]
        else
            maxP = math.max(pU, math.max(pF, pD))
            tieEps = 1e-10
            isMaxU = math.abs(pU - maxP) <= tieEps
            isMaxF = math.abs(pF - maxP) <= tieEps
            isMaxD = math.abs(pD - maxP) <= tieEps
            dir = (isMaxU and not (isMaxF or isMaxD)) ? 1 : (isMaxD and not (isMaxU or isMaxF)) ? -1 : 0
            edgeFlat = dir == 1 ? (pU - pF) : dir == -1 ? (pD - pF) : 0.0
            edgeOpp  = dir == 1 ? (pU - pD) : dir == -1 ? (pD - pU) : 0.0
            edge = dir == 0 ? na : math.min(edgeFlat, edgeOpp)

            binOk   = (tradeMinBinSamples <= 0) or (nBin >= tradeMinBinSamples)
            totalOk = (tradeMinTotalSamples <= 0) or (total >= tradeMinTotalSamples)
            edgeOk  = (dir != 0) and edge >= abstainMinEdge

            ok = edgeOk and binOk and totalOk

            reason =
                 (tradeMinTotalSamples > 0 and total < tradeMinTotalSamples) ? "Low Total" :
                 (tradeMinBinSamples   > 0 and nBin  < tradeMinBinSamples)   ? "Weak Bin" :
                 (dir == 0)                                                  ? "Flat" :
                 (edge < abstainMinEdge)                                    ? "Low Edge" :
                 "OK"

            col = ok ? color.lime : color.orange
            [ok, reason, col, edge]

//====================
// Signal execution layer
//====================

// Trend regime
atrNormHere = atr / math.max(close, 0.0001)
trendReg = f_trend_regime(emaF, emaS, atrNormHere)
trendUp  = trendReg == 1.0
trendDn  = trendReg == -1.0
trendSide = trendReg == 0.0

// D1 â€“ Smooth trend strength (continuous [-1, 1] alternative)
trendStrength = f_trend_strength(emaF, emaS)
trendUpSmooth  = useSmoothTrend ? trendStrength > TREND_SMOOTH_THRESH : trendUp
trendDnSmooth  = useSmoothTrend ? trendStrength < -TREND_SMOOTH_THRESH : trendDn

// D2 â€“ ADX trend strength filter
[diPlus, diMinus, adxRaw] = ta.dmi(adxLen, adxLen)
adxOk = (not useAdx) or (not na(adxRaw) and adxRaw >= adxThresh)

// B2 â€“ ROC momentum score at signal layer
rocScore = f_roc_score(close, rocLen)
rocLongOk  = wRoc == 0 or rocScore > 0.0
rocShortOk = wRoc == 0 or rocScore < 0.0

// B4 â€“ Volume score at signal layer
volScore = f_vol_score(volume, volEnsLen)
volEnsLongOk  = wVol == 0 or volScore > -0.3
volEnsShortOk = wVol == 0 or volScore > -0.3  // symmetric: both sides reject depressed volume

//====================
// Risk Helpers
//====================

var float stopPx  = na
var float tpPx    = na
var float trailPx = na
var bool  isBeHit = false // Track if Breakeven triggered
var int   enBar   = 0     // Track Entry Bar Index for Stalemate

// Calculate risk levels on entry; returns updated stop/tp/trail
f_set_risk_on_entry(isLong, entry, atrNow) =>
    float stopOut  = isLong ? (entry - stopATR * atrNow) : (entry + stopATR * atrNow)
    float tpOut    = isLong ? (entry + tpATR   * atrNow) : (entry - tpATR   * atrNow)
    float trailOut = na
    [stopOut, tpOut, trailOut]

// Update trailing stop; returns updated trail
f_update_trail(isLong, entry, atrNow, stopVal, trailVal) =>
    // activate trailing only after reaching +R
    denom = math.max(math.abs(entry - stopVal), PRICE_EPS)
    rNow = isLong ? ((close - entry) / denom) : ((entry - close) / denom)
    float trailOut = trailVal
    if rNow >= trailAfterR
        float trailCandidate = isLong ? (close - trailATR * atrNow) : (close + trailATR * atrNow)
        trailOut := na(trailOut) ? trailCandidate : (isLong ? math.max(trailOut, trailCandidate) : math.min(trailOut, trailCandidate))
    trailOut

f_risk_exit_hit(isLong, stopVal, tpVal, trailVal) =>
    if not useAtrRisk or na(stopVal)
        [false, ""]
    else
        stopHit  = isLong ? (low <= stopVal) : (high >= stopVal)
        tpHit    = not na(tpVal) and (isLong ? (high >= tpVal)  : (low  <= tpVal))
        trailHit = not na(trailVal) and (isLong ? (low <= trailVal) : (high >= trailVal))
        
        // Optimistic Exit Priority on Favorable Candles (TP wins if bar closed in profit)
        bool favorableClose = isLong ? (close > open) : (close < open)
        // If TP hit and bar looks strong, assume TP happened before any deep wick
        bool priorityTP = tpHit and favorableClose

        // standard: stop wins if both in same bar (unless optimistic priority)
        hit = priorityTP ? true : (stopHit or trailHit or tpHit)
        // Priority logic
        msg = priorityTP ? "TP" : stopHit ? "SL" : trailHit ? "Trail" : tpHit ? "TP" : ""
        [hit, msg]

//====================
// Outlook/Forecast packs (one security call per horizon TF)
//====================
[t1, c1, h1, l1, ef1, es1, r1, a1, vR1, conf1] = f_tf_pack(tfF1)
[t2, c2, h2, l2, ef2, es2, r2, a2, vR2, conf2] = f_tf_pack(tfF2)
[t3, c3, h3, l3, ef3, es3, r3, a3, vR3, conf3] = f_tf_pack(tfF3)
[t4, c4, h4, l4, ef4, es4, r4, a4, vR4, conf4] = f_tf_pack(tfF4)
[t5, c5, h5, l5, ef5, es5, r5, a5, vR5, conf5] = f_tf_pack(tfF5)
[t6, c6, h6, l6, ef6, es6, r6, a6, vR6, conf6] = f_tf_pack(tfF6)
[t7, c7, h7, l7, ef7, es7, r7, a7, vR7, conf7] = f_tf_pack(tfF7)

// Get Target Params per TF
[fcT1, kB1, aT1, pH1, tp1, sl1] = f_get_params(tfF1)
[fcT2, kB2, aT2, pH2, tp2, sl2] = f_get_params(tfF2)
[fcT3, kB3, aT3, pH3, tp3, sl3] = f_get_params(tfF3)
[fcT4, kB4, aT4, pH4, tp4, sl4] = f_get_params(tfF4)
[fcT5, kB5, aT5, pH5, tp5, sl5] = f_get_params(tfF5)
[fcT6, kB6, aT6, pH6, tp6, sl6] = f_get_params(tfF6)
[fcT7, kB7, aT7, pH7, tp7, sl7] = f_get_params(tfF7)

tfCloseF1 = conf1
tfCloseF2 = conf2
tfCloseF3 = conf3
tfCloseF4 = conf4
tfCloseF5 = conf5
tfCloseF6 = conf6
tfCloseF7 = conf7

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

[t1c, m1c, l1c] = f_state_tml(c1, ef1, es1, r1)
[t2c, m2c, l2c] = f_state_tml(c2, ef2, es2, r2)
[t3c, m3c, l3c] = f_state_tml(c3, ef3, es3, r3)
[t4c, m4c, l4c] = f_state_tml(c4, ef4, es4, r4)
[t5c, m5c, l5c] = f_state_tml(c5, ef5, es5, r5)
[t6c, m6c, l6c] = f_state_tml(c6, ef6, es6, r6)
[t7c, m7c, l7c] = f_state_tml(c7, ef7, es7, r7)

tfForecastArr = array.from(tfF1, tfF2, tfF3, tfF4, tfF5, tfF6, tfF7)
tForecastArr = array.from(t1, t2, t3, t4, t5, t6, t7)
cForecastArr = array.from(c1, c2, c3, c4, c5, c6, c7)
hForecastArr = array.from(h1, h2, h3, h4, h5, h6, h7)
lForecastArr = array.from(l1, l2, l3, l4, l5, l6, l7)
efForecastArr = array.from(ef1, ef2, ef3, ef4, ef5, ef6, ef7)
esForecastArr = array.from(es1, es2, es3, es4, es5, es6, es7)
rForecastArr = array.from(r1, r2, r3, r4, r5, r6, r7)
aForecastArr = array.from(a1, a2, a3, a4, a5, a6, a7)
vRForecastArr = array.from(vR1, vR2, vR3, vR4, vR5, vR6, vR7)
confForecastArr = array.from(conf1, conf2, conf3, conf4, conf5, conf6, conf7)
outScoreArr = array.from(outScore1, outScore2, outScore3, outScore4, outScore5, outScore6, outScore7)
tArr = array.from(t1c, t2c, t3c, t4c, t5c, t6c, t7c)
mArr = array.from(m1c, m2c, m3c, m4c, m5c, m6c, m7c)
lArr = array.from(l1c, l2c, l3c, l4c, l5c, l6c, l7c)

f_entry_forecast_gate(isLong) =>
    bool ok = true
    forecastAllowed = enableForecast and f_forecast_allowed()
    if useForecastGateEntry and use3Way and forecastAllowed
        [pU, pF, pD, nBin, total] = f_get_rel_vals(entryFcTF, entryFcModel)
        binOk   = (tradeMinBinSamples <= 0) or (nBin >= tradeMinBinSamples)
        totalOk = (tradeMinTotalSamples <= 0) or (total >= tradeMinTotalSamples)

        // reliability label from your CI logic (re-used)
        canCal = forecastAllowed and (not na(total) and total > 0)
        relLbl = f_rel_label(isLong ? pU : pD, nBin, total, canCal)
        relOk  = (not requireRelOk) or (relLbl == "ok" or relLbl == "strong")

        [eUf, eUo, eDf, eDo] = f_edges3(pU, pF, pD)

        if requirePathTargetEntry and f_target_for_tf(f_tf_from_horizon(entryFcTF)) != "PathTPvsSL"
            ok := false
        else if isLong
            edgeOk = (not na(eUf) and eUf >= minEdgePP) and (not na(eUo) and eUo >= minEdgePP)
            ok := binOk and totalOk and relOk and (not na(pU) and pU >= minDirProb) and edgeOk
        else
            edgeOk = (not na(eDf) and eDf >= minEdgePP) and (not na(eDo) and eDo >= minEdgePP)
            ok := binOk and totalOk and relOk and (not na(pD) and pD >= minDirProb) and edgeOk

        idxFc = f_tf_index(entryFcTF)
        cSel = array.get(cForecastArr, idxFc)
        efSel = array.get(efForecastArr, idxFc)
        esSel = array.get(esForecastArr, idxFc)
        aSel = array.get(aForecastArr, idxFc)
        confSel = array.get(confForecastArr, idxFc)
        trendSideLocal = (confSel == true) and (f_trend_regime(efSel, esSel, aSel / math.max(cSel, PRICE_EPS)) == 0.0)
        if useChopAbstain and trendSideLocal and (not na(pF) and pF >= flatAbstainThr)
            ok := false
    ok

// MTF packs (for normalized score access)
[tS1, cS1, hS1, lS1, efS1, esS1, rS1, aS1, vRS1, confS1] = f_tf_pack(tfShort1)
[tS2, cS2, hS2, lS2, efS2, esS2, rS2, aS2, vRS2, confS2] = f_tf_pack(tfShort2)
[tS3, cS3, hS3, lS3, efS3, esS3, rS3, aS3, vRS3, confS3] = f_tf_pack(tfShort3)
[tM1, cM1, hM1, lM1, efM1, esM1, rM1, aM1, vRM1, confM1] = f_tf_pack(tfMedium1)
[tM2, cM2, hM2, lM2, efM2, esM2, rM2, aM2, vRM2, confM2] = f_tf_pack(tfMedium2)
[tM3, cM3, hM3, lM3, efM3, esM3, rM3, aM3, vRM3, confM3] = f_tf_pack(tfMedium3)
[tL1, cL1, hL1, lL1, efL1, esL1, rL1, aL1, vRL1, confL1] = f_tf_pack(tfLong1)
[tL2, cL2, hL2, lL2, efL2, esL2, rL2, aL2, vRL2, confL2] = f_tf_pack(tfLong2)
[tL3, cL3, hL3, lL3, efL3, esL3, rL3, aL3, vRL3, confL3] = f_tf_pack(tfLong3)

tfMtfArr = array.from(tfShort1, tfShort2, tfShort3, tfMedium1, tfMedium2, tfMedium3, tfLong1, tfLong2, tfLong3)
cMtfArr = array.from(cS1, cS2, cS3, cM1, cM2, cM3, cL1, cL2, cL3)
efMtfArr = array.from(efS1, efS2, efS3, efM1, efM2, efM3, efL1, efL2, efL3)
esMtfArr = array.from(esS1, esS2, esS3, esM1, esM2, esM3, esL1, esL2, esL3)
rMtfArr = array.from(rS1, rS2, rS3, rM1, rM2, rM3, rL1, rL2, rL3)

outSym(score) => score > SCORE_NEUTRAL_BAND ? "â–²" : score < -SCORE_NEUTRAL_BAND ? "â–¼" : "âˆ’"
outCol(score) => score > SCORE_NEUTRAL_BAND ? color.lime : score < -SCORE_NEUTRAL_BAND ? color.red : tblText

isBull1 = f_is_bull_bias(outScore1, ef1, es1)
isBull2 = f_is_bull_bias(outScore2, ef2, es2)
isBull3 = f_is_bull_bias(outScore3, ef3, es3)
isBull4 = f_is_bull_bias(outScore4, ef4, es4)
isBull5 = f_is_bull_bias(outScore5, ef5, es5)
isBull6 = f_is_bull_bias(outScore6, ef6, es6)
isBull7 = f_is_bull_bias(outScore7, ef7, es7)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= SEC_30M) ? "Short" : (not na(mtfBaseSecs) and mtfBaseSecs <= SEC_4H) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

f_score_tf_cached(tf) =>
    idx = f_find_tf_idx(tf, tfForecastArr)
    if idx >= 0
        f_score_tf(array.get(cForecastArr, idx), array.get(efForecastArr, idx), array.get(esForecastArr, idx), array.get(rForecastArr, idx))
    else
        idxM = f_find_tf_idx(tf, tfMtfArr)
        idxM >= 0 ? f_score_tf(array.get(cMtfArr, idxM), array.get(efMtfArr, idxM), array.get(esMtfArr, idxM), array.get(rMtfArr, idxM)) : na

getVoteScore() =>
    float sum = 0.0
    float wgt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    // Weight higher timeframes more (tf3 > tf2 > tf1 by convention)
    if f_is_tf_higher_or_equal(tf1)
        sum += 1.0 * f_score_tf_cached(tf1)
        wgt += 1.0
    if f_is_tf_higher_or_equal(tf2)
        sum += 1.5 * f_score_tf_cached(tf2)
        wgt += 1.5
    if f_is_tf_higher_or_equal(tf3)
        sum += 2.0 * f_score_tf_cached(tf3)
        wgt += 2.0

    wgt == 0 ? 0.0 : sum / wgt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > SCORE_NEUTRAL_BAND)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -SCORE_NEUTRAL_BAND)

// Per-horizon bin arrays (unrolled â€” Pine v6 does not support array-of-arrays)
cntN1Arr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull : tf1State.cntN_bear) : tf1State.cntN
cnt11Arr = useBullBearCal ? (isBull1 ? tf1State.cnt1_bull : tf1State.cnt1_bear) : tf1State.cnt1
cntN2Arr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull : tf2State.cntN_bear) : tf2State.cntN
cnt12Arr = useBullBearCal ? (isBull2 ? tf2State.cnt1_bull : tf2State.cnt1_bear) : tf2State.cnt1
cntN3Arr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull : tf3State.cntN_bear) : tf3State.cntN
cnt13Arr = useBullBearCal ? (isBull3 ? tf3State.cnt1_bull : tf3State.cnt1_bear) : tf3State.cnt1
cntN4Arr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull : tf4State.cntN_bear) : tf4State.cntN
cnt14Arr = useBullBearCal ? (isBull4 ? tf4State.cnt1_bull : tf4State.cnt1_bear) : tf4State.cnt1
cntN5Arr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull : tf5State.cntN_bear) : tf5State.cntN
cnt15Arr = useBullBearCal ? (isBull5 ? tf5State.cnt1_bull : tf5State.cnt1_bear) : tf5State.cnt1
cntN6Arr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull : tf6State.cntN_bear) : tf6State.cntN
cnt16Arr = useBullBearCal ? (isBull6 ? tf6State.cnt1_bull : tf6State.cnt1_bear) : tf6State.cnt1
cntN7Arr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull : tf7State.cntN_bear) : tf7State.cntN
cnt17Arr = useBullBearCal ? (isBull7 ? tf7State.cnt1_bull : tf7State.cnt1_bear) : tf7State.cnt1

cntN1RawArr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull_raw : tf1State.cntN_bear_raw) : tf1State.cntN_raw
cnt11RawArr = useBullBearCal ? (isBull1 ? tf1State.cnt1_bull_raw : tf1State.cnt1_bear_raw) : tf1State.cnt1_raw
cntN2RawArr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull_raw : tf2State.cntN_bear_raw) : tf2State.cntN_raw
cnt12RawArr = useBullBearCal ? (isBull2 ? tf2State.cnt1_bull_raw : tf2State.cnt1_bear_raw) : tf2State.cnt1_raw
cntN3RawArr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull_raw : tf3State.cntN_bear_raw) : tf3State.cntN_raw
cnt13RawArr = useBullBearCal ? (isBull3 ? tf3State.cnt1_bull_raw : tf3State.cnt1_bear_raw) : tf3State.cnt1_raw
cntN4RawArr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull_raw : tf4State.cntN_bear_raw) : tf4State.cntN_raw
cnt14RawArr = useBullBearCal ? (isBull4 ? tf4State.cnt1_bull_raw : tf4State.cnt1_bear_raw) : tf4State.cnt1_raw
cntN5RawArr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull_raw : tf5State.cntN_bear_raw) : tf5State.cntN_raw
cnt15RawArr = useBullBearCal ? (isBull5 ? tf5State.cnt1_bull_raw : tf5State.cnt1_bear_raw) : tf5State.cnt1_raw
cntN6RawArr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull_raw : tf6State.cntN_bear_raw) : tf6State.cntN_raw
cnt16RawArr = useBullBearCal ? (isBull6 ? tf6State.cnt1_bull_raw : tf6State.cnt1_bear_raw) : tf6State.cnt1_raw
cntN7RawArr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull_raw : tf7State.cntN_bear_raw) : tf7State.cntN_raw
cnt17RawArr = useBullBearCal ? (isBull7 ? tf7State.cnt1_bull_raw : tf7State.cnt1_bear_raw) : tf7State.cnt1_raw

//====================
// Calibration storage â€” per horizon TF (Removed - moved to top)
//====================
// (Moved to top level state)

//====================
// Reset handling (rising edge) â€” per horizon F1..F7
//====================
f_is_chart_tf(tf) =>
    timeframe.period == tf

var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All"
        f_reset_eval_all()
        f_reset_tf(tf1State)
        f_reset_tf(tf2State)
        f_reset_tf(tf3State)
        f_reset_tf(tf4State)
        f_reset_tf(tf5State)
        f_reset_tf(tf6State)
        f_reset_tf(tf7State)

    if resetWhich == "F1" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF1))
        f_reset_tf(tf1State)
    if resetWhich == "F2" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF2))
        f_reset_tf(tf2State)
    if resetWhich == "F3" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF3))
        f_reset_tf(tf3State)
    if resetWhich == "F4" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF4))
        f_reset_tf(tf4State)
    if resetWhich == "F5" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF5))
        f_reset_tf(tf5State)
    if resetWhich == "F6" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF6))
        f_reset_tf(tf6State)
    if resetWhich == "F7" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF7))
        f_reset_tf(tf7State)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed and f_forecast_allowed() and (calibrateInBackground or showTable or showEvalSection)
if doCal
    for i = 0 to 6
        tfSel = f_idx_to_tfsel(i)
        tfH = array.get(tfForecastArr, i)
        [fc, kb, at, ph, tp, sl] = f_get_params(tfH)
        st = f_get_state_for_tf(tfSel)
        if not na(st)
            f_process_tf(i + 1, tfH, array.get(confForecastArr, i), array.get(outScoreArr, i), array.get(cForecastArr, i), array.get(hForecastArr, i), array.get(lForecastArr, i), array.get(aForecastArr, i), array.get(vRForecastArr, i), array.get(efForecastArr, i), array.get(esForecastArr, i),
                st,
                fc, kb, at, ph, tp, sl,
                alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

// NOTE: f_get_disp_vals reads global inputs: wState, wPullback, wRegime,
//       wTrend, predBinsN, predBins1, dim2Bins, useBullBearCal, alphaN,
//       alpha1, kShrink, kShrinkReg, calMinSamples.  Pine's 14-param limit
//       prevents passing these explicitly.
f_get_disp_vals(_tf, sA, c, atrVal, ef, es, vr, TfState st) =>
    bias = ef > es ? 1 : ef < es ? -1 : 0
    sB = f_pullback_score(c, ef, es, bias)
    sC = vr >= VOL_THRESH_HIGH ? -1.0 : (vr <= VOL_THRESH_LOW ? 1.0 : 0.0)
    // Epsilon PRICE_EPS prevents division by zero on penny stocks or exotic instruments
    atrNorm = atrVal / math.max(c, PRICE_EPS)
    sD = f_trend_regime(ef, es, atrNorm)
    sEns = f_ensemble4(sA, sB, sC, sD, wState, wPullback, wRegime, wTrend)
    if na(sEns) or na(sD)
        [pUpr_t, pFpr_t, pDpr_t] = f_prior3(_tf, sA)
        [pUpr_t, pFpr_t, pDpr_t, 0.0, pUpr_t, pFpr_t, pDpr_t, 0.0]
    else
        bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, st.qCutsN)
        b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, st.qCuts1)
        biasSel = useBullBearCal ? f_bias_from_score(sA) : 0
        if biasSel == 0
            biasSel := bias == 0 ? 1 : bias
        cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        upN_sel  = useBullBearCal ? (biasSel > 0 ? st.upN_bull  : st.upN_bear)  : st.upN
        dnN_sel  = useBullBearCal ? (biasSel > 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
        cnt1_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
        up1_sel  = useBullBearCal ? (biasSel > 0 ? st.up1_bull  : st.up1_bear)  : st.up1
        dn1_sel  = useBullBearCal ? (biasSel > 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1
        cntN_raw_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull_raw : st.cntN_bear_raw) : st.cntN_raw
        cnt1_raw_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull_raw : st.cnt1_bear_raw) : st.cnt1_raw
        tempN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
        temp1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
        vecAN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
        vecBN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
        vecA1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
        vecB1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1
        [pUN_t, pFN_t, pDN_t, nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaN, kShrink, kShrinkReg)
        [pU1_t, pF1_t, pD1_t, n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1, kShrink, kShrinkReg)
        pUN = pUN_t
        pFN = pFN_t
        pDN = pDN_t
        nN = array.get(cntN_raw_sel, bN)
        pU1 = pU1_t
        pF1 = pF1_t
        pD1 = pD1_t
        n1 = array.get(cnt1_raw_sel, b1)
        useCalN = f_can_cal3(nN_t)
        useCal1 = f_can_cal3(n1_t)
        if useCalN
            zUN = f_safe_log(pUN)
            zFN = f_safe_log(pFN)
            zDN = f_safe_log(pDN)
            [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, tempN_sel, vecAN_sel, vecBN_sel)
            pUN := tUN_t
            pFN := tFN_t
            pDN := tDN_t
        if useCal1
            zU1 = f_safe_log(pU1)
            zF1 = f_safe_log(pF1)
            zD1 = f_safe_log(pD1)
            [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, temp1_sel, vecA1_sel, vecB1_sel)
            pU1 := tU1_t
            pF1 := tF1_t
            pD1 := tD1_t
        if nN < calMinSamples
            [pUpr_t, pFpr_t, pDpr_t] = f_prior3(_tf, sA)
            [pUN_b, pFN_b, pDN_b] = f_blend_prior(pUN, pFN, pDN, pUpr_t, pFpr_t, pDpr_t, nN)
            pUN := pUN_b
            pFN := pFN_b
            pDN := pDN_b
        if n1 < calMinSamples
            [pUpr2_t, pFpr2_t, pDpr2_t] = f_prior3(_tf, sA)
            [pU1_b, pF1_b, pD1_b] = f_blend_prior(pU1, pF1, pD1, pUpr2_t, pFpr2_t, pDpr2_t, n1)
            pU1 := pU1_b
            pF1 := pF1_b
            pD1 := pD1_b
        [pUN, pFN, pDN, nN, pU1, pF1, pD1, n1]

//====================
// Display values â€” N and 1 per horizon
//====================
var float[] dispPUN = array.new_float(7, na)
var float[] dispPFN = array.new_float(7, na)
var float[] dispPDN = array.new_float(7, na)
var float[] dispNN  = array.new_float(7, na)
var float[] dispPU1 = array.new_float(7, na)
var float[] dispPF1 = array.new_float(7, na)
var float[] dispPD1 = array.new_float(7, na)
var float[] dispN1  = array.new_float(7, na)

for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    tfH = array.get(tfForecastArr, i)
    st = f_get_state_for_tf(tfSel)
    if not na(st)
        [pUN_t, pFN_t, pDN_t, nN_t, pU1_t, pF1_t, pD1_t, n1_t] = f_get_disp_vals(tfH, array.get(outScoreArr, i), array.get(cForecastArr, i), array.get(aForecastArr, i), array.get(efForecastArr, i), array.get(esForecastArr, i), array.get(vRForecastArr, i), st)
        array.set(dispPUN, i, pUN_t)
        array.set(dispPFN, i, pFN_t)
        array.set(dispPDN, i, pDN_t)
        array.set(dispNN,  i, nN_t)
        array.set(dispPU1, i, pU1_t)
        array.set(dispPF1, i, pF1_t)
        array.set(dispPD1, i, pD1_t)
        array.set(dispN1,  i, n1_t)

// --- Total resolved samples per TF (across all bins)
totNArr = array.new_float(7, na)
tot1Arr = array.new_float(7, na)
for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    cntN = f_sel_tf_farr(tfSel, cntN1Arr, cntN2Arr, cntN3Arr, cntN4Arr, cntN5Arr, cntN6Arr, cntN7Arr)
    cnt1 = f_sel_tf_farr(tfSel, cnt11Arr, cnt12Arr, cnt13Arr, cnt14Arr, cnt15Arr, cnt16Arr, cnt17Arr)
    array.set(totNArr, i, f_sum_int_array(cntN))
    array.set(tot1Arr, i, f_sum_int_array(cnt1))


// Populate rel-value arrays for gating/table (current bar)

for i = 0 to 6
    array.set(relPUN,  i, array.get(dispPUN, i))
    array.set(relPFN,  i, array.get(dispPFN, i))
    array.set(relPDN,  i, array.get(dispPDN, i))
    array.set(relNN,   i, array.get(dispNN, i))
    array.set(relTotN, i, array.get(totNArr, i))
    array.set(relPU1,  i, array.get(dispPU1, i))
    array.set(relPF1,  i, array.get(dispPF1, i))
    array.set(relPD1,  i, array.get(dispPD1, i))
    array.set(relN1,   i, array.get(dispN1, i))
    array.set(relTot1, i, array.get(tot1Arr, i))

// calibration â€œenabled for displayâ€ if forecast enabled + we have any resolved samples in that TF
totFNArr = array.new_float(7, na)
totF1Arr = array.new_float(7, na)
isBullArr2 = array.from(isBull1, isBull2, isBull3, isBull4, isBull5, isBull6, isBull7)

for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    useBull = array.get(isBullArr2, i)
    array.set(totFNArr, i, f_get_total_samples(tfSel, "N", useBull))
    array.set(totF1Arr, i, f_get_total_samples(tfSel, "1", useBull))

totF1N = array.get(totFNArr, 0)
totF2N = array.get(totFNArr, 1)
totF3N = array.get(totFNArr, 2)
totF4N = array.get(totFNArr, 3)
totF5N = array.get(totFNArr, 4)
totF6N = array.get(totFNArr, 5)
totF7N = array.get(totFNArr, 6)
totF11 = array.get(totF1Arr, 0)
totF12 = array.get(totF1Arr, 1)
totF13 = array.get(totF1Arr, 2)
totF14 = array.get(totF1Arr, 3)
totF15 = array.get(totF1Arr, 4)
totF16 = array.get(totF1Arr, 5)
totF17 = array.get(totF1Arr, 6)

forecastAllowed = enableForecast and f_forecast_allowed()

canFNArr = array.new_bool(7, false)
canF1Arr = array.new_bool(7, false)
for i = 0 to 6
    totN = array.get(totFNArr, i)
    tot1 = array.get(totF1Arr, i)
    array.set(canFNArr, i, forecastAllowed and (not na(totN) and totN > 0))
    array.set(canF1Arr, i, forecastAllowed and (not na(tot1) and tot1 > 0))

canF1N = array.get(canFNArr, 0)
canF2N = array.get(canFNArr, 1)
canF3N = array.get(canFNArr, 2)
canF4N = array.get(canFNArr, 3)
canF5N = array.get(canFNArr, 4)
canF6N = array.get(canFNArr, 5)
canF7N = array.get(canFNArr, 6)

canF11 = array.get(canF1Arr, 0)
canF12 = array.get(canF1Arr, 1)
canF13 = array.get(canF1Arr, 2)
canF14 = array.get(canF1Arr, 3)
canF15 = array.get(canF1Arr, 4)
canF16 = array.get(canF1Arr, 5)
canF17 = array.get(canF1Arr, 6)

curBrierRaw = f_getBrier_raw(relFilterTF, relFilterModel)
curBrier = nz(curBrierRaw, 0.5)
relBull = relFilterTF == "F1" ? isBull1 : relFilterTF == "F2" ? isBull2 : relFilterTF == "F3" ? isBull3 : relFilterTF == "F4" ? isBull4 : relFilterTF == "F5" ? isBull5 : relFilterTF == "F6" ? isBull6 : isBull7
totSamp = f_get_total_samples(relFilterTF, relFilterModel, relBull)
reliabilityOk = (not forecastAllowed) or (not useRelFilter) or (not na(curBrierRaw) and not na(totSamp) and totSamp > 0 and curBrierRaw <= maxBrier)
evidenceOk = (not forecastAllowed) or (not evidenceGate) or (not na(totSamp) and totSamp >= evidenceMinTotal)

[pRelU_t, pRelF_t, pRelD_t, nRel_t, totRel_t] = f_get_rel_vals(relFilterTF, relFilterModel)
pRelU = pRelU_t
pRelF = pRelF_t
pRelD = pRelD_t
nRel  = nRel_t
totRel = totRel_t

[decisionOk_t, decisionLabel_t, decisionColor_t, decisionEdge_t] = f_decision_quality(pRelU, pRelF, pRelD, nRel, totRel)
decisionOk = decisionOk_t
decisionLabel = decisionLabel_t
decisionColor = decisionColor_t
decisionEdge = decisionEdge_t
decisionEdgeTxt = (not use3Way or na(decisionEdge)) ? "â€”" : str.tostring(decisionEdge * 100.0, "#.1") + "pp"

[evalEce, evalDriftPP, evalN] = f_eval_metrics_for_tf(relFilterTF)
// A5 â€“ store ECE for next bar's recal decision
prevEvalEce := evalEce
eceOk = (not useEceGate) or (not na(evalEce) and evalEce <= eceMax)
driftOk = (not useDriftGate) or (not na(evalDriftPP) and math.abs(evalDriftPP) <= driftMaxPP)
evalOk = (not forecastAllowed) or (eceOk and driftOk)
evalSoftHit = useEvalPenalty and ((not na(evalEce) and evalEce >= eceWarn) or (not na(evalDriftPP) and math.abs(evalDriftPP) >= driftWarnPP))
confGate = evalSoftHit ? f_clamp01(confidence * (1.0 - evalPenalty)) : confidence

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown (+ eval penalty)
// Fail-closed coercions: any na => deny
confOk      = (not na(confGate)) and (confGate >= minTrust)
ddOk        = (ddHardGateHit == false)
mtfOkLong_  = (mtfOkLong == true)
mtfOkShort_ = (mtfOkShort == true)
macOkLong_  = (macroGateLong == true)
macOkShort_ = (macroGateShort == true)

gateLongNow  = confOk and mtfOkLong_  and macOkLong_  and ddOk
gateShortNow = confOk and mtfOkShort_ and macOkShort_ and ddOk

decisionOkSafe     = (not use3Way) ? true : (decisionOk == true)
cooldownOkSafe     = (cooldownOk == true)
nearCloseOk        = (blockNearClose == false)

// Session Check
inSession = (not useSessionFilter) or (not na(time(timeframe.period, sessionWin)))

allowEntry =
     inSession
 and barstate.isconfirmed
 and cooldownOkSafe
 and nearCloseOk
 and (reliabilityOk == true)
 and (evidenceOk == true)
 and (evalOk == true)
 and (not abstainGate or decisionOkSafe)

allowExit = barstate.isconfirmed

// Initialize signal flags
buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false


//====================
// Table helpers MUST be global (cannot be defined inside if-block)
//====================
var table gT = na
if na(gT)
    tblCols = 10
    tblRows = 17
    gT := table.new(position.middle_right, tblCols, tblRows, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

f_status_row(lbl, val, rRow, valCol) =>
    table.cell(gT, 0, rRow, lbl, text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, rRow, val, text_color=valCol, bgcolor=tblCell, text_size=size.tiny)

f_bin_quality(pTop, nBin) =>
    if nBin <= 0
        ["warmup", tblTextDim]
    else if nBin < calMinSamples
        ["warmup", tblTextDim]
    else
        hw = f_ci95_halfwidth(pTop, nBin)
        lbl = na(hw) ? "warmup" : hw <= HW_STRONG ? "strong" : hw <= HW_OK ? "ok" : "weak"
        col = na(hw) ? tblTextDim : hw <= HW_STRONG ? color.lime : hw <= HW_OK ? color.yellow : color.orange
        [lbl, col]

f_rowTF(_tf, score, tC, mC, lC, rV,
    pUN, pFN, pDN, nBin, nTot, nBin1,
        rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(_tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 1, rRow, outSym(score),  text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, rRow, str.tostring(tC) + "/" + str.tostring(mC) + "/" + str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    enabled = forecastAllowed
    useCalN = enabled and (nBin >= calMinSamples)
    [pUprio_t, pFprio_t, pDprio_t] = f_prior3(_tf, score)
    pUprio = pUprio_t
    pFprio = pFprio_t
    pDprio = pDprio_t
    pU = useCalN ? pUN : pUprio
    pF = useCalN ? pFN : pFprio
    pD = useCalN ? pDN : pDprio

    maxP = math.max(pU, math.max(pF, pD))
    tieEps = 1e-10
    isMaxU = math.abs(pU - maxP) <= tieEps
    isMaxF = math.abs(pF - maxP) <= tieEps
    isMaxD = math.abs(pD - maxP) <= tieEps
    dirSym = maxP < dirMinProb ? "Â·" : (isMaxU and not (isMaxF or isMaxD)) ? "â–²" : (isMaxD and not (isMaxU or isMaxF)) ? "â–¼" : "â– "
    dirCol = (isMaxU and not (isMaxF or isMaxD)) ? color.lime : (isMaxD and not (isMaxU or isMaxF)) ? color.red : color.yellow

    table.cell(gT, 5, rRow, dirSym, text_color=dirCol, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 6, rRow, str.tostring(pU * 100, "#.0") + "%", text_color=color.lime, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 7, rRow, str.tostring(pF * 100, "#.0") + "%", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 8, rRow, str.tostring(pD * 100, "#.0") + "%", text_color=color.red, bgcolor=tblCell, text_size=size.tiny)

    [qLbl_t, qCol_t] = f_bin_quality(maxP, nBin)
    qLbl = qLbl_t
    qCol = qCol_t
    nTxt = "N:" + str.tostring(nBin, "#") + " 1:" + str.tostring(nBin1, "#") // + " " + qLbl
    table.cell(gT, 9, rRow, nTxt, text_color=qCol, bgcolor=tblCell, text_size=size.tiny)

f_rowTF_idx(i, rRow) =>
    f_rowTF(
        array.get(tfForecastArr, i),
        array.get(outScoreArr, i),
        array.get(tArr, i),
        array.get(mArr, i),
        array.get(lArr, i),
        array.get(rForecastArr, i),
        array.get(dispPUN, i),
        array.get(dispPFN, i),
        array.get(dispPDN, i),
        array.get(dispNN, i),
        array.get(totNArr, i),
        array.get(dispN1, i),
        rRow
    )

f_fill_cells(tbl, rRow, cStart, cEnd, txt, txtColor, bgColor, txtSize) =>
    for c = cStart to cEnd
        table.cell(tbl, c, rRow, txt, text_color=txtColor, bgcolor=bgColor, text_size=txtSize)

f_fmtBrier(stats) =>
    s = array.get(stats, 0)
    c = array.get(stats, 1)
    val = c > 0 ? s / c : na
    txt = na(val) ? "â€”" : str.tostring(val, "#.###")
    col = na(val) ? tblTextDim : val < BRIER_GOOD ? color.green : val < BRIER_BASELINE ? color.lime : val < BRIER_POOR ? color.yellow : color.red
    [txt, col]

f_fmtCnt(stats) =>
    c = array.get(stats, 1)
    [str.tostring(c, "#"), c < 10 ? tblTextDim : tblText]

f_rowRel(tf, statsN, stats1, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    
    [tBN_t, cBN_t] = f_fmtBrier(statsN)
    tBN = tBN_t
    cBN = cBN_t
    table.cell(gT, 1, rRow, tBN, text_color=cBN, bgcolor=tblCell, text_size=size.tiny)
    
    [tB1_t, cB1_t] = f_fmtBrier(stats1)
    tB1 = tB1_t
    cB1 = cB1_t
    table.cell(gT, 2, rRow, tB1, text_color=cB1, bgcolor=tblCell, text_size=size.tiny)
    
    [tcN_t, ccN_t] = f_fmtCnt(statsN)
    tcN = tcN_t
    ccN = ccN_t
    table.cell(gT, 3, rRow, tcN, text_color=ccN, bgcolor=tblCell, text_size=size.tiny)
    
    [tc1_t, cc1_t] = f_fmtCnt(stats1)
    tc1 = tc1_t
    cc1 = cc1_t
    table.cell(gT, 4, rRow, tc1, text_color=cc1, bgcolor=tblCell, text_size=size.tiny)

//====================
// Table (10 columns) â€” rendered on confirmed bars (stable)
//====================
mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow
c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblTextDim

renderTable = showTable and barstate.islast and (not tableOnConfirmed or barstate.isconfirmed)
modeTxt = tableOnConfirmed ? "CONF" : "LIVE"
hdrSuffix = ui_tableShowMode ? " â€¢ " + modeTxt : ""
hdrOutlook = "Outlook" + hdrSuffix
hdrForecast = "Forecast" + hdrSuffix

if renderTable
    tblCols = 10
    table.clear(gT, 0, 0, tblCols - 1, 16)

    // Status rows
    table.cell(gT, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(gT, 2, 0, "Decision", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 0, decisionLabel, text_color=decisionColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, 0, decisionEdgeTxt, text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    
    // Configurable display of ATR in previously empty fields
    table.cell(gT, 5, 0, "ATR", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 6, 0, str.tostring(atr, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    
    f_fill_cells(gT, 0, 7, 8, "", tblText, tblCell, size.tiny)
    table.cell(gT, 9, 0, modeTxt, text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)

    f_status_row("MinTrust", str.tostring(minTrust, format.mintick), 1, tblText)
    f_status_row("Volume", volStr, 2, c_vol)
    f_status_row("Strength", strengthStr, 3, c_strength)
    f_status_row("MTF", mtfStr, 4, tblText)
    f_status_row("Pos", posStr, 5, tblText)
    f_status_row("LastSig", lastSig, 6, tblText)
    f_status_row("Time", str.format_time(timenow, "HH:mm"), 7, tblText)

    // Outlook header + forecast columns
    hdrLabels = array.from(hdrOutlook, "Bias", "Score", "T/M/L", "RSI", hdrForecast + "\nDir", "Up%", "Flat%", "Down%", "n(N) | n(1)")
    for c = 0 to 9
        table.cell(gT, c, 8, array.get(hdrLabels, c), text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    for i = 0 to 6
        f_rowTF_idx(i, 9 + i)

    table.cell(gT, 0, 16, f_target_footer_text(), text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny, text_halign=text.align_left)
    f_fill_cells(gT, 16, 1, 9, "", tblTextDim, tblHeader, size.tiny)
    table.merge_cells(gT, 0, 16, 9, 16)


//====================
// Signal Logic (Post-Forecast)
//====================
volSma = ta.sma(volume, volLen)
volOk = (not useVolConfirm) or (not na(volume) and volume > volSma * volMult)

// Global Volume Ratio
float volRatioG = (not na(volume) and not na(volSma) and volSma > 0) ? volume / volSma : 0.0
bool hugeVolG   = volRatioG >= rescueVolMult

// Rescue Logic: Replaced Volume-only trigger with Price Impulse trigger (v6.2)
// User Intent: Prevent falling knife entries on huge bearish volume.
// Require "Considerable Price Increase" (Impulse Candle > 0.7 ATR). Lowered from 1.0 to catch valid signals.
float bodySize = math.abs(close - open)
bool isImpulse = bodySize > (atr * rescueImpulseATR)

bool allowRescueLong  = isImpulse and (close > open) and barstate.isconfirmed and cooldownOk
bool allowRescueShort = isImpulse and (close < open) and barstate.isconfirmed and cooldownOk

// Legacy support (OR logic)
bool allowRescue = (allowRescueLong or allowRescueShort)

// C1 â€“ Pre-signal momentum (RSI alignment)
chartRsi = ta.rsi(close, rsiStateLen)
preMomLongOk  = (not usePreMomentum) or (not na(chartRsi) and chartRsi >= preMomRsiLo)
preMomShortOk = (not usePreMomentum) or (not na(chartRsi) and chartRsi <= preMomRsiHi)

// C3 â€“ EMA acceleration (gap expanding)
emaGap     = math.abs(emaF - emaS) / math.max(close, PRICE_EPS)
emaGapPrev = math.abs(emaF[1] - emaS[1]) / math.max(close[1], PRICE_EPS)
emaAccelLongOk  = (not useEmaAccel) or (emaGap >= emaGapPrev)
emaAccelShortOk = (not useEmaAccel) or (emaGap <= emaGapPrev)

// C4 â€“ VWAP alignment (intraday only; vwapVal computed in Zones section)
vwapLongOk  = (not useVwap) or (not timeframe.isintraday) or (na(vwapVal) or close >= vwapVal)
vwapShortOk = (not useVwap) or (not timeframe.isintraday) or (na(vwapVal) or close <= vwapVal)

fcGateLong  = f_entry_forecast_gate(true)
fcGateShort = f_entry_forecast_gate(false)

// Fetch probabilities for strict ChoCH filtering (Global Scope)
[pU, pF, pD, nBin_prob, total_prob] = f_get_rel_vals(entryFcTF, entryFcModel)

// Pullback depth
pbLow = ta.lowest(low, pbLookback)
pbHigh = ta.highest(high, pbLookback)
pbDepthLong = (emaF - pbLow) / math.max(atr, PRICE_EPS)
pbDepthShort = (pbHigh - emaF) / math.max(atr, PRICE_EPS)

touchEmaF_Long  = low <= emaF and close >= emaF
touchEmaF_Short = high >= emaF and close <= emaF

bullReversal = close > open and close > emaF and low <= emaF
bearReversal = close < open and close < emaF and high >= emaF

setOkLong  = (not requireSET) or setLong
setOkShort = (not requireSET) or setShort

pullbackLongOk  = trendUpSmooth and bullBias and (pbDepthLong >= pbMinATR) and (pbDepthLong <= pbMaxATR) and (close > emaS)
pullbackShortOk = trendDnSmooth and bearBias and (pbDepthShort >= pbMinATR) and (pbDepthShort <= pbMaxATR) and (close < emaS)

// Breakout
var float lastSwingHigh = na
var float lastSwingLow  = na
var int lastSwingHighBar = na
var int lastSwingLowBar  = na
ph = ta.pivothigh(high, swingL, swingR)
pl = ta.pivotlow(low,  swingL, swingR)
if not na(ph)
    lastSwingHigh := ph
    lastSwingHighBar := bar_index
if not na(pl)
    lastSwingLow := pl
    lastSwingLowBar := bar_index
if swingMaxAgeBars > 0
    if not na(lastSwingHighBar) and (bar_index - lastSwingHighBar > swingMaxAgeBars)
        lastSwingHigh := na
        lastSwingHighBar := na
    if not na(lastSwingLowBar) and (bar_index - lastSwingLowBar > swingMaxAgeBars)
        lastSwingLow := na
        lastSwingLowBar := na

// Breakout Logic (Close vs Wick)
bool breakHigh = false
bool breakLow  = false

if breakoutSource == "Close"
    breakHigh := close > lastSwingHigh and close[1] <= lastSwingHigh
    breakLow  := close < lastSwingLow  and close[1] >= lastSwingLow
else // Wick
    if not na(lastSwingHigh)
        breakHigh := ta.crossover(high, lastSwingHigh)
    if not na(lastSwingLow)
        breakLow  := ta.crossunder(low,  lastSwingLow)

breakoutLong  = not na(lastSwingHigh) and breakHigh
breakoutShort = not na(lastSwingLow)  and breakLow

// Liquidity Sweeps (SMC)
bool isSweep_Bull = not na(lastSwingLow) and (low < lastSwingLow) and (close > lastSwingLow)
bool isSweep_Bear = not na(lastSwingHigh) and (high > lastSwingHigh) and (close < lastSwingHigh)
int barsSinceSweep_Bull = ta.barssince(isSweep_Bull)
int barsSinceSweep_Bear = ta.barssince(isSweep_Bear)
bool sweepRecent_Bull = (not na(barsSinceSweep_Bull)) and (barsSinceSweep_Bull <= liqSweepLookback)
bool sweepRecent_Bear = (not na(barsSinceSweep_Bear)) and (barsSinceSweep_Bear <= liqSweepLookback)

// --- Market Structure State (BOS vs ChoCH) ---
var int structState = 0 // 0=Neutral, 1=Bullish, -1=Bearish
bool isChoCH_Long = false
bool isBOS_Long   = false
bool isChoCH_Short = false
bool isBOS_Short   = false

// Long Break Logic
if breakoutLong
    if structState == -1 // Was Bearish -> Reversal
        isChoCH_Long := true
    else // Neutral or Bullish -> Continuation
        isBOS_Long := true
    structState := 1 // Set to Bullish

// Short Break Logic
if breakoutShort
    if structState == 1 // Was Bullish -> Reversal
        isChoCH_Short := true
    else // Neutral or Bearish -> Continuation
        isBOS_Short := true
    structState := -1 // Set to Bearish

// Fail-closed signal subconditions: any na => deny (== true coerces na to false)
fcGateLongSafe  = (fcGateLong == true)
fcGateShortSafe = (fcGateShort == true)
volOkSafe       = (volOk == true)
setOkLongSafe   = (setOkLong == true)
setOkShortSafe  = (setOkShort == true)
pullbackLongOkSafe  = (pullbackLongOk == true)
pullbackShortOkSafe = (pullbackShortOk == true)
touchEmaF_LongSafe  = (touchEmaF_Long == true)
touchEmaF_ShortSafe = (touchEmaF_Short == true)
crossClose_EmaF_upSafe   = (crossClose_EmaF_up == true)
crossClose_EmaF_downSafe = (crossClose_EmaF_down == true)
bullReversalSafe = (bullReversal == true)
bearReversalSafe = (bearReversal == true)
trendUpSafe      = (trendUp == true)
trendDnSafe      = (trendDn == true)
breakoutLongSafe  = (breakoutLong == true)
breakoutShortSafe = (breakoutShort == true)
trendFlipUpSafe   = (trendFlipUp == true)
trendFlipDownSafe = (trendFlipDown == true)
reclaimUpSafe     = (reclaimUp == true)
reclaimDownSafe   = (reclaimDown == true)
adxOkSafe         = (adxOk == true)
rocLongOkSafe     = (rocLongOk == true)
rocShortOkSafe    = (rocShortOk == true)
volEnsLongOkSafe  = (volEnsLongOk == true)
volEnsShortOkSafe = (volEnsShortOk == true)
preMomLongOkSafe  = (preMomLongOk == true)
preMomShortOkSafe = (preMomShortOk == true)
emaAccelLongOkSafe  = (emaAccelLongOk == true)
emaAccelShortOkSafe = (emaAccelShortOk == true)
vwapLongOkSafe    = (vwapLongOk == true)
vwapShortOkSafe   = (vwapShortOk == true)

// Enhancement composite gates
enhLongOk  = adxOkSafe and rocLongOkSafe and volEnsLongOkSafe and preMomLongOkSafe and emaAccelLongOkSafe and vwapLongOkSafe
enhShortOk = adxOkSafe and rocShortOkSafe and volEnsShortOkSafe and preMomShortOkSafe and emaAccelShortOkSafe and vwapShortOkSafe

hybridLongTrigger  = touchEmaF_LongSafe  and (crossClose_EmaF_upSafe   or bullReversalSafe)
hybridShortTrigger = touchEmaF_ShortSafe and (crossClose_EmaF_downSafe or bearReversalSafe)

// Signals
if pos == 0 and (allowEntry or allowRescue)

    // Recency (Global Scope inside loop for safety)
    int barsSinceChoCH_L = ta.barssince(isChoCH_Long)
    bool revRecencyOkL   = (not na(barsSinceChoCH_L)) and (barsSinceChoCH_L <= 5 or volRatioG >= 1.0)
    int barsSinceChoCH_S = ta.barssince(isChoCH_Short)
    bool revRecencyOkS   = (not na(barsSinceChoCH_S)) and (barsSinceChoCH_S <= 5 or volRatioG >= 1.0)

    // Reversal Logic (Global)
    bool probOkGlobal    = (pU >= 0.50)
    bool probOkGlobalS   = (pD >= 0.50)
    
    // SMC Filter: If enabled, requires recent sweep
    // A Reversal Buy requires a Bullish Sweep (Stop Run on Lows)
    // allowRescue (Volume > 1.5x) allows bypassing strict SMC Structure (Restored v6.2)
    // Updated to use allowable rescue Direction (Impulse)
    bool smcOkL = (not useLiqSweep) or sweepRecent_Bull or allowRescueLong
    bool smcOkS = (not useLiqSweep) or sweepRecent_Bear or allowRescueShort
    
    // Global Gate: allowNeuralReversals
    // Reversals bypass MTF (Trend) but MUST respect Safety Gates (Macro + Drawdown) to avoid catching falling knives
    // Added Impulse check to filter "Short Candles" in downtrends
    bool impulseOkL = isImpulse and (close > open)
    bool impulseOkS = isImpulse and (close < open)
    bool revBuyGlobal    = allowNeuralReversals and macOkLong_  and ddOk and (isChoCH_Long or revRecencyOkL) and probOkGlobal and volOk and smcOkL and impulseOkL
    bool revShortGlobal  = allowNeuralReversals and macOkShort_ and ddOk and (isChoCH_Short or revRecencyOkS) and probOkGlobalS and volOk and smcOkS and impulseOkS

    if engine == "Hybrid"
        // Base triggers
        gateBuy   = gateLongNow  and fcGateLongSafe  and volOkSafe and setOkLongSafe  and pullbackLongOkSafe  and hybridLongTrigger  and enhLongOk
        
        // ChoCH Filter (Strict)
        isChoCH_Entry = gateBuy and (structState == -1 or isChoCH_Long) // Currently Bearish OR Just Flipped
        chochFilterOk = (not isChoCH_Entry) or ((pU >= chochMinProb) and (not chochReqVol or volOk))
        
        // REV-BUY (Neural Reversal) injection
        buySignal   := (gateBuy and chochFilterOk) or revBuyGlobal
        
        gateShort = enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and setOkShortSafe and pullbackShortOkSafe and hybridShortTrigger and enhShortOk
        isChoCH_ShortEntry = gateShort and (structState == 1 or isChoCH_Short) // Currently Bullish OR Just Flipped
        chochShortFilterOk = (not isChoCH_ShortEntry) or ((pD >= chochMinProb) and (not chochReqVol or volOk))
        
        shortSignal := (gateShort and chochShortFilterOk) or revShortGlobal

    else if engine == "Breakout"
        // Base
        baseBuy = gateLongNow  and fcGateLongSafe  and volOkSafe and trendUpSafe and breakoutLongSafe  and enhLongOk
        isChoCH_Entry = baseBuy and (structState == -1 or isChoCH_Long)
        chochFilterOk = (not isChoCH_Entry) or ((pU >= chochMinProb) and (not chochReqVol or volOk))
        
        buySignal   := (baseBuy and chochFilterOk) or revBuyGlobal
        
        baseShort = enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and trendDnSafe and breakoutShortSafe and enhShortOk
        isChoCH_ShortEntry = baseShort and (structState == 1 or isChoCH_Short)
        chochShortFilterOk = (not isChoCH_ShortEntry) or ((pD >= chochMinProb) and (not chochReqVol or volOk))
        
        shortSignal := (baseShort and chochShortFilterOk) or revShortGlobal

    else if engine == "Trend+Pullback"
        buySignal   := gateLongNow and (trendFlipUpSafe or reclaimUpSafe) and enhLongOk
        shortSignal := enableShorts and gateShortNow and (trendFlipDownSafe or reclaimDownSafe) and enhShortOk
        
        // Inject Reversal Logic
        buySignal   := buySignal   or revBuyGlobal
        shortSignal := shortSignal or revShortGlobal

    else // Loose
        buySignal   := gateLongNow and crossClose_EmaF_upSafe and enhLongOk
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_downSafe and enhShortOk

    if buySignal and shortSignal
        buySignal := false
        shortSignal := false

preBuyNow = false
preShortNow = false
if pos == 0 and allowEntry
    float preDist = preWarnDistATR * atr
    distOk = (not na(preDist)) and (preDist > 0) and (not na(atr)) and (atr > 0)
    preSetOkLong = (not requireSET) or (preSetPulseOnly ? setLongPulse : setLongStrict)
    preSetOkShort = (not requireSET) or (preSetPulseOnly ? setShortPulse : setShortStrict)

    if engine == "Hybrid"
        preBuyNow := gateLongNow and fcGateLongSafe and volOkSafe and preSetOkLong and pullbackLongOkSafe and touchEmaF_LongSafe and not (crossClose_EmaF_upSafe or bullReversalSafe)
        preShortNow := enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and preSetOkShort and pullbackShortOkSafe and touchEmaF_ShortSafe and not (crossClose_EmaF_downSafe or bearReversalSafe)
    else if engine == "Breakout"
        nearLong = distOk and (not na(lastSwingHigh)) and (close <= lastSwingHigh) and ((lastSwingHigh - close) <= preDist)
        nearShort = distOk and (not na(lastSwingLow)) and (close >= lastSwingLow) and ((close - lastSwingLow) <= preDist)
        preBuyNow := gateLongNow and fcGateLongSafe and volOkSafe and trendUpSafe and nearLong and not breakoutLongSafe
        preShortNow := enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and trendDnSafe and nearShort and not breakoutShortSafe
    else if engine == "Trend+Pullback"
        nearFlipUp = distOk and (not na(emaF)) and (not na(emaS)) and (emaF < emaS) and ((emaS - emaF) <= preDist)
        nearFlipDown = distOk and (not na(emaF)) and (not na(emaS)) and (emaF > emaS) and ((emaF - emaS) <= preDist)
        nearReclaimUp = distOk and (not na(emaF)) and (bullBias == true) and (close < emaF) and ((emaF - close) <= preDist)
        nearReclaimDown = distOk and (not na(emaF)) and (bearBias == true) and (close > emaF) and ((close - emaF) <= preDist)
        preBuyNow := gateLongNow and (nearFlipUp or nearReclaimUp) and not (trendFlipUpSafe or reclaimUpSafe)
        preShortNow := enableShorts and gateShortNow and (nearFlipDown or nearReclaimDown) and not (trendFlipDownSafe or reclaimDownSafe)
    else // Loose
        nearEmaFUp = distOk and (not na(emaF)) and (close < emaF) and ((emaF - close) <= preDist)
        nearEmaFDown = distOk and (not na(emaF)) and (close > emaF) and ((close - emaF) <= preDist)
        preBuyNow := gateLongNow and nearEmaFUp and not crossClose_EmaF_upSafe
        preShortNow := enableShorts and gateShortNow and nearEmaFDown and not crossClose_EmaF_downSafe

preBuyPrev = (preBuyNow[1] == true)
preShortPrev = (preShortNow[1] == true)
preBuyPulse = showPreEntryLabels and preBuyNow and not preBuyPrev
preShortPulse = showPreEntryLabels and preShortNow and not preShortPrev

var int barsSinceEntry = 0
if pos != pos[1] and pos != 0
    barsSinceEntry := 0
else if pos != 0
    barsSinceEntry += 1
else
    barsSinceEntry := 0

bool canStructExit = (barsSinceEntry >= exitGraceBars)

// Risk Decay Calculation (Linear interpolation)
// Gated: decay pauses during huge volume shock (prevents premature tightening)
if useAtrRisk and useRiskDecay and barsSinceEntry <= decayBars and not hugeVolG
    float w   = math.min(1.0, float(barsSinceEntry) / float(decayBars))
    // Calculate current target Multipliers
    float cStopM = math.max(0.1, stopATR + (decayStopATR - stopATR) * w)
    float cTpM   = math.max(0.1, tpATR   + (decayTpATR   - tpATR)   * w)
    
    if pos == 1 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
        // Recalculate based on STATIC entry conditions to ensure stability
        targetStop = entryPrice - (cStopM * entryAtr)
        targetTp   = entryPrice + (cTpM   * entryAtr)
        
        // Tighten Only: Higher Stop, Lower TP
        stopPx := math.max(stopPx, targetStop)
        if not useInfiniteTP
            tpPx   := math.min(tpPx, targetTp)
            
    else if pos == -1 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
        targetStop = entryPrice + (cStopM * entryAtr)
        targetTp   = entryPrice - (cTpM   * entryAtr)
        
        // Tighten Only: Lower Stop, Higher TP
        stopPx := math.min(stopPx, targetStop)
        if not useInfiniteTP
            tpPx   := math.max(tpPx, targetTp)

// Breakeven Logic
if useBreakeven and not isBeHit and pos != 0 and not na(entryPrice) and not na(atr)
    if pos == 1
        triggerPx = entryPrice + (beTrigger * atr)
        if high >= triggerPx
            newStop = entryPrice + (beOffset * atr)
            if newStop > stopPx
                stopPx := newStop
                isBeHit := true
    else
        triggerPx = entryPrice - (beTrigger * atr)
        if low <= triggerPx
            newStop = entryPrice - (beOffset * atr)
            if newStop < stopPx
                stopPx := newStop
                isBeHit := true

// Stalemate Logic
// Only active if no other exit signal triggers this bar
bool staleExit = false
if useStalemate and pos != 0 and (bar_index - enBar) >= staleBars and not na(atr) and atr > 0
    // Check profit
    float profitATR = 0.0
    if pos == 1
        profitATR := (close - entryPrice) / atr
    else
        profitATR := (entryPrice - close) / atr
        
    if profitATR < staleMinATR
        staleExit := true

// Capturing exit reasons for debugging/transparency
string tempExitReason = ""

if pos == 1 and allowExit
    if useAtrRisk
        trailPx := f_update_trail(true, entryPrice, atr, stopPx, trailPx)
    [rHit, rMsg] = f_risk_exit_hit(true, stopPx, tpPx, trailPx)
    
    // TP Filtering (Hold Winner)
    if rHit and rMsg == "TP" and confidence >= exitConfTP
        rHit := false 
    
    // Check for Reversal Exit (ChoCH Down)
    structHit = ((breakShort and canStructExit) or isChoCH_Short)

    // ChoCh Filtering (Confirm Reversal)
    // Only exit Short if the Down Probability (pD) is high enough
    if structHit and not na(pD) and pD < exitConfChoCh
        structHit := false
    
    exitSignal := rHit or structHit or staleExit
    if exitSignal
        tempExitReason := rHit ? rMsg : staleExit ? "Stalemate" : "ChoCH"

if pos == -1 and allowExit
    if useAtrRisk

        trailPx := f_update_trail(false, entryPrice, atr, stopPx, trailPx)
    [rHit, rMsg] = f_risk_exit_hit(false, stopPx, tpPx, trailPx)
    
    // TP Filtering (Hold Winner)
    if rHit and rMsg == "TP" and confidence >= exitConfTP
        rHit := false 
    
    // Check for Reversal Exit (ChoCH Up)
    structHit = ((breakLong and canStructExit) or isChoCH_Long)

    // ChoCh Filtering (Confirm Reversal) - REMOVED for Bullish ChoCh per instruction
    // if structHit and not na(pU) and pU < exitConfChoCh
    //    structHit := false
    
    coverSignal := rHit or structHit or staleExit
    if coverSignal
        tempExitReason := rHit ? rMsg : staleExit ? "Stalemate" : "ChoCH"

// State Logic
var string lastExitReason = ""
if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        lastExitReason := tempExitReason
        entryPrice := na
        stopPx := na
        tpPx := na
        trailPx := na
        isBeHit := false
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        lastExitReason := tempExitReason
        entryPrice := na
        stopPx := na
        tpPx := na
        trailPx := na
        isBeHit := false
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        entryAtr   := atr
        enBar      := bar_index
        isBeHit    := false
        if useAtrRisk
            [newStop, newTp, newTrail] = f_set_risk_on_entry(true, entryPrice, atr)
            stopPx  := newStop
            tpPx    := newTp
            trailPx := newTrail
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        entryAtr   := atr
        enBar      := bar_index
        isBeHit    := false
        if useAtrRisk
            [sStop, sTp, sTrail] = f_set_risk_on_entry(false, entryPrice, atr)
            stopPx  := sStop
            tpPx    := sTp
            trailPx := sTrail
        lastSignalBar := bar_index
        lastSig := "SHORT"

buyEvent   = barstate.isconfirmed and pos == 1 and pos[1] == 0
shortEvent = barstate.isconfirmed and pos == -1 and pos[1] == 0
exitEvent  = barstate.isconfirmed and pos == 0 and pos[1] == 1
coverEvent = barstate.isconfirmed and pos == 0 and pos[1] == -1

alertFreq = alertOnBarCloseOnly ? alert.freq_once_per_bar_close : alert.freq_once_per_bar

// Alerts
alertcondition((not useAlertCalls) and buyEvent,   title="BUY",   message="SkippALGO BUY | {{ticker}} @ {{close}} | {{time}}")
alertcondition((not useAlertCalls) and shortEvent, title="SHORT", message="SkippALGO SHORT | {{ticker}} @ {{close}} | {{time}}")
alertcondition((not useAlertCalls) and exitEvent,  title="EXIT",  message="SkippALGO EXIT | {{ticker}} @ {{close}} | {{time}}")
alertcondition((not useAlertCalls) and coverEvent, title="COVER", message="SkippALGO COVER | {{ticker}} @ {{close}} | {{time}}")

f_send_alert(cond, label) =>
    if useAlertCalls and cond and barstate.isconfirmed and barstate.isrealtime
        alert("SkippALGO " + label + " | " + syminfo.ticker + " @ " + str.tostring(close, "#.##") + " | TF=" + timeframe.period + " | Conf=" + str.tostring(confidence * 100, "#.0") + "%", alertFreq)

f_send_alert(buyEvent, "BUY")
f_send_alert(shortEvent, "SHORT")
f_send_alert(exitEvent, "EXIT")
f_send_alert(coverEvent, "COVER")

// Highlighting
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))
plotshape(preBuyPulse, title="PRE-BUY", style=shape.labelup, location=location.belowbar, size=size.tiny, text="PRE\nBUY", textcolor=color.black, color=color.new(color.yellow, 0))
plotshape(preShortPulse, title="PRE-SHORT", style=shape.labeldown, location=location.abovebar, size=size.tiny, text="PRE\nSHORT", textcolor=color.black, color=color.new(color.orange, 0))

// Label rendering (configurable source + price)
labelBuy   = buyEvent
labelShort = shortEvent
labelExit  = exitEvent
labelCover = coverEvent

entryPxPrev = entryPrice[1]

f_label_price(isLong, isEntry) =>
    entryBase = isEntry ? entryPrice : entryPxPrev
    entryVal = na(entryBase) ? close : entryBase
    labelPriceMode == "Entry Price" ? entryVal : labelPriceMode == "Close" ? close : isLong ? low : high

if showEntryLabels and labelBuy
    label.new(bar_index, f_label_price(true, true), "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and labelShort
    label.new(bar_index, f_label_price(false, true), "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and labelExit
    label.new(bar_index, f_label_price(false, false), "EXIT\n" + lastExitReason + "\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and labelCover
    label.new(bar_index, f_label_price(true, false), "COVER\n" + lastExitReason + "\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

plot(useAtrRisk and pos == 1 ? stopPx : na,  title="Stop (Long)",  linewidth=1, color=color.new(color.red, 0))
plot(useAtrRisk and not useInfiniteTP and pos == 1 ? tpPx   : na,  title="TP (Long)",    linewidth=1, color=color.new(color.green, 0))
plot(useAtrRisk and pos == 1 ? trailPx: na,  title="Trail (Long)", linewidth=1, color=color.new(color.orange, 0))

plot(useAtrRisk and pos == -1 ? stopPx : na, title="Stop (Short)", linewidth=1, color=color.new(color.red, 0))
plot(useAtrRisk and not useInfiniteTP and pos == -1 ? tpPx   : na, title="TP (Short)",   linewidth=1, color=color.new(color.green, 0))
plot(useAtrRisk and pos == -1 ? trailPx: na, title="Trail (Short)",linewidth=1, color=color.new(color.orange, 0))

// Strategy Execution (Active)
// v6.1.3: TradersPost JSON Payload logic
// uniqueId: recommended by user: {{ticker}}-{{interval}}-{{time}}-{{strategy.order.id}}
// Note: strategy.order.id is essentially the "id" param passed to entry/exit.
f_tp_json(action, orderId, legacyMsg) =>
    if useJsonAlerts
        str.format('{{"ticker": "{0}", "action": "{1}", "orderId": "{2}", "uniqueId": "{0}-{3}-{4}-{2}", "price": {5}, "contracts": {6}, "sentiment": "{7}" }}', 
             syminfo.ticker, 
             action, 
             orderId, 
             timeframe.period, 
             str.tostring(timenow), 
             str.tostring(close, "#.##"), 
             str.tostring(math.abs(strategy.position_size)),
             pos == 1 ? "bullish" : pos == -1 ? "bearish" : "flat"
        )
    else
        legacyMsg

if buyEvent
    strategy.entry("L", strategy.long, comment="Brier=" + str.tostring(curBrier, "#.##"), alert_message=f_tp_json("buy", "L", "SkippALGO BUY | " + syminfo.ticker + " @ " + str.tostring(close, "#.##") + " | TF=" + timeframe.period))
    if useAtrRisk and not na(stopPx) and (useInfiniteTP or not na(tpPx))
        strategy.exit("Exit L", "L", stop=stopPx, limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit L", "SkippALGO EXIT L | " + syminfo.ticker + " | stop/tp hit"))

if shortEvent
    strategy.entry("S", strategy.short, comment="Brier=" + str.tostring(curBrier, "#.##"), alert_message=f_tp_json("sell", "S", "SkippALGO SHORT | " + syminfo.ticker + " @ " + str.tostring(close, "#.##") + " | TF=" + timeframe.period))
    if useAtrRisk and not na(stopPx) and (useInfiniteTP or not na(tpPx))
        strategy.exit("Exit S", "S", stop=stopPx, limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit S", "SkippALGO EXIT S | " + syminfo.ticker + " | stop/tp hit"))

if useAtrRisk and pos != 0 and not na(stopPx)
    if pos == 1 and not na(trailPx)
        strategy.exit("Exit L", "L", stop=math.max(stopPx, trailPx), limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit L", "SkippALGO TRAIL EXIT L | " + syminfo.ticker))
    if pos == -1 and not na(trailPx)
        strategy.exit("Exit S", "S", stop=math.min(stopPx, trailPx), limit=useInfiniteTP ? na : tpPx, alert_message=f_tp_json("exit", "Exit S", "SkippALGO TRAIL EXIT S | " + syminfo.ticker))

if exitEvent
    strategy.close("L", comment="Exit Signal", alert_message=f_tp_json("close", "L", "SkippALGO EXIT | " + syminfo.ticker + " @ " + str.tostring(close, "#.##")))
if coverEvent
    strategy.close("S", comment="Cover Signal", alert_message=f_tp_json("close", "S", "SkippALGO COVER | " + syminfo.ticker + " @ " + str.tostring(close, "#.##")))

//====================
// Calibration Diagnostics Panel (Debug)
//====================
var table diagTbl = na
if showDiagPanel and na(diagTbl)
    diagTbl := table.new(position.top_right, 2, 14, bgcolor=color.new(color.black, 85), frame_color=color.gray, frame_width=1, border_color=color.gray, border_width=1)

// Helper to get selected TfState
f_get_diag_state() =>
    diagHorizon == "F1" ? tf1State : diagHorizon == "F2" ? tf2State : diagHorizon == "F3" ? tf3State : diagHorizon == "F4" ? tf4State : diagHorizon == "F5" ? tf5State : diagHorizon == "F6" ? tf6State : tf7State

f_diag_row(tbl, r, lbl, val, valColor) =>
    table.cell(tbl, 0, r, lbl, text_color=color.gray, text_size=size.tiny)
    table.cell(tbl, 1, r, val, text_color=valColor, text_size=size.tiny)

f_diag_sep(tbl, r) =>
    table.cell(tbl, 0, r, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(tbl, 1, r, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)

if showDiagPanel and barstate.islast and (not tableOnConfirmed or barstate.isconfirmed)
    st = f_get_diag_state()
    if na(st)
        table.cell(diagTbl, 0, 0, "ðŸ”§ Calibration Diagnostics", text_color=color.white, bgcolor=color.new(color.blue, 70), text_size=size.small)
        table.cell(diagTbl, 1, 0, "â€”", text_color=color.gray, bgcolor=color.new(color.blue, 70), text_size=size.small)
    else
        diagIdx = f_tf_index(diagHorizon)
        diagScore = array.get(outScoreArr, diagIdx)
        diagEmaF = array.get(efForecastArr, diagIdx)
        diagEmaS = array.get(esForecastArr, diagIdx)
        isBullDiag = f_is_bull_bias(diagScore, diagEmaF, diagEmaS)
        
        // Select model arrays
        cntArr = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.cntN_bull_raw : st.cntN_bear_raw) : st.cntN_raw) : (useBullBearCal ? (isBullDiag ? st.cnt1_bull_raw : st.cnt1_bear_raw) : st.cnt1_raw)
        upArr  = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.upN_bull_raw  : st.upN_bear_raw)  : st.upN_raw)  : (useBullBearCal ? (isBullDiag ? st.up1_bull_raw  : st.up1_bear_raw)  : st.up1_raw)
        plattArr = diagModel == "N" ? st.plattN : st.platt1
        brierStats = diagModel == "N" ? st.brierStatsN : st.brierStats1
        llStats = diagModel == "N" ? st.llStatsN : st.llStats1
        
        // Platt params
        plattA = array.get(plattArr, 0)
        plattB = array.get(plattArr, 1)
        
        // Brier/LogLoss
        brierSum = array.get(brierStats, 0)
        brierCnt = array.get(brierStats, 1)
        brierAvg = brierCnt > 0 ? brierSum / brierCnt : na
        
        llSum = array.get(llStats, 0)
        llCnt = array.get(llStats, 1)
        llAvg = llCnt > 0 ? llSum / llCnt : na
        
        // Bin samples (total and per-bin distribution)
        totalSamples = array.sum(cntArr)
        numBins = array.size(cntArr)
        
        // Bin distribution (min/max/avg samples per bin)
        minBin = numBins > 0 ? array.min(cntArr) : 0
        maxBin = numBins > 0 ? array.max(cntArr) : 0
        avgBin = numBins > 0 ? totalSamples / numBins : 0
        
        // Win rate (overall calibrated base rate)
        totalUp = array.sum(upArr)
        baseRate = totalSamples > 0 ? totalUp * 100.0 / totalSamples : 50.0
        
        // Convergence check: Is Platt A stable (should be near 1.0 if well-calibrated)?
        plattStable = (plattA >= PLATT_A_LO and plattA <= PLATT_A_HI) and (plattB >= -PLATT_B_BOUND and plattB <= PLATT_B_BOUND)
        convStatus = plattStable ? "âœ… Converged" : (plattA < PLATT_A_UNSTABLE_LO or plattA > PLATT_A_UNSTABLE_HI) ? "âš ï¸ Unstable" : "ðŸ”„ Adjusting"
        convColor = plattStable ? color.lime : (plattA < PLATT_A_UNSTABLE_LO or plattA > PLATT_A_UNSTABLE_HI) ? color.red : color.yellow
        
        // Quality grade
        qualityGrade = na(brierAvg) ? "â€”" : brierAvg < BRIER_EXCELLENT ? "A (Excellent)" : brierAvg < BRIER_GOOD ? "B (Good)" : brierAvg < BRIER_BASELINE ? "C (Baseline)" : brierAvg < BRIER_POOR ? "D (Poor)" : "F (No Skill)"
        qualityColor = na(brierAvg) ? color.gray : brierAvg < BRIER_EXCELLENT ? color.lime : brierAvg < BRIER_GOOD ? color.green : brierAvg < BRIER_BASELINE ? color.yellow : brierAvg < BRIER_POOR ? color.orange : color.red
        
        // Row 0: Header
        table.cell(diagTbl, 0, 0, "ðŸ”§ Calibration Diagnostics", text_color=color.white, bgcolor=color.new(color.blue, 70), text_size=size.small)
        table.cell(diagTbl, 1, 0, diagHorizon + " / " + diagModel, text_color=color.aqua, bgcolor=color.new(color.blue, 70), text_size=size.small)
        
        // Row 1: Platt A
        f_diag_row(diagTbl, 1, "Platt A (slope)", str.tostring(plattA, "#.###"), color.white)
        
        // Row 2: Platt B
        f_diag_row(diagTbl, 2, "Platt B (intercept)", str.tostring(plattB, "#.###"), color.white)
        
        // Row 3: Convergence status
        f_diag_row(diagTbl, 3, "SGD Status", convStatus, convColor)
        
        // Row 4: Separator
        f_diag_sep(diagTbl, 4)
        
        // Row 5: Brier Score
        f_diag_row(diagTbl, 5, "Brier Score", na(brierAvg) ? "â€”" : str.tostring(brierAvg, "#.####"), na(brierAvg) ? color.gray : brierAvg < BRIER_BASELINE ? color.lime : color.red)
        
        // Row 6: LogLoss
        f_diag_row(diagTbl, 6, "LogLoss", na(llAvg) ? "â€”" : str.tostring(llAvg, "#.####"), na(llAvg) ? color.gray : llAvg < 0.65 ? color.lime : color.red)
        
        // Row 7: Quality Grade
        f_diag_row(diagTbl, 7, "Quality Grade", qualityGrade, qualityColor)
        
        // Row 8: Separator
        f_diag_sep(diagTbl, 8)
        
        // Row 9: Total samples
        f_diag_row(diagTbl, 9, "Total Samples", str.tostring(totalSamples), totalSamples >= calMinSamples * numBins ? color.lime : color.yellow)
        
        // Row 10: Bin distribution
        f_diag_row(diagTbl, 10, "Bin Min/Avg/Max", str.tostring(minBin) + "/" + str.tostring(avgBin, "#") + "/" + str.tostring(maxBin), color.white)
        
        // Row 11: Warmup label (mirrors table behavior)
        warmupLbl = f_samp_label(enableForecast, totalSamples)
        warmupPct = math.min(100, totalSamples * 100.0 / (calMinSamples * numBins))
        warmupTxt = warmupLbl == "off" ? "off" : warmupLbl == "â€¦" ? "â€¦" : warmupLbl + " (" + str.tostring(warmupPct, "#.0") + "%)"
        warmupCol = warmupLbl == "strong" ? color.lime : warmupLbl == "ok" ? color.yellow : warmupLbl == "â€¦" ? color.red : color.gray
        f_diag_row(diagTbl, 11, "Warmup", warmupTxt, warmupCol)
        
        // Row 12: Base Rate
        f_diag_row(diagTbl, 12, "Base Rate (Up%)", str.tostring(baseRate, "#.1") + "%", math.abs(baseRate - 50) > 15 ? color.orange : color.white)
        
        // Row 13: Observations count
        f_diag_row(diagTbl, 13, "Resolutions", str.tostring(int(brierCnt)), color.white)

//====================
// Calibration Export Alert
//====================
f_get_export_state() =>
    exportHorizon == "F1" ? tf1State : exportHorizon == "F2" ? tf2State : exportHorizon == "F3" ? tf3State : exportHorizon == "F4" ? tf4State : exportHorizon == "F5" ? tf5State : exportHorizon == "F6" ? tf6State : tf7State

if exportCalibration and barstate.isconfirmed and barstate.isrealtime and (bar_index % exportInterval == 0)
    expSt = f_get_export_state()

    pAN = array.get(expSt.plattN, 0)
    pBN = array.get(expSt.plattN, 1)
    pA1 = array.get(expSt.platt1, 0)
    pB1 = array.get(expSt.platt1, 1)

    // Brier/LogLoss stats aligned to evalWhichHead
    useHeadN = evalWhichHead == "N"
    brierStats = useHeadN ? expSt.brierStatsN : expSt.brierStats1
    llStats = useHeadN ? expSt.llStatsN : expSt.llStats1
    cntArr = useHeadN ? expSt.cntN : expSt.cnt1

    brierSumN = array.get(brierStats, 0)
    brierCntN = array.get(brierStats, 1)
    brierAvgN = brierCntN > 0 ? brierSumN / brierCntN : 0

    llSumN = array.get(llStats, 0)
    llCntN = array.get(llStats, 1)
    llAvgN = llCntN > 0 ? llSumN / llCntN : 0

    totalSamplesN = array.sum(cntArr)

    // Build JSON payload (single line to avoid line continuation issues)
    jsonPayload = str.format('{"ticker":"{0}","horizon":"{1}","bar_index":{2},"timestamp":"{3}","platt_N":{{"a":{4},"b":{5}}},"platt_1":{{"a":{6},"b":{7}}},"brier_avg":{8},"logloss_avg":{9},"samples":{10},"resolutions":{11}}',
        syminfo.ticker,
        exportHorizon,
        str.tostring(bar_index),
        str.tostring(timenow),
        str.tostring(pAN, "#.####"),
        str.tostring(pBN, "#.####"),
        str.tostring(pA1, "#.####"),
        str.tostring(pB1, "#.####"),
        str.tostring(brierAvgN, "#.####"),
        str.tostring(llAvgN, "#.####"),
        str.tostring(totalSamplesN),
        str.tostring(int(brierCntN))
    )

    alert(jsonPayload, alert.freq_once_per_bar)

//====================
// Trend Regime Export Alert (for monitoring)
//====================
// Epsilon PRICE_EPS prevents division by zero on penny stocks or exotic instruments
atrNormCur = atr / math.max(close, PRICE_EPS)
curTrendRegime = f_trend_regime(emaF, emaS, atrNormCur)
trendLabel = curTrendRegime > 0.5 ? "BULL" : curTrendRegime < -0.5 ? "BEAR" : "SIDEWAYS"
bullRegimeCond = curTrendRegime > 0.5 and curTrendRegime[1] <= 0.5
bearRegimeCond = curTrendRegime < -0.5 and curTrendRegime[1] >= -0.5
sidewaysRegimeCond = math.abs(curTrendRegime) <= 0.5 and math.abs(curTrendRegime[1]) > 0.5
alertcondition(bullRegimeCond, title="Regime: BULL", message="{{ticker}} entered BULL regime")
alertcondition(bearRegimeCond, title="Regime: BEAR", message="{{ticker}} entered BEAR regime")
alertcondition(sidewaysRegimeCond, title="Regime: SIDEWAYS", message="{{ticker}} entered SIDEWAYS regime")

//====================
