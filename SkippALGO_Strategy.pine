// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6
// SkippALGO Strategy (Deep Upgrade v6.1)
// - Synchronized with Main Indicator v6.1
// - Target Profiles (Fixed, KReturn, KATR, TPorSL)
// - Ensemble Score (Algo + Pullback + Regime)
// - 2D Binning (Score x Volatility)
// - Platt Scaling (SGD Probability Calibration)
strategy("SkippALGO Strategy (Deep Upgrade v6.1)", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_labels_count=500, max_lines_count=500)

//====================
// Inputs â€” Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

//====================
// Constants â€” Avoid Magic Numbers
//====================
// Volatility regime thresholds
VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

// Statistical constants
Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)

// Rolling buffer recalculation interval (prevent FP drift)
ROLL_RECALC_INTERVAL = 500

// Sideways/choppy market detection thresholds
SIDEWAYS_EMA_THRESH = 0.005   // Max EMA diff ratio for sideways
SIDEWAYS_ATR_THRESH = 0.015   // Max ATR norm for sideways

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels  = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers   = input.bool(true, "Show SET markers")
showTable        = input.bool(true, "Show Outlook/Forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

//====================
// Inputs â€” Forecast Calibration Enhancements (Deep Upgrade v6.1)
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])
pHdrN = fcDisplay == "Edge pp (N)" ? "Edge(N)" : "Up%(N)"
pHdr1 = fcDisplay == "Edge pp (N)" ? "Edge(1)" : "Up%(1)"
atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)

//====================
// Inputs â€” Forecast 3-way (Up/Flat/Down)
//====================
grp_tri = "Forecast 3-way (Up/Flat/Down)"
use3Way = input.bool(true, "3-way probs: Up/Flat/Down", group=grp_tri)

deadbandFast = input.float(0.10, "Deadband Ã— ATR (Fast <=5m)", step=0.01, group=grp_tri)
deadbandMid  = input.float(0.10, "Deadband Ã— ATR (Mid <=1h)",  step=0.01, group=grp_tri)
deadbandSlow = input.float(0.10, "Deadband Ã— ATR (Slow >1h)",  step=0.01, group=grp_tri)

flatPriorFast = input.float(0.42, "Warmup prior: Flat (Fast)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorMid  = input.float(0.30, "Warmup prior: Flat (Mid)",  step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorSlow = input.float(0.22, "Warmup prior: Flat (Slow)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)

tiltMaxFast = input.float(0.10, "Warmup tilt max (Fast)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxMid  = input.float(0.12, "Warmup tilt max (Mid)",  step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxSlow = input.float(0.15, "Warmup tilt max (Slow)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)

dirMinProb = input.float(0.45, "Direction shown if max prob â‰¥", step=0.01, minval=0.34, maxval=0.90, group=grp_tri)

fcTblModel = input.string("N", "Forecast columns", options=["N","1","Both"], group=grp_tri)

calibratorMode = input.string("Off", "3-way calibrator", options=["Off","Temp","Vector"], group=grp_tri)
lrCal = input.float(0.01, "Calibrator LR", step=0.001, minval=0.0001, group=grp_tri)
tempMin = input.float(0.5, "Temp min", step=0.1, minval=0.1, group=grp_tri)
tempMax = input.float(5.0, "Temp max", step=0.1, minval=0.5, group=grp_tri)
vecAMin = input.float(0.25, "Vec A min", step=0.05, minval=0.05, group=grp_tri)
vecAMax = input.float(3.0, "Vec A max", step=0.05, minval=0.5, group=grp_tri)
vecBMin = input.float(-2.0, "Vec B min", step=0.1, group=grp_tri)
vecBMax = input.float(2.0, "Vec B max", step=0.1, group=grp_tri)
cal3AutoFallback = input.bool(true, "3-way auto fallback (weak bins)", group=grp_tri)
cal3MinSamples  = input.int(120, "3-way min samples for calibrator", minval=10, maxval=5000, group=grp_tri)
useBullBearCal = input.bool(true, "Separate bull/bear calibrators", group=grp_tri)
countDecay = input.float(1.0, "Count decay (1.0=none)", minval=0.80, maxval=1.0, step=0.01, group=grp_tri)
kShrinkReg = input.int(5, "Regime shrinkage k", minval=0, maxval=1000, group=grp_tri)

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpATRM    = input.float(0.80, "Path TP", step=0.05, group=grp_mid)
slATRM    = input.float(0.50, "Path SL", step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.20, "Path TP", step=0.05, group=grp_slow)
slATRS    = input.float(0.80, "Path SL", step=0.05, group=grp_slow)

// Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"], group="Policy")
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"], group="Policy")

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")

// --- Phase 4: Online Calibration ---
grp_cal = "Calibration Settings (Phase 4)"
usePlatt = input.bool(true, "Use Platt Scaling (Online SGD)", group=grp_cal)
lrPlatt  = input.float(0.005, "Learning Rate (SGD)", minval=0.001, maxval=0.1, step=0.001, group=grp_cal)

// Bins & Smoothing
predBinsN = input.int(3, "Pred bins (N) stable", minval=2, maxval=9, group="Engine")
predBins1 = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3, group="Engine")
dim2Bins  = 3 // Volatility Low/Mid/Hi

// Quantile binning (score dimension)
useQuantileBins = input.bool(true, "Use quantile bins (score)", group="Engine")
quantileWindow = input.int(500, "Quantile window (samples)", minval=100, maxval=5000, group="Engine")
quantileUpdate = input.int(50, "Quantile update interval (bars)", minval=10, maxval=1000, group="Engine")
quantileMinSamples = input.int(200, "Quantile min samples", minval=50, maxval=5000, group="Engine")

alphaN = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1, group="Engine")
alpha1 = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1, group="Engine")
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000, tooltip="Higher = pull bin probability closer to global TF average", group="Engine")

calMinSamples = input.int(40, "Min samples per bin (activate)", minval=5, maxval=1000, group="Engine")

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01, group="Signals")
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01, group="Signals")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7"], group="Maintenance")
resetNow   = input.bool(false, "Reset selected calibration NOW", group="Maintenance")

//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F6", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")
relFilterModel = input.string("N", "Filter Model", options=["N", "1"], tooltip="N=Multi-factor, 1=Single-factor")

// Evidence / coverage gating
evidenceGate = input.bool(false, "Evidence gate (block weak bins)")
evidenceMinTotal = input.int(120, "Evidence min total samples", minval=1, maxval=10000)
abstainGate = input.bool(true, "Abstain on weak decisions")
abstainMinEdge = input.float(0.08, "Abstain min edge (pp)", minval=0.0, maxval=0.50, step=0.01)

//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ECE/Drift)")
evalWhichHead   = input.string("N", "Evaluate head", options=["N","1"])  // N=stable bins, 1=reactive bins

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"])

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)

//====================
// Inputs â€” Calibration Diagnostics (Debug Panel)
//====================
grp_diag = "ðŸ”§ Calibration Diagnostics"
showDiagPanel   = input.bool(false, "Show Calibration Debug Panel", group=grp_diag, tooltip="Displays Platt params, convergence, bin samples")
diagHorizon     = input.string("F1", "Diagnostic Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_diag)
diagModel       = input.string("N", "Diagnostic Model", options=["N","1"], group=grp_diag, tooltip="N=Multi-factor, 1=Single-factor")

//====================
// Inputs â€” Calibration Export (Webhook)
//====================
grp_export = "ðŸ“¤ Calibration Export"
exportCalibration = input.bool(false, "Enable Calibration Export Alert", group=grp_export, tooltip="Fires alert with JSON calibration state")
exportInterval    = input.int(100, "Export Every N Bars", minval=10, maxval=1000, group=grp_export)
exportHorizon     = input.string("F1", "Export Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_export)

//====================
// Calibration storage â€” TfState UDT (replaces 100+ global arrays)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    float[] cntN
    float[] upN
    float[] dnN
    float[] cnt1
    float[] up1
    float[] dn1
    float[] cntN_bull
    float[] upN_bull
    float[] dnN_bull
    float[] cntN_bear
    float[] upN_bear
    float[] dnN_bear
    float[] cnt1_bull
    float[] up1_bull
    float[] dn1_bull
    float[] cnt1_bear
    float[] up1_bear
    float[] dn1_bear
    // Queues
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    int[]   qBias
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    float[] qPUpN
    float[] qPFlN
    float[] qPDnN
    float[] qPUp1
    float[] qPFl1
    float[] qPDn1
    float[] qZUpN
    float[] qZFlN
    float[] qZDnN
    float[] qZUp1
    float[] qZFl1
    float[] qZDn1
    // Stats
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    float[] tempN
    float[] temp1
    float[] vecAN
    float[] vecBN
    float[] vecA1
    float[] vecB1
    // Evaluation N
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    // Evaluation 1
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1

// Helper to initialize TfState
f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
            array.new_int(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
            array.new_int(),
            array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.from(1.0, 0.0), array.from(1.0, 0.0),
    array.from(1.0), array.from(1.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
      // Eval N
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float(),
      // Eval 1
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float()
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)

//====================
// Table colors (navy + soft-blue frame)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

//====================
// Quantile bin buffers (score dimension)
//====================
var float[] qScoreBuf = array.new_float()
var float[] qCutsN = array.new_float(math.max(predBinsN - 1, 0), na)
var float[] qCuts1 = array.new_float(math.max(predBins1 - 1, 0), na)

//====================
// Helpers
//====================
// --- Sum int array (total resolved samples across all bins)
f_sum_int_array(a) =>
    float s = 0.0
    for i = 0 to array.size(a) - 1
        s += array.get(a, i)
    s

// --- Update quantile cutpoints (score dimension)
f_fill_cuts(sorted, cuts, bins) =>
    cutCount = bins - 1
    if cutCount > 0
        n = array.size(sorted)
        for i = 0 to cutCount - 1
            frac = (i + 1.0) / bins
            idx = int(math.floor(frac * (n - 1)))
            array.set(cuts, i, array.get(sorted, idx))

f_update_quantiles(score) =>
    if useQuantileBins
        array.push(qScoreBuf, score)
        if array.size(qScoreBuf) > quantileWindow
            array.shift(qScoreBuf)
        if bar_index % quantileUpdate == 0 and array.size(qScoreBuf) >= quantileMinSamples
            tmp = array.copy(qScoreBuf)
            array.sort(tmp, order.ascending)
            f_fill_cuts(tmp, qCutsN, predBinsN)
            f_fill_cuts(tmp, qCuts1, predBins1)

f_bin_quantile(score, cuts, bins) =>
    if (not useQuantileBins) or array.size(cuts) == 0 or na(array.get(cuts, 0))
        f_bin(score, bins)
    else
        b = 0
        for i = 0 to array.size(cuts) - 1
            if score <= array.get(cuts, i)
                b := i
                break
            else
                b := i + 1
        math.max(0, math.min(bins - 1, b))

f_regime_bin(trendScore) =>
    trendScore > 0.5 ? 2 : trendScore < -0.5 ? 0 : 1

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

// @function Clamp value to arbitrary [lo, hi] range
// @param val Value to clamp
// @param lo Minimum bound
// @param hi Maximum bound
// @returns Clamped value
f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" : tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  : tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "â€”" : v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") : v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") : v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") : str.tostring(v, "#")

f_chance_word() =>
    anyWin = fcTargetF == "PathTPvsSL" or fcTargetM == "PathTPvsSL" or fcTargetS == "PathTPvsSL"
    anyWin ? "Win" : "Up"

f_ci95_halfwidth(p, n) =>
    n <= 0 ? na : Z_95 * math.sqrt(p * (1.0 - p) / n)

f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= 0.05 ? "strong" : hw <= 0.10 ? "ok" : "weak"
    lbl

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    trend = emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = sec <= 300 // <= 5m
    isMid  = sec <= 3600 // <= 1h
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     isFast ? tpATRF    : isMid ? tpATRM    : tpATRS, 
     isFast ? slATRF    : isMid ? slATRM    : slATRS]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    // Clamp output to prevent extreme values
    math.max(-10.0, math.min(10.0, math.log(pc / (1.0 - pc))))

f_sigmoid(x) =>
    // Prevent overflow for extreme x values
    x < -500 ? 0.0 : x > 500 ? 1.0 : 1.0 / (1.0 + math.exp(-x))

f_platt_prob(pRaw, a, b) =>
    usePlatt ? f_sigmoid(a * f_logit(pRaw) + b) : pRaw

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Bias -1 (Bear): mirror logic; Bias 0 (neutral): return 0
    bias == 1 ? (c > ef ? 0.5 : c > es ? 1.0 : -1.0) : bias == -1 ? (c < ef ? 0.5 : c < es ? 1.0 : -1.0) : 0.0

// @function Computes trend regime score (bull/bear/sideways)
// @param emaF Fast EMA value
// @param emaS Slow EMA value
// @param atrNorm ATR normalized by close (for sideways detection)
// @returns Score in [-1, 1]: +1=bull, -1=bear, 0=sideways/choppy
f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / nz(emaS, 1)
    // Strong trend: EMAs diverging significantly (>0.5% gap)
    // Sideways: EMAs close together AND low volatility
    isSideways = math.abs(emaDiff) < SIDEWAYS_EMA_THRESH and atrNorm < SIDEWAYS_ATR_THRESH
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

f_ensemble(sA, sB, sC, wA, wB, wC) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Regime Score (-1..1)
    num = wA * sA + wB * sB + wC * sC
    den = wA + wB + wC
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Vol Regime Score (-1..1)
    // sD: Trend Regime Score (-1..1): bull/bear/sideways
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// --- Phase 2 Helpers: 2D Binning ---
// @function Computes 2D bin index from score and trend regime
// @param score Ensemble score in [-1, 1]
// @param trendScore Trend regime score in [-1, 1]
// @param binsScore Number of bins for score dimension
// @param binsReg Number of bins for regime dimension (typically 3)
// @param cutsArr Quantile cutpoints for score dimension
// @returns Flattened bin index
f_bin2D(score, trendScore, binsScore, binsReg, cutsArr) =>
    bS = f_bin_quantile(score, cutsArr, binsScore)
    bR = f_regime_bin(trendScore)
    int(bS * binsReg + bR)

f_db_mult(tf) =>
    sec = timeframe.in_seconds(tf)
    sec <= 300 ? deadbandFast : sec <= 3600 ? deadbandMid : deadbandSlow

f_outcome3(delta, db) =>
    delta > db ? 1 : delta < -db ? -1 : 0

f_bias_from_score(score) =>
    score >= 0 ? 1 : -1

f_decay_counts(cntArr, upArr, dnArr, decay) =>
    if decay < 0.9999
        for i = 0 to array.size(cntArr) - 1
            array.set(cntArr, i, array.get(cntArr, i) * decay)
            array.set(upArr,  i, array.get(upArr,  i) * decay)
            array.set(dnArr,  i, array.get(dnArr,  i) * decay)

f_cal_update3(cntArr, upArr, dnArr, bin, outcome) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    d0 = array.get(dnArr,  bin)
    array.set(cntArr, bin, n0 + 1.0)
    array.set(upArr,  bin, u0 + (outcome == 1 ? 1.0 : 0.0))
    array.set(dnArr,  bin, d0 + (outcome == -1 ? 1.0 : 0.0))

f_prob3(u, f, d, n, alpha) =>
    denom = n + 3.0 * alpha
    denom == 0.0 ? [0.3333, 0.3334, 0.3333] : [(u + alpha) / denom, (f + alpha) / denom, (d + alpha) / denom]

f_cal_cur3(cntArr, upArr, dnArr, bin, alpha, shrinkK, shrinkReg) =>
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    d = array.get(dnArr,  bin)
    f = math.max(0, n - u - d)

    [pUb, pFb, pDb] = f_prob3(u, f, d, n, alpha)

    volBin = bin % dim2Bins
    binsScore = int(array.size(cntArr) / dim2Bins)
    nReg = 0.0
    uReg = 0.0
    dReg = 0.0
    for i = 0 to binsScore - 1
        idx = i * dim2Bins + volBin
        nReg += array.get(cntArr, idx)
        uReg += array.get(upArr,  idx)
        dReg += array.get(dnArr,  idx)
    fReg = math.max(0, nReg - uReg - dReg)
    [pUr, pFr, pDr] = f_prob3(uReg, fReg, dReg, nReg, alpha)

    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    dBase = array.sum(dnArr)
    fBase = math.max(0, nBase - uBase - dBase)
    [pU0, pF0, pD0] = f_prob3(uBase, fBase, dBase, nBase, alpha)

    wReg = (shrinkReg <= 0) ? 1.0 : (n / (n + shrinkReg + 0.0))
    pUreg = wReg * pUb + (1.0 - wReg) * pUr
    pFreg = wReg * pFb + (1.0 - wReg) * pFr
    pDreg = wReg * pDb + (1.0 - wReg) * pDr

    w = (shrinkK <= 0) ? 1.0 : (nReg / (nReg + shrinkK + 0.0))
    pU = w * pUreg + (1.0 - w) * pU0
    pF = w * pFreg + (1.0 - w) * pF0
    pD = w * pDreg + (1.0 - w) * pD0

    s = pU + pF + pD
    s == 0.0 ? [0.3333, 0.3334, 0.3333, n] : [pU / s, pF / s, pD / s, n]

f_safe_log(p) =>
    math.log(math.max(PROB_EPS, p))

f_softmax3(zU, zF, zD) =>
    zMax = math.max(zU, math.max(zF, zD))
    eU = math.exp(zU - zMax)
    eF = math.exp(zF - zMax)
    eD = math.exp(zD - zMax)
    s = eU + eF + eD
    s == 0.0 ? [0.3333, 0.3334, 0.3333] : [eU / s, eF / s, eD / s]

f_can_cal3(nBin) =>
    calibratorMode != "Off" and (not cal3AutoFallback or nBin >= cal3MinSamples)

f_cal_apply(zU, zF, zD, tempArr, aArr, bArr) =>
    zUo = zU
    zFo = zF
    zDo = zD
    if calibratorMode == "Temp"
        t = array.get(tempArr, 0)
        t := t <= 0.0 ? 1.0 : t
        zUo := zU / t
        zFo := zF / t
        zDo := zD / t
    else if calibratorMode == "Vector"
        aU = array.get(aArr, 0)
        aF = array.get(aArr, 1)
        aD = array.get(aArr, 2)
        bU = array.get(bArr, 0)
        bF = array.get(bArr, 1)
        bD = array.get(bArr, 2)
        zUo := aU * zU + bU
        zFo := aF * zF + bF
        zDo := aD * zD + bD
    f_softmax3(zUo, zFo, zDo)

f_brier3(pU, pF, pD, outcome) =>
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0
    ((pU - yU) * (pU - yU) + (pF - yF) * (pF - yF) + (pD - yD) * (pD - yD)) / 3.0

f_logloss3(pU, pF, pD, outcome) =>
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD
    -math.log(f_clamp(pTrue, 0.0001, 0.9999))

f_prior3(tf, outScore) =>
    sec = timeframe.in_seconds(tf)
    baseFlat = sec <= 300 ? flatPriorFast : sec <= 3600 ? flatPriorMid : flatPriorSlow
    tiltMax  = sec <= 300 ? tiltMaxFast  : sec <= 3600 ? tiltMaxMid  : tiltMaxSlow

    baseSide = (1.0 - baseFlat) * 0.5
    tilt = f_clamp(outScore, -1.0, 1.0) * tiltMax

    pU = f_clamp(baseSide + tilt, 0.0, 1.0)
    pD = f_clamp(baseSide - tilt, 0.0, 1.0)
    pF = f_clamp(baseFlat, 0.0, 1.0)

    s = pU + pF + pD
    s == 0.0 ? [0.3333, 0.3334, 0.3333] : [pU / s, pF / s, pD / s]

f_samp_label(enabled, total) =>
    not enabled ? "off" : total < calMinSamples ? "â€¦" : total < calMinSamples * 3 ? "ok" : "strong"

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

f_tf_pack(tf) =>
    request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(close == 0 ? 0.0 : ta.atr(atrLen) / close, volRankLen)], // Added Phase 2 Vol Rank
        barmerge.gaps_off,
        barmerge.lookahead_off
    )

f_score_tf(tf) =>
    [c, ef, es, r] = request.security(
            syminfo.tickerid,
            tf,
            [close,
             ta.ema(close, emaFastLen),
             ta.ema(close, emaSlowLen),
             ta.rsi(close, rsiStateLen)],
            barmerge.gaps_off,
            barmerge.lookahead_off
        )
    f_state_score(c, ef, es, r)

// Forecast binning (fallback: fixed width)
f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = int(math.floor(u * bins))
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b



// @function Computes Laplace-smoothed probability with division safety
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter (default typically 1.0)
// @returns Probability in (0, 1), defaults to 0.5 if denominator is zero
f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_update(cntArr, upArr, bin, isUp) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    array.set(cntArr, bin, n0 + 1.0)
    array.set(upArr,  bin, u0 + (isUp ? 1.0 : 0.0))

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Bin raw
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "â€”" : n < calMinSamples ? "â€¦" : pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) : n < calMinSamples ? color.new(color.white, 60) : pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_pupText(pUp, n, canCal) =>
    not canCal ? "OFF" : n == 0 ? "â€”" : n < calMinSamples ? "Warm " + str.tostring(n) + "/" + str.tostring(calMinSamples) : fcDisplay == "Edge pp (N)" ? ((pUp - 0.5) * 100.0 > 0 ? "+" + str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")" : str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")") : "Up " + str.tostring(pUp * 100.0, "#.0") + "% (" + str.tostring(n) + ")"

// Helper: Brier Score (MSE)
f_brier(p, isEvent) =>
    y = isEvent ? 1.0 : 0.0
    math.pow(p - y, 2)

// Helper: Log Loss (clipped)
f_logloss(p, isEvent) =>
    y = isEvent ? 1.0 : 0.0
    pClip = f_clamp(p, 0.01, 0.99)
    -(y * math.log(pClip) + (1.0 - y) * math.log(1.0 - pClip))

// Helper: Update one Evaluation struct
f_eval_update_one(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, 
                  evCalCnt, evCalSumP, evCalSumY, evCalBBuf, evCalPBuf, evCalYBuf, 
                  pPred, isUp, rollScore, rollShort, rollLong, buckets) =>
    // 1. Calc instance scores
    bs = f_brier(pPred, isUp)
    ll = f_logloss(pPred, isUp)
    y  = isUp ? 1.0 : 0.0
    
    // 2. Rolling Brier/LogLoss
    array.push(evBrier, bs)
    array.push(evLog, ll)
    sb = array.get(evSumBrier, 0) + bs
    sl = array.get(evSumLog, 0) + ll
    if array.size(evBrier) > rollScore
        sb := sb - array.shift(evBrier)
        sl := sl - array.shift(evLog)
    // Periodic recalculation to prevent FP drift
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(evBrier) > 0
        sb := array.sum(evBrier)
        sl := array.sum(evLog)
    array.set(evSumBrier, 0, sb)
    array.set(evSumLog, 0, sl)

    // 3. Drift (YS vs YL)
    array.push(evYS, y)
    array.push(evYL, y)
    sys = array.get(evSumYS, 0) + y
    syl = array.get(evSumYL, 0) + y
    if array.size(evYS) > rollShort
        sys := sys - array.shift(evYS)
    if array.size(evYL) > rollLong
        syl := syl - array.shift(evYL)
    // Periodic recalculation to prevent FP drift
    if bar_index % ROLL_RECALC_INTERVAL == 0
        if array.size(evYS) > 0
            sys := array.sum(evYS)
        if array.size(evYL) > 0
            syl := array.sum(evYL)
    array.set(evSumYS, 0, sys)
    array.set(evSumYL, 0, syl)

    // 4. Calibration (ECE Buckets)
    bIdx = math.min(math.floor(pPred * buckets), buckets - 1)
    
    // Rolling buffer for ECE (remove old events to keep ECE "live")
    // We store [bIdx, pPred, y] in parallel arrays or similar structure
    array.push(evCalBBuf, int(bIdx))
    array.push(evCalPBuf, pPred)
    array.push(evCalYBuf, y)
    
    // Add to buckets
    array.set(evCalCnt,  bIdx, array.get(evCalCnt,  bIdx) + 1)
    array.set(evCalSumP, bIdx, array.get(evCalSumP, bIdx) + pPred)
    array.set(evCalSumY, bIdx, array.get(evCalSumY, bIdx) + y)

    // Expire old
    // Use rollScore for ECE window as well for simplicity (or separate param)
    if array.size(evCalBBuf) > rollScore
        oldB = array.shift(evCalBBuf)
        oldP = array.shift(evCalPBuf)
        oldY = array.shift(evCalYBuf)
        // Remove from buckets
        cOld = array.get(evCalCnt, oldB)
        if cOld > 0
            array.set(evCalCnt, oldB, cOld - 1)
            array.set(evCalSumP, oldB, array.get(evCalSumP, oldB) - oldP)
            array.set(evCalSumY, oldB, array.get(evCalSumY, oldB) - oldY)

f_eval_update_one3(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL,
                  evCalCnt, evCalSumP, evCalSumY, evCalBBuf, evCalPBuf, evCalYBuf,
                  pU, pF, pD, outcome, rollScore, rollShort, rollLong, buckets) =>
    b3 = f_brier3(pU, pF, pD, outcome)
    ll = f_logloss3(pU, pF, pD, outcome)
    yUp = outcome == 1 ? 1.0 : 0.0
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD

    array.push(evBrier, b3)
    array.push(evLog, ll)
    sb = array.get(evSumBrier, 0) + b3
    sl = array.get(evSumLog, 0) + ll
    if array.size(evBrier) > rollScore
        sb := sb - array.shift(evBrier)
        sl := sl - array.shift(evLog)
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(evBrier) > 0
        sb := array.sum(evBrier)
        sl := array.sum(evLog)
    array.set(evSumBrier, 0, sb)
    array.set(evSumLog, 0, sl)

    array.push(evYS, yUp)
    array.push(evYL, yUp)
    sys = array.get(evSumYS, 0) + yUp
    syl = array.get(evSumYL, 0) + yUp
    if array.size(evYS) > rollShort
        sys := sys - array.shift(evYS)
    if array.size(evYL) > rollLong
        syl := syl - array.shift(evYL)
    if bar_index % ROLL_RECALC_INTERVAL == 0
        if array.size(evYS) > 0
            sys := array.sum(evYS)
        if array.size(evYL) > 0
            syl := array.sum(evYL)
    array.set(evSumYS, 0, sys)
    array.set(evSumYL, 0, syl)

    bIdx = math.min(math.floor(pTrue * buckets), buckets - 1)
    array.push(evCalBBuf, int(bIdx))
    array.push(evCalPBuf, pTrue)
    array.push(evCalYBuf, 1.0)

    array.set(evCalCnt,  bIdx, array.get(evCalCnt,  bIdx) + 1)
    array.set(evCalSumP, bIdx, array.get(evCalSumP, bIdx) + pTrue)
    array.set(evCalSumY, bIdx, array.get(evCalSumY, bIdx) + 1.0)

    if array.size(evCalBBuf) > rollScore
        oldB = array.shift(evCalBBuf)
        oldP = array.shift(evCalPBuf)
        oldY = array.shift(evCalYBuf)
        cOld = array.get(evCalCnt, oldB)
        if cOld > 0
            array.set(evCalCnt, oldB, cOld - 1)
            array.set(evCalSumP, oldB, array.get(evCalSumP, oldB) - oldP)
            array.set(evCalSumY, oldB, array.get(evCalSumY, oldB) - oldY)

f_eval_on_resolve(TfState st, pPredN, pPred1, isUp) =>
    modeN = evalWhichHead == "N"
    mode1 = evalWhichHead == "1"
    
    if modeN
        f_eval_update_one(st.evBrierN, st.evLogN, st.evSumBrierN, st.evSumLogN, st.evYS_N, st.evYL_N, st.evSumYS_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN, pPredN, isUp, evalRollScore, evalRollShort, evalRollLong, evalBuckets)
    if mode1
        f_eval_update_one(st.evBrier1, st.evLog1, st.evSumBrier1, st.evSumLog1, st.evYS_1, st.evYL_1, st.evSumYS_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1, pPred1, isUp, evalRollScore, evalRollShort, evalRollLong, evalBuckets)

// Helper: Get Eval Stats [Brier, LogLoss, ECE, DriftPP, Count]
f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY) =>
    n = array.size(evBrier)
    if n < evalMinEvents
        [float(na), float(na), float(na), float(na), float(n)]
    else
        // Brier, Log
        bs = array.get(evSumBrier, 0) / n
        ll = array.get(evSumLog, 0) / n
        
        // ECE - compute inline without nested if
        eceSum = 0.0
        totCal = 0
        for i = 0 to evalBuckets - 1
            bn = array.get(evCalCnt, i)
            // Use ternary to avoid nested if block issue
            contrib = bn > 0 ? bn * math.abs(array.get(evCalSumP, i) / bn - array.get(evCalSumY, i) / bn) : 0.0
            eceSum += contrib
            totCal += bn > 0 ? bn : 0
        ece = totCal > 0 ? eceSum / totCal : 0.0
        
        // Drift
        // Only if short/long windows are filled
        nS = array.size(evYS)
        nL = array.size(evYL)
        drift = 0.0
        if nS >= evalRollShort and nL >= evalRollLong
            avgS = array.get(evSumYS, 0) / nS
            avgL = array.get(evSumYL, 0) / nL
            drift := (avgS - avgL) * 100.0 // in pp
        else
            drift := float(na)
            
        [bs, ll, ece, drift, float(n)]

// Table Helpers
f_colLowerBetter(val, goodThr, badThr) =>
    na(val) ? color.new(color.gray, 60) : val < goodThr ? color.new(color.lime, 30) : val > badThr ? color.new(color.red, 30) : color.new(color.yellow, 30)

f_ppSigned(val) =>
    na(val) ? "â€”" : (val > 0 ? "+" : "") + str.tostring(val, "#.1") + "pp"

f_rowEval(tbl, tid, titleStr, evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY, rIdx) =>
    [bs, ll, ece, drift, n] = f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY)
    
    // Header
    table.cell(tbl, 0, rIdx, titleStr, text_halign=text.align_left, text_size=size.small, bgcolor=color.new(color.gray, 90))
    
    if na(bs)
        table.cell(tbl, 1, rIdx, "Wait (" + str.tostring(n, "#") + ")", text_size=size.small)
    else
        // Brier
        // scale: typically 0.25 is max entropy. <0.20 is good. <0.15 is great.
        // Let's color based on general intuition
        cBs = f_colLowerBetter(bs, 0.18, 0.23)
        table.cell(tbl, 1, rIdx, str.tostring(bs, "#.3f"), bgcolor=cBs, text_size=size.small)
        
        // LogL
        // scale: ~0.693 is rand. <0.60 is good.
        cLl = f_colLowerBetter(ll, 0.55, 0.65)
        table.cell(tbl, 2, rIdx, str.tostring(ll, "#.3f"), bgcolor=cLl, text_size=size.small)
        
        // ECE
        cEce = f_colLowerBetter(ece, 0.05, 0.10)
        table.cell(tbl, 3, rIdx, str.tostring(ece*100, "#.1")+"%", bgcolor=cEce, text_size=size.small)
        
        // Drift
        cDr = math.abs(drift) > driftWarnPP ? color.new(color.red, 30) : color.new(color.gray, 90)
        table.cell(tbl, 4, rIdx, f_ppSigned(drift), bgcolor=cDr, text_size=size.small)


f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0.0), array.fill(st.upN, 0.0), array.fill(st.dnN, 0.0)
    array.fill(st.cnt1, 0.0), array.fill(st.up1, 0.0), array.fill(st.dn1, 0.0)
    array.fill(st.cntN_bull, 0.0), array.fill(st.upN_bull, 0.0), array.fill(st.dnN_bull, 0.0)
    array.fill(st.cntN_bear, 0.0), array.fill(st.upN_bear, 0.0), array.fill(st.dnN_bear, 0.0)
    array.fill(st.cnt1_bull, 0.0), array.fill(st.up1_bull, 0.0), array.fill(st.dn1_bull, 0.0)
    array.fill(st.cnt1_bear, 0.0), array.fill(st.up1_bear, 0.0), array.fill(st.dn1_bear, 0.0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    array.clear(st.qBias)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    array.clear(st.qPUpN)
    array.clear(st.qPFlN)
    array.clear(st.qPDnN)
    array.clear(st.qPUp1)
    array.clear(st.qPFl1)
    array.clear(st.qPDn1)
    array.clear(st.qZUpN)
    array.clear(st.qZFlN)
    array.clear(st.qZDnN)
    array.clear(st.qZUp1)
    array.clear(st.qZFl1)
    array.clear(st.qZDn1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)
    array.set(st.tempN, 0, 1.0)
    array.set(st.temp1, 0, 1.0)
    array.set(st.vecAN, 0, 1.0)
    array.set(st.vecAN, 1, 1.0)
    array.set(st.vecAN, 2, 1.0)
    array.set(st.vecBN, 0, 0.0)
    array.set(st.vecBN, 1, 0.0)
    array.set(st.vecBN, 2, 0.0)
    array.set(st.vecA1, 0, 1.0)
    array.set(st.vecA1, 1, 1.0)
    array.set(st.vecA1, 2, 1.0)
    array.set(st.vecB1, 0, 0.0)
    array.set(st.vecB1, 1, 0.0)
    array.set(st.vecB1, 2, 0.0)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN), array.clear(st.evSumBrierN), array.clear(st.evLogN), array.clear(st.evSumLogN), array.clear(st.evYS_N), array.clear(st.evSumYS_N), array.clear(st.evYL_N), array.clear(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1), array.clear(st.evSumBrier1), array.clear(st.evLog1), array.clear(st.evSumLog1), array.clear(st.evYS_1), array.clear(st.evSumYS_1), array.clear(st.evYL_1), array.clear(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// Process one TF calibration step (updates on new TF bar)
// @param _hid Horizon ID (1-7) - reserved for debugging/logging
f_process_tf(_hid, _tf, newTfBar, sA, 
             cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
             TfState st,
             fcTgt, kB, aThr, pH, tpA, slA,
             alphaNVal, alpha1Val, shrinkKVal, wStateVal, wPullbackVal, wRegimeVal, wTrendVal) =>

    if newTfBar
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = array.get(st.qAge,   i)
            entry_i = array.get(st.qEntry, i)
            atr_i   = array.get(st.qAtr,   i)
            mh_i    = array.get(st.qMaxH,  i)
            ml_i    = array.get(st.qMinL,  i)
            bN_i    = array.get(st.qBinN,  i)
            b1_i    = array.get(st.qBin1,  i)
            bias_i  = array.get(st.qBias,  i)

            // Stored at entry
            float probN_i = na
            float prob1_i = na
            float lgtN_i = na
            float lgt1_i = na
            float predN_i = na
            float pred1_i = na
            if not use3Way
                probN_i := array.get(st.qProbN,  i)
                prob1_i := array.get(st.qProb1,  i)
                lgtN_i  := array.get(st.qLogitN, i)
                lgt1_i  := array.get(st.qLogit1, i)
                predN_i := array.get(st.qPredN,  i)
                pred1_i := array.get(st.qPred1,  i)

            // 3-way stored probs/logits
            float pUpN_i = na
            float pFlN_i = na
            float pDnN_i = na
            float pUp1_i = na
            float pFl1_i = na
            float pDn1_i = na
            float zUpN_i = na
            float zFlN_i = na
            float zDnN_i = na
            float zUp1_i = na
            float zFl1_i = na
            float zDn1_i = na
            if use3Way
                pUpN_i := array.get(st.qPUpN, i)
                pFlN_i := array.get(st.qPFlN, i)
                pDnN_i := array.get(st.qPDnN, i)
                pUp1_i := array.get(st.qPUp1, i)
                pFl1_i := array.get(st.qPFl1, i)
                pDn1_i := array.get(st.qPDn1, i)
                zUpN_i := array.get(st.qZUpN, i)
                zFlN_i := array.get(st.qZFlN, i)
                zDnN_i := array.get(st.qZDnN, i)
                zUp1_i := array.get(st.qZUp1, i)
                zFl1_i := array.get(st.qZFl1, i)
                zDn1_i := array.get(st.qZDn1, i)

            resolved = false
            doUpdate = false
            isUp     = false
            int outcome = 0

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                    else
                        doUpdate := true
                        if use3Way
                            db = f_db_mult(_tf) * atr_i
                            delta = cNow - entry_i
                            outcome := f_outcome3(delta, db)
                            isUp := outcome == 1
                        else
                            retATR = (cNow - entry_i) / atr_i
                            isUp := retATR >= aThr
                            outcome := isUp ? 1 : -1

            else // PathTPvsSL
                tpPx = entry_i + tpA * atr_i
                slPx = entry_i - slA * atr_i
                winHit  = mh_i >= tpPx
                lossHit = ml_i <= slPx

                if winHit or lossHit
                    resolved := true
                    doUpdate := true
                    if winHit and lossHit
                        if pathTiePolicy == "Win"
                            isUp := true
                            outcome := 1
                        else if pathTiePolicy == "Neutral"
                            if use3Way
                                outcome := 0
                            else
                                doUpdate := false
                        else
                            isUp := false
                            outcome := -1
                    else
                        isUp := winHit and not lossHit
                        outcome := isUp ? 1 : -1

                else if age_i >= pH
                    resolved := true
                    if noHitPolicy == "Loss"
                        doUpdate := true
                        isUp := false
                        outcome := -1
                    else if use3Way and (noHitPolicy == "Neutral" or noHitPolicy == "Ignore")
                        doUpdate := true
                        outcome := 0
                    else
                        doUpdate := false

            if resolved
                if doUpdate
                    if not use3Way
                        outcome := isUp ? 1 : -1
                    if use3Way
                        f_decay_counts(st.cntN, st.upN, st.dnN, countDecay)
                        f_decay_counts(st.cnt1, st.up1, st.dn1, countDecay)
                    f_cal_update3(st.cntN, st.upN, st.dnN, bN_i, outcome)
                    f_cal_update3(st.cnt1, st.up1, st.dn1, b1_i, outcome)

                    if use3Way and useBullBearCal
                        useBull = bias_i >= 0
                        cntN_sel = useBull ? st.cntN_bull : st.cntN_bear
                        upN_sel  = useBull ? st.upN_bull  : st.upN_bear
                        dnN_sel  = useBull ? st.dnN_bull  : st.dnN_bear
                        cnt1_sel = useBull ? st.cnt1_bull : st.cnt1_bear
                        up1_sel  = useBull ? st.up1_bull  : st.up1_bear
                        dn1_sel  = useBull ? st.dn1_bull  : st.dn1_bear
                        f_decay_counts(cntN_sel, upN_sel, dnN_sel, countDecay)
                        f_decay_counts(cnt1_sel, up1_sel, dn1_sel, countDecay)
                        f_cal_update3(cntN_sel, upN_sel, dnN_sel, bN_i, outcome)
                        f_cal_update3(cnt1_sel, up1_sel, dn1_sel, b1_i, outcome)
                    
                    outcomeVal = isUp ? 1.0 : 0.0
                    
                    // --- Evaluation (Live Scoring) ---
                    // Score based on the final prediction we made (predN_i / pred1_i)
                    if use3Way and ((evalMode == "History+Live") or (evalMode == "LiveOnly" and barstate.isrealtime))
                        f_eval_update_one3(st.evBrierN, st.evLogN, st.evSumBrierN, st.evSumLogN, st.evYS_N, st.evYL_N, st.evSumYS_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN, pUpN_i, pFlN_i, pDnN_i, outcome, evalRollScore, evalRollShort, evalRollLong, evalBuckets)
                        f_eval_update_one3(st.evBrier1, st.evLog1, st.evSumBrier1, st.evSumLog1, st.evYS_1, st.evYL_1, st.evSumYS_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1, pUp1_i, pFl1_i, pDn1_i, outcome, evalRollScore, evalRollShort, evalRollLong, evalBuckets)
                    else if not use3Way and ((evalMode == "History+Live") or (evalMode == "LiveOnly" and barstate.isrealtime))
                        f_eval_on_resolve(st, predN_i, pred1_i, isUp)

                    if use3Way and calibratorMode != "Off"
                        nBinN_cur = array.get(st.cntN, bN_i)
                        nBin1_cur = array.get(st.cnt1, b1_i)
                        canCalN = not cal3AutoFallback or nBinN_cur >= cal3MinSamples
                        canCal1 = not cal3AutoFallback or nBin1_cur >= cal3MinSamples
                        yU = outcome == 1 ? 1.0 : 0.0
                        yF = outcome == 0 ? 1.0 : 0.0
                        yD = outcome == -1 ? 1.0 : 0.0

                        if calibratorMode == "Temp"
                            if canCalN
                                tN = array.get(st.tempN, 0)
                                [pUNc, pFNc, pDNc] = f_softmax3(zUpN_i / tN, zFlN_i / tN, zDnN_i / tN)
                                gradN = ((pUNc - yU) * zUpN_i + (pFNc - yF) * zFlN_i + (pDNc - yD) * zDnN_i) / (tN * tN)
                                tN := f_clamp(tN - lrCal * gradN, tempMin, tempMax)
                                array.set(st.tempN, 0, tN)

                            if canCal1
                                t1 = array.get(st.temp1, 0)
                                [pU1c, pF1c, pD1c] = f_softmax3(zUp1_i / t1, zFl1_i / t1, zDn1_i / t1)
                                grad1 = ((pU1c - yU) * zUp1_i + (pF1c - yF) * zFl1_i + (pD1c - yD) * zDn1_i) / (t1 * t1)
                                t1 := f_clamp(t1 - lrCal * grad1, tempMin, tempMax)
                                array.set(st.temp1, 0, t1)
                        else if calibratorMode == "Vector"
                            if canCalN
                                aUN = array.get(st.vecAN, 0)
                                aFN = array.get(st.vecAN, 1)
                                aDN = array.get(st.vecAN, 2)
                                bUN = array.get(st.vecBN, 0)
                                bFN = array.get(st.vecBN, 1)
                                bDN = array.get(st.vecBN, 2)
                                [pUNc, pFNc, pDNc] = f_softmax3(aUN * zUpN_i + bUN, aFN * zFlN_i + bFN, aDN * zDnN_i + bDN)
                                aUN := f_clamp(aUN - lrCal * (pUNc - yU) * zUpN_i, vecAMin, vecAMax)
                                aFN := f_clamp(aFN - lrCal * (pFNc - yF) * zFlN_i, vecAMin, vecAMax)
                                aDN := f_clamp(aDN - lrCal * (pDNc - yD) * zDnN_i, vecAMin, vecAMax)
                                bUN := f_clamp(bUN - lrCal * (pUNc - yU), vecBMin, vecBMax)
                                bFN := f_clamp(bFN - lrCal * (pFNc - yF), vecBMin, vecBMax)
                                bDN := f_clamp(bDN - lrCal * (pDNc - yD), vecBMin, vecBMax)
                                array.set(st.vecAN, 0, aUN)
                                array.set(st.vecAN, 1, aFN)
                                array.set(st.vecAN, 2, aDN)
                                array.set(st.vecBN, 0, bUN)
                                array.set(st.vecBN, 1, bFN)
                                array.set(st.vecBN, 2, bDN)

                            if canCal1
                                aU1 = array.get(st.vecA1, 0)
                                aF1 = array.get(st.vecA1, 1)
                                aD1 = array.get(st.vecA1, 2)
                                bU1 = array.get(st.vecB1, 0)
                                bF1 = array.get(st.vecB1, 1)
                                bD1 = array.get(st.vecB1, 2)
                                [pU1c, pF1c, pD1c] = f_softmax3(aU1 * zUp1_i + bU1, aF1 * zFl1_i + bF1, aD1 * zDn1_i + bD1)
                                aU1 := f_clamp(aU1 - lrCal * (pU1c - yU) * zUp1_i, vecAMin, vecAMax)
                                aF1 := f_clamp(aF1 - lrCal * (pF1c - yF) * zFl1_i, vecAMin, vecAMax)
                                aD1 := f_clamp(aD1 - lrCal * (pD1c - yD) * zDn1_i, vecAMin, vecAMax)
                                bU1 := f_clamp(bU1 - lrCal * (pU1c - yU), vecBMin, vecBMax)
                                bF1 := f_clamp(bF1 - lrCal * (pF1c - yF), vecBMin, vecBMax)
                                bD1 := f_clamp(bD1 - lrCal * (pD1c - yD), vecBMin, vecBMax)
                                array.set(st.vecA1, 0, aU1)
                                array.set(st.vecA1, 1, aF1)
                                array.set(st.vecA1, 2, aD1)
                                array.set(st.vecB1, 0, bU1)
                                array.set(st.vecB1, 1, bF1)
                                array.set(st.vecB1, 2, bD1)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    if not use3Way
                        nBinN_cur = array.get(st.cntN, bN_i)
                        if nBinN_cur >= calMinSamples
                            // Brier on raw prob
                            sqErrN = math.pow(outcomeVal - probN_i, 2)
                            curSumN = array.get(st.brierStatsN, 0)
                            curCntN = array.get(st.brierStatsN, 1)
                            array.set(st.brierStatsN, 0, curSumN + sqErrN)
                            array.set(st.brierStatsN, 1, curCntN + 1.0)
                            
                            // Platt SGD
                            if usePlatt
                                aN = array.get(st.plattN, 0)
                                bN = array.get(st.plattN, 1)
                                pAdj = f_sigmoid(aN * lgtN_i + bN)
                                err = pAdj - outcomeVal
                                da = err * lgtN_i
                                db = err
                                // Update
                                aN := math.max(0.1, math.min(5.0, aN - lrPlatt * da)) 
                                bN := math.max(-3.0, math.min(3.0, bN - lrPlatt * db))
                                array.set(st.plattN, 0, aN)
                                array.set(st.plattN, 1, bN)
                                
                                // LogLoss
                                pLL = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj))
                                ll = -(outcomeVal * math.log(pLL) + (1.0 - outcomeVal) * math.log(1.0 - pLL))
                                curSumLL = array.get(st.llStatsN, 0)
                                curCntLL = array.get(st.llStatsN, 1)
                                array.set(st.llStatsN, 0, curSumLL + ll)
                                array.set(st.llStatsN, 1, curCntLL + 1.0)
                        
                        // --- Phase 4: SGD Update & LogLoss (1) ---
                        sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                        curSum1 = array.get(st.brierStats1, 0)
                        curCnt1 = array.get(st.brierStats1, 1)
                        array.set(st.brierStats1, 0, curSum1 + sqErr1)
                        array.set(st.brierStats1, 1, curCnt1 + 1.0)

                        if usePlatt
                            pltA1 = array.get(st.platt1, 0)
                            pltB1 = array.get(st.platt1, 1)
                            pAdj1 = f_sigmoid(pltA1 * lgt1_i + pltB1)
                            err1 = pAdj1 - outcomeVal
                            da1 = err1 * lgt1_i
                            db1 = err1
                            pltA1 := math.max(0.1, math.min(5.0, pltA1 - lrPlatt * da1))
                            pltB1 := math.max(-3.0, math.min(3.0, pltB1 - lrPlatt * db1))
                            array.set(st.platt1, 0, pltA1)
                            array.set(st.platt1, 1, pltB1)
                            
                            pLL1 = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj1))
                            ll1 = -(outcomeVal * math.log(pLL1) + (1.0 - outcomeVal) * math.log(1.0 - pLL1))
                            curSumLL1 = array.get(st.llStats1, 0)
                            curCntLL1 = array.get(st.llStats1, 1)
                            array.set(st.llStats1, 0, curSumLL1 + ll1)
                            array.set(st.llStats1, 1, curCntLL1 + 1.0)

                if not use3Way
                    array.remove(st.qProbN, i)
                    array.remove(st.qProb1, i)
                    array.remove(st.qLogitN, i)
                    array.remove(st.qLogit1, i)
                    array.remove(st.qPredN, i)
                    array.remove(st.qPred1, i)
                if use3Way
                    array.remove(st.qPUpN, i)
                    array.remove(st.qPFlN, i)
                    array.remove(st.qPDnN, i)
                    array.remove(st.qPUp1, i)
                    array.remove(st.qPFl1, i)
                    array.remove(st.qPDn1, i)
                    array.remove(st.qZUpN, i)
                    array.remove(st.qZFlN, i)
                    array.remove(st.qZDnN, i)
                    array.remove(st.qZUp1, i)
                    array.remove(st.qZFl1, i)
                    array.remove(st.qZDn1, i)
                array.remove(st.qAge,   i)
                array.remove(st.qMaxH,  i)
                array.remove(st.qMinL,  i)
                array.remove(st.qAtr,   i)
                array.remove(st.qEntry, i)
                array.remove(st.qBinN,  i)
                array.remove(st.qBin1,  i)
                array.remove(st.qBias, i)
            i -= 1
        bias = emaFNow > emaSNow ? 1 : -1
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        atrNorm = atrNow / nz(cNow, 1)
        sD = f_trend_regime(emaFNow, emaSNow, atrNorm)
        sEns = f_ensemble4(sA, sB, sC, sD, wStateVal, wPullbackVal, wRegimeVal, wTrendVal)
        f_update_quantiles(sEns)
        
        // --- Phase 2: 2D Binning ---
        bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, qCutsN)
        b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, qCuts1)

        biasFlag = useBullBearCal ? f_bias_from_score(sA) : 0
        cntN_sel = useBullBearCal ? (biasFlag >= 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        upN_sel  = useBullBearCal ? (biasFlag >= 0 ? st.upN_bull  : st.upN_bear)  : st.upN
        dnN_sel  = useBullBearCal ? (biasFlag >= 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
        cnt1_sel = useBullBearCal ? (biasFlag >= 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
        up1_sel  = useBullBearCal ? (biasFlag >= 0 ? st.up1_bull  : st.up1_bear)  : st.up1
        dn1_sel  = useBullBearCal ? (biasFlag >= 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1

        if use3Way
            [pUrawN, pFrawN, pDrawN, _nN] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaNVal, shrinkKVal, kShrinkReg)
            [pUraw1, pFraw1, pDraw1, _n1] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1Val, shrinkKVal, kShrinkReg)

            zUN = f_safe_log(pUrawN)
            zFN = f_safe_log(pFrawN)
            zDN = f_safe_log(pDrawN)
            zU1 = f_safe_log(pUraw1)
            zF1 = f_safe_log(pFraw1)
            zD1 = f_safe_log(pDraw1)

            useCalN = f_can_cal3(_nN)
            useCal1 = f_can_cal3(_n1)
            [pUN, pFN, pDN] = useCalN ? f_cal_apply(zUN, zFN, zDN, st.tempN, st.vecAN, st.vecBN) : [pUrawN, pFrawN, pDrawN]
            [pU1, pF1, pD1] = useCal1 ? f_cal_apply(zU1, zF1, zD1, st.temp1, st.vecA1, st.vecB1) : [pUraw1, pFraw1, pDraw1]

            array.push(st.qBinN,  bN)
            array.push(st.qBin1,  b1)
            array.push(st.qEntry, cNow)
            array.push(st.qAtr,   atrNow)

            array.push(st.qMaxH,  cNow)
            array.push(st.qMinL,  cNow)

            array.push(st.qAge,   0)
            array.push(st.qBias,  biasFlag)

            array.push(st.qPUpN, pUN)
            array.push(st.qPFlN, pFN)
            array.push(st.qPDnN, pDN)
            array.push(st.qPUp1, pU1)
            array.push(st.qPFl1, pF1)
            array.push(st.qPDn1, pD1)

            array.push(st.qZUpN, zUN)
            array.push(st.qZFlN, zFN)
            array.push(st.qZDnN, zDN)
            array.push(st.qZUp1, zU1)
            array.push(st.qZFl1, zF1)
            array.push(st.qZDn1, zD1)
        else
            // Capture current probabilities
            [pNowN, _nN] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
            [pNow1, _n1] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)

            // Logits (Phase 4)
            lgtN = f_logit(pNowN)
            lgt1 = f_logit(pNow1)

            // Platt Adjust (Display/Predict)
            aN = array.get(st.plattN, 0)
            bN_p = array.get(st.plattN, 1)
            pAdjN = f_sigmoid(aN * lgtN + bN_p)

            pltA1 = array.get(st.platt1, 0)
            pltB1_p = array.get(st.platt1, 1)
            pAdj1 = f_sigmoid(pltA1 * lgt1 + pltB1_p)

            // Use adjusted if Platt enabled, else raw
            pFinalN = usePlatt ? pAdjN : pNowN
            pFinal1 = usePlatt ? pAdj1 : pNow1

            array.push(st.qBinN,  bN)
            array.push(st.qBin1,  b1)
            array.push(st.qEntry, cNow)
            array.push(st.qAtr,   atrNow)

            array.push(st.qMaxH,  cNow)
            array.push(st.qMinL,  cNow)

            array.push(st.qAge,   0)
            array.push(st.qBias,  biasFlag)

            array.push(st.qProbN, pNowN)
            array.push(st.qProb1, pNow1)
            array.push(st.qLogitN, lgtN)
            array.push(st.qLogit1, lgt1)
            array.push(st.qPredN, pFinalN)
            array.push(st.qPred1, pFinal1)

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ? ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("300")) ? rsiLenFastTF : (not na(baseSecs) and baseSecs <= timeframe.in_seconds("3600")) ? rsiLenMidTF : rsiLenSlowTF) : rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime (protect against close=0 on exotic instruments)
atrRank = close == 0 ? 0.5 : f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? nz(volRankRaw, 0.5) : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // global per-bar
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)

    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier = config == "Standard" ? 1.00 : config == "Pro" ? 1.05 : config == "V2 Essential" ? 0.95 : config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30")) ? "Short" : (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown
gateLongNow  = (confidence >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidence >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice = zoneAnchor == "Entry" and not na(entryPrice) ? entryPrice : zoneAnchor == "VWAP" ? vwapVal : zoneAnchor == "MA200" ? sma200Val : zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "â€”"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)

f_getBrier(tfSel, modSel) =>
    float score = 0.5 // default safe
    
    // Select array pair stats
    float[] stats = na
    if tfSel == "F1"
        stats := (modSel == "N") ? tf1State.brierStatsN : tf1State.brierStats1
    else if tfSel == "F2"
        stats := (modSel == "N") ? tf2State.brierStatsN : tf2State.brierStats1
    else if tfSel == "F3"
        stats := (modSel == "N") ? tf3State.brierStatsN : tf3State.brierStats1
    else if tfSel == "F4"
        stats := (modSel == "N") ? tf4State.brierStatsN : tf4State.brierStats1
    else if tfSel == "F5"
        stats := (modSel == "N") ? tf5State.brierStatsN : tf5State.brierStats1
    else if tfSel == "F6"
        stats := (modSel == "N") ? tf6State.brierStatsN : tf6State.brierStats1
    else if tfSel == "F7"
        stats := (modSel == "N") ? tf7State.brierStatsN : tf7State.brierStats1
    
    if not na(stats)
        s = array.get(stats, 0)
        c = array.get(stats, 1)
        if c > 0
            score := s / c
    score

f_get_total_samples(tfSel, modSel) =>
    float total = 0.0
    float[] cnt = na
    if tfSel == "F1"
        cnt := (modSel == "N") ? tf1State.cntN : tf1State.cnt1
    else if tfSel == "F2"
        cnt := (modSel == "N") ? tf2State.cntN : tf2State.cnt1
    else if tfSel == "F3"
        cnt := (modSel == "N") ? tf3State.cntN : tf3State.cnt1
    else if tfSel == "F4"
        cnt := (modSel == "N") ? tf4State.cntN : tf4State.cnt1
    else if tfSel == "F5"
        cnt := (modSel == "N") ? tf5State.cntN : tf5State.cnt1
    else if tfSel == "F6"
        cnt := (modSel == "N") ? tf6State.cntN : tf6State.cnt1
    else if tfSel == "F7"
        cnt := (modSel == "N") ? tf7State.cntN : tf7State.cnt1

    if not na(cnt)
        total := array.sum(cnt)
    total

curBrier = f_getBrier(relFilterTF, relFilterModel)
reliabilityOk = (not useRelFilter) or (curBrier <= maxBrier)
evidenceOk = (not evidenceGate) or (f_get_total_samples(relFilterTF, relFilterModel) >= evidenceMinTotal)

[pRelU, pRelF, pRelD, nRel, totRel] = f_get_rel_vals(relFilterTF, relFilterModel)
[decisionOk, decisionLabel, decisionColor, decisionEdge] = f_decision_quality(pRelU, pRelF, pRelD, nRel, totRel)
decisionEdgeTxt = (not use3Way or na(decisionEdge)) ? "â€”" : str.tostring(decisionEdge * 100.0, "#.1") + "pp"

allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose and reliabilityOk and evidenceOk and (not abstainGate or decisionOk)
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"

//====================
// Alerts
//====================
alertcondition(buySignal,   title="BUY",   message="BUY")
alertcondition(exitSignal,  title="EXIT",  message="EXIT")
alertcondition(shortSignal, title="SHORT", message="SHORT")
alertcondition(coverSignal, title="COVER", message="COVER")

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 25))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Outlook/Forecast packs (one security call per horizon TF)
//====================
[t1, c1, h1, l1, ef1, es1, r1, a1, vR1] = f_tf_pack(tfF1)
[t2, c2, h2, l2, ef2, es2, r2, a2, vR2] = f_tf_pack(tfF2)
[t3, c3, h3, l3, ef3, es3, r3, a3, vR3] = f_tf_pack(tfF3)
[t4, c4, h4, l4, ef4, es4, r4, a4, vR4] = f_tf_pack(tfF4)
[t5, c5, h5, l5, ef5, es5, r5, a5, vR5] = f_tf_pack(tfF5)
[t6, c6, h6, l6, ef6, es6, r6, a6, vR6] = f_tf_pack(tfF6)
[t7, c7, h7, l7, ef7, es7, r7, a7, vR7] = f_tf_pack(tfF7)

// Get Target Params per TF
[fcT1, kB1, aT1, pH1, tp1, sl1] = f_get_params(tfF1)
[fcT2, kB2, aT2, pH2, tp2, sl2] = f_get_params(tfF2)
[fcT3, kB3, aT3, pH3, tp3, sl3] = f_get_params(tfF3)
[fcT4, kB4, aT4, pH4, tp4, sl4] = f_get_params(tfF4)
[fcT5, kB5, aT5, pH5, tp5, sl5] = f_get_params(tfF5)
[fcT6, kB6, aT6, pH6, tp6, sl6] = f_get_params(tfF6)
[fcT7, kB7, aT7, pH7, tp7, sl7] = f_get_params(tfF7)

chgT1 = ta.change(t1)
chgT2 = ta.change(t2)
chgT3 = ta.change(t3)
chgT4 = ta.change(t4)
chgT5 = ta.change(t5)
chgT6 = ta.change(t6)
chgT7 = ta.change(t7)

newF1 = not na(t1) and (chgT1 != 0)
newF2 = not na(t2) and (chgT2 != 0)
newF3 = not na(t3) and (chgT3 != 0)
newF4 = not na(t4) and (chgT4 != 0)
newF5 = not na(t5) and (chgT5 != 0)
newF6 = not na(t6) and (chgT6 != 0)
newF7 = not na(t7) and (chgT7 != 0)

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

[t1c, m1c, l1c] = f_state_tml(c1, ef1, es1, r1)
[t2c, m2c, l2c] = f_state_tml(c2, ef2, es2, r2)
[t3c, m3c, l3c] = f_state_tml(c3, ef3, es3, r3)
[t4c, m4c, l4c] = f_state_tml(c4, ef4, es4, r4)
[t5c, m5c, l5c] = f_state_tml(c5, ef5, es5, r5)
[t6c, m6c, l6c] = f_state_tml(c6, ef6, es6, r6)
[t7c, m7c, l7c] = f_state_tml(c7, ef7, es7, r7)

outSym(score) => score > 0.05 ? "â–²" : score < -0.05 ? "â–¼" : "âˆ’"
outCol(score) => score > 0.05 ? color.lime : score < -0.05 ? color.red : tblText

isBull1 = f_bias_from_score(outScore1) == 1
isBull2 = f_bias_from_score(outScore2) == 1
isBull3 = f_bias_from_score(outScore3) == 1
isBull4 = f_bias_from_score(outScore4) == 1
isBull5 = f_bias_from_score(outScore5) == 1
isBull6 = f_bias_from_score(outScore6) == 1
isBull7 = f_bias_from_score(outScore7) == 1

cntN1Arr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull : tf1State.cntN_bear) : tf1State.cntN
cnt11Arr = useBullBearCal ? (isBull1 ? tf1State.cnt1_bull : tf1State.cnt1_bear) : tf1State.cnt1
cntN2Arr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull : tf2State.cntN_bear) : tf2State.cntN
cnt12Arr = useBullBearCal ? (isBull2 ? tf2State.cnt1_bull : tf2State.cnt1_bear) : tf2State.cnt1
cntN3Arr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull : tf3State.cntN_bear) : tf3State.cntN
cnt13Arr = useBullBearCal ? (isBull3 ? tf3State.cnt1_bull : tf3State.cnt1_bear) : tf3State.cnt1
cntN4Arr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull : tf4State.cntN_bear) : tf4State.cntN
cnt14Arr = useBullBearCal ? (isBull4 ? tf4State.cnt1_bull : tf4State.cnt1_bear) : tf4State.cnt1
cntN5Arr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull : tf5State.cntN_bear) : tf5State.cntN
cnt15Arr = useBullBearCal ? (isBull5 ? tf5State.cnt1_bull : tf5State.cnt1_bear) : tf5State.cnt1
cntN6Arr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull : tf6State.cntN_bear) : tf6State.cntN
cnt16Arr = useBullBearCal ? (isBull6 ? tf6State.cnt1_bull : tf6State.cnt1_bear) : tf6State.cnt1
cntN7Arr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull : tf7State.cntN_bear) : tf7State.cntN
cnt17Arr = useBullBearCal ? (isBull7 ? tf7State.cnt1_bull : tf7State.cnt1_bear) : tf7State.cnt1

//====================
// Calibration storage â€” per horizon TF (Removed - moved to top)
//====================
// (Moved to top level state)

//====================
// Reset handling (rising edge) â€” per horizon F1..F7
//====================
var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    switch resetWhich
        "All" => f_reset_eval_all()
        "F1"  => f_reset_tf(tf1State)
        "F2"  => f_reset_tf(tf2State)
        "F3"  => f_reset_tf(tf3State)
        "F4"  => f_reset_tf(tf4State)
        "F5"  => f_reset_tf(tf5State)
        "F6"  => f_reset_tf(tf6State)
        "F7"  => f_reset_tf(tf7State)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed
if doCal
    f_process_tf(1, tfF1, newF1, outScore1, c1, h1, l1, a1, vR1, ef1, es1, tf1State, fcT1, kB1, aT1, pH1, tp1, sl1, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(2, tfF2, newF2, outScore2, c2, h2, l2, a2, vR2, ef2, es2, tf2State, fcT2, kB2, aT2, pH2, tp2, sl2, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(3, tfF3, newF3, outScore3, c3, h3, l3, a3, vR3, ef3, es3, tf3State, fcT3, kB3, aT3, pH3, tp3, sl3, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(4, tfF4, newF4, outScore4, c4, h4, l4, a4, vR4, ef4, es4, tf4State, fcT4, kB4, aT4, pH4, tp4, sl4, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(5, tfF5, newF5, outScore5, c5, h5, l5, a5, vR5, ef5, es5, tf5State, fcT5, kB5, aT5, pH5, tp5, sl5, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(6, tfF6, newF6, outScore6, c6, h6, l6, a6, vR6, ef6, es6, tf6State, fcT6, kB6, aT6, pH6, tp6, sl6, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(7, tfF7, newF7, outScore7, c7, h7, l7, a7, vR7, ef7, es7, tf7State, fcT7, kB7, aT7, pH7, tp7, sl7, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

f_get_disp_vals(_tf, sA, c, atrVal, ef, es, vr, TfState st) =>
    bias = ef > es ? 1 : -1
    sB = f_pullback_score(c, ef, es, bias)
    sC = vr >= VOL_THRESH_HIGH ? -1.0 : (vr <= VOL_THRESH_LOW ? 1.0 : 0.0)
    atrNorm = atrVal / nz(c, 1)
    sD = f_trend_regime(ef, es, atrNorm)
    sEns = f_ensemble4(sA, sB, sC, sD, wState, wPullback, wRegime, wTrend)
    bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, qCutsN)
    b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, qCuts1)
    biasSel = useBullBearCal ? f_bias_from_score(sA) : 0
    cntN_sel = useBullBearCal ? (biasSel >= 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
    upN_sel  = useBullBearCal ? (biasSel >= 0 ? st.upN_bull  : st.upN_bear)  : st.upN
    dnN_sel  = useBullBearCal ? (biasSel >= 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
    cnt1_sel = useBullBearCal ? (biasSel >= 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
    up1_sel  = useBullBearCal ? (biasSel >= 0 ? st.up1_bull  : st.up1_bear)  : st.up1
    dn1_sel  = useBullBearCal ? (biasSel >= 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1
    [pUN, pFN, pDN, nN] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaN, kShrink, kShrinkReg)
    [pU1, pF1, pD1, n1] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1, kShrink, kShrinkReg)
    useCalN = f_can_cal3(nN)
    useCal1 = f_can_cal3(n1)
    if useCalN
        zUN = f_safe_log(pUN)
        zFN = f_safe_log(pFN)
        zDN = f_safe_log(pDN)
        [pUN, pFN, pDN] := f_cal_apply(zUN, zFN, zDN, st.tempN, st.vecAN, st.vecBN)
    if useCal1
        zU1 = f_safe_log(pU1)
        zF1 = f_safe_log(pF1)
        zD1 = f_safe_log(pD1)
        [pU1, pF1, pD1] := f_cal_apply(zU1, zF1, zD1, st.temp1, st.vecA1, st.vecB1)
    [pUN, pFN, pDN, nN, pU1, pF1, pD1, n1]

//====================
// Display values â€” N and 1 per horizon
//====================
[pUN1, pFN1, pDN1, nN1, pU11, pF11, pD11, n11p] = f_get_disp_vals(tfF1, outScore1, c1, a1, ef1, es1, vR1, tf1State)
[pUN2, pFN2, pDN2, nN2, pU12, pF12, pD12, n12p] = f_get_disp_vals(tfF2, outScore2, c2, a2, ef2, es2, vR2, tf2State)
[pUN3, pFN3, pDN3, nN3, pU13, pF13, pD13, n13p] = f_get_disp_vals(tfF3, outScore3, c3, a3, ef3, es3, vR3, tf3State)
[pUN4, pFN4, pDN4, nN4, pU14, pF14, pD14, n14p] = f_get_disp_vals(tfF4, outScore4, c4, a4, ef4, es4, vR4, tf4State)
[pUN5, pFN5, pDN5, nN5, pU15, pF15, pD15, n15p] = f_get_disp_vals(tfF5, outScore5, c5, a5, ef5, es5, vR5, tf5State)
[pUN6, pFN6, pDN6, nN6, pU16, pF16, pD16, n16p] = f_get_disp_vals(tfF6, outScore6, c6, a6, ef6, es6, vR6, tf6State)
[pUN7, pFN7, pDN7, nN7, pU17, pF17, pD17, n17p] = f_get_disp_vals(tfF7, outScore7, c7, a7, ef7, es7, vR7, tf7State)

// --- Total resolved samples per TF (across all bins)
totN1 = f_sum_int_array(cntN1Arr)
totN2 = f_sum_int_array(cntN2Arr)
totN3 = f_sum_int_array(cntN3Arr)
totN4 = f_sum_int_array(cntN4Arr)
totN5 = f_sum_int_array(cntN5Arr)
totN6 = f_sum_int_array(cntN6Arr)
totN7 = f_sum_int_array(cntN7Arr)

tot11 = f_sum_int_array(cnt11Arr)
tot12 = f_sum_int_array(cnt12Arr)
tot13 = f_sum_int_array(cnt13Arr)
tot14 = f_sum_int_array(cnt14Arr)
tot15 = f_sum_int_array(cnt15Arr)
tot16 = f_sum_int_array(cnt16Arr)
tot17 = f_sum_int_array(cnt17Arr)

// calibration â€œenabled for displayâ€ if forecast enabled + we have any resolved samples in that TF
canF1N = enableForecast and (totN1 > 0)
canF2N = enableForecast and (totN2 > 0)
canF3N = enableForecast and (totN3 > 0)
canF4N = enableForecast and (totN4 > 0)
canF5N = enableForecast and (totN5 > 0)
canF6N = enableForecast and (totN6 > 0)
canF7N = enableForecast and (totN7 > 0)

canF11 = enableForecast and (tot11 > 0)
canF12 = enableForecast and (tot12 > 0)
canF13 = enableForecast and (tot13 > 0)
canF14 = enableForecast and (tot14 > 0)
canF15 = enableForecast and (tot15 > 0)
canF16 = enableForecast and (tot16 > 0)
canF17 = enableForecast and (tot17 > 0)

f_get_rel_vals(tfSel, modSel) =>
    float pU = na
    float pF = na
    float pD = na
    float nBin = na
    float total = na
    if modSel == "N"
        if tfSel == "F1"
            pU := pUN1, pF := pFN1, pD := pDN1, nBin := nN1, total := totN1
        else if tfSel == "F2"
            pU := pUN2, pF := pFN2, pD := pDN2, nBin := nN2, total := totN2
        else if tfSel == "F3"
            pU := pUN3, pF := pFN3, pD := pDN3, nBin := nN3, total := totN3
        else if tfSel == "F4"
            pU := pUN4, pF := pFN4, pD := pDN4, nBin := nN4, total := totN4
        else if tfSel == "F5"
            pU := pUN5, pF := pFN5, pD := pDN5, nBin := nN5, total := totN5
        else if tfSel == "F6"
            pU := pUN6, pF := pFN6, pD := pDN6, nBin := nN6, total := totN6
        else if tfSel == "F7"
            pU := pUN7, pF := pFN7, pD := pDN7, nBin := nN7, total := totN7
    else
        if tfSel == "F1"
            pU := pU11, pF := pF11, pD := pD11, nBin := n11p, total := tot11
        else if tfSel == "F2"
            pU := pU12, pF := pF12, pD := pD12, nBin := n12p, total := tot12
        else if tfSel == "F3"
            pU := pU13, pF := pF13, pD := pD13, nBin := n13p, total := tot13
        else if tfSel == "F4"
            pU := pU14, pF := pF14, pD := pD14, nBin := n14p, total := tot14
        else if tfSel == "F5"
            pU := pU15, pF := pF15, pD := pD15, nBin := n15p, total := tot15
        else if tfSel == "F6"
            pU := pU16, pF := pF16, pD := pD16, nBin := n16p, total := tot16
        else if tfSel == "F7"
            pU := pU17, pF := pF17, pD := pD17, nBin := n17p, total := tot17
    [pU, pF, pD, nBin, total]

f_decision_quality(pU, pF, pD, nBin, total) =>
    maxP = math.max(pU, math.max(pF, pD))
    minP = math.min(pU, math.min(pF, pD))
    midP = (pU + pF + pD) - maxP - minP
    edge = maxP - midP
    totalOk = (not evidenceGate) or (total >= evidenceMinTotal)
    ok = (not use3Way) ? true : (edge >= abstainMinEdge and nBin >= calMinSamples and totalOk)
    reason = (evidenceGate and total < evidenceMinTotal) ? "low total" : nBin < calMinSamples ? "weak bin" : edge < abstainMinEdge ? "low edge" : "ok"
    label = ok ? "OK" : "ABSTAIN (" + reason + ")"
    col = ok ? color.lime : color.orange
    [ok, label, col, edge]

//====================
// Table helpers MUST be global (cannot be defined inside if-block)
//====================
var table gT = na
if na(gT)
    tblCols = fcTblModel == "Both" ? 12 : 9
    tblRows = 16
    gT := table.new(position.middle_right, tblCols, tblRows, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

f_rowTF(_tf, score, tC, mC, lC, rV,
        pUN, pFN, pDN, totN,
        pU1, pF1, pD1, tot1,
        rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(_tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 1, rRow, outSym(score),  text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, rRow, str.tostring(tC) + "/" + str.tostring(mC) + "/" + str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    enabled = enableForecast
    useCalN = enabled and (totN >= calMinSamples)
    [pUprio, pFprio, pDprio] = f_prior3(_tf, score)
    pU = useCalN ? pUN : pUprio
    pF = useCalN ? pFN : pFprio
    pD = useCalN ? pDN : pDprio

    maxP = math.max(pU, math.max(pF, pD))
    dirSym = maxP < dirMinProb ? "Â·" : (pU == maxP ? "â–²" : pD == maxP ? "â–¼" : "â– ")

    table.cell(gT, 5, rRow, "â–² " + str.tostring(pU * 100, "#.0"), text_color=color.lime, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 6, rRow, "âˆ’ " + str.tostring(pF * 100, "#.0"), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 7, rRow, "â–¼ " + str.tostring(pD * 100, "#.0"), text_color=color.red, bgcolor=tblCell, text_size=size.tiny)

    lbl = f_samp_label(enabled, totN) + " (" + str.tostring(totN) + ") " + dirSym
    labelCol = fcTblModel == "Both" ? 11 : 8
    table.cell(gT, labelCol, rRow, lbl, text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)

    if fcTblModel == "Both"
        useCal1 = enabled and (tot1 >= calMinSamples)
        pU1d = useCal1 ? pU1 : pUprio
        pF1d = useCal1 ? pF1 : pFprio
        pD1d = useCal1 ? pD1 : pDprio
        table.cell(gT, 8,  rRow, "â–² " + str.tostring(pU1d * 100, "#.0"), text_color=color.lime, bgcolor=tblCell, text_size=size.tiny)
        table.cell(gT, 9,  rRow, "âˆ’ " + str.tostring(pF1d * 100, "#.0"), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
        table.cell(gT, 10, rRow, "â–¼ " + str.tostring(pD1d * 100, "#.0"), text_color=color.red, bgcolor=tblCell, text_size=size.tiny)

f_fmtBrier(stats) =>
    s = array.get(stats, 0)
    c = array.get(stats, 1)
    val = c > 0 ? s / c : na
    txt = na(val) ? "â€”" : str.tostring(val, "#.###")
    col = na(val) ? tblTextDim : val < 0.20 ? color.green : val < 0.25 ? color.lime : val < 0.30 ? color.yellow : color.red
    [txt, col]

f_fmtCnt(stats) =>
    c = array.get(stats, 1)
    [str.tostring(c, "#"), c < 10 ? tblTextDim : tblText]

f_rowRel(tf, statsN, stats1, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    
    [tBN, cBN] = f_fmtBrier(statsN)
    table.cell(gT, 1, rRow, tBN, text_color=cBN, bgcolor=tblCell, text_size=size.tiny)
    
    [tB1, cB1] = f_fmtBrier(stats1)
    table.cell(gT, 2, rRow, tB1, text_color=cB1, bgcolor=tblCell, text_size=size.tiny)
    
    [tcN, ccN] = f_fmtCnt(statsN)
    table.cell(gT, 3, rRow, tcN, text_color=ccN, bgcolor=tblCell, text_size=size.tiny)
    
    [tc1, cc1] = f_fmtCnt(stats1)
    table.cell(gT, 4, rRow, tc1, text_color=cc1, bgcolor=tblCell, text_size=size.tiny)

//====================
// Table (5 columns) â€” rendered on confirmed bars (stable)
//====================
mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow
c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblText

targetDesc = "Multi-Profile (See Settings). Fast: " + fcTargetF + ", Mid: " + fcTargetM + ", Slow: " + fcTargetS

if showTable and barstate.isconfirmed
    tblCols = fcTblModel == "Both" ? 12 : 9
    table.clear(gT, 0, 0, tblCols - 1, 15)

    // Status rows
    table.cell(gT, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(gT, 2, 0, "Decision", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 0, decisionLabel, text_color=decisionColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, 0, decisionEdgeTxt, text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 2, volStr,   text_color=c_vol,      bgcolor=tblCell,   text_size=size.tiny)

    table.cell(gT, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 3, strengthStr, text_color=c_strength, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)


//====================
// Calibration Diagnostics Panel (Debug)
//====================
var table diagTbl = na
if showDiagPanel and na(diagTbl)
    diagTbl := table.new(position.top_right, 2, 18, bgcolor=color.new(color.black, 85), frame_color=color.gray, frame_width=1, border_color=color.gray, border_width=1)

// Helper to get selected TfState
f_get_diag_state() =>
    diagHorizon == "F1" ? tf1State : diagHorizon == "F2" ? tf2State : diagHorizon == "F3" ? tf3State : diagHorizon == "F4" ? tf4State : diagHorizon == "F5" ? tf5State : diagHorizon == "F6" ? tf6State : tf7State

if showDiagPanel and barstate.islast
    st = f_get_diag_state()

    isBullDiag = f_bias_from_score(diagHorizon == "F1" ? outScore1 : diagHorizon == "F2" ? outScore2 : diagHorizon == "F3" ? outScore3 : diagHorizon == "F4" ? outScore4 : diagHorizon == "F5" ? outScore5 : diagHorizon == "F6" ? outScore6 : outScore7) == 1
    
    // Select model arrays
    cntArr = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.cntN_bull : st.cntN_bear) : st.cntN) : (useBullBearCal ? (isBullDiag ? st.cnt1_bull : st.cnt1_bear) : st.cnt1)
    upArr  = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.upN_bull  : st.upN_bear)  : st.upN)  : (useBullBearCal ? (isBullDiag ? st.up1_bull  : st.up1_bear)  : st.up1)
    plattArr = diagModel == "N" ? st.plattN : st.platt1
    brierStats = diagModel == "N" ? st.brierStatsN : st.brierStats1
    llStats = diagModel == "N" ? st.llStatsN : st.llStats1
    
    // Platt params
    plattA = array.get(plattArr, 0)
    plattB = array.get(plattArr, 1)
    
    // Brier/LogLoss
    brierSum = array.get(brierStats, 0)
    brierCnt = array.get(brierStats, 1)
    brierAvg = brierCnt > 0 ? brierSum / brierCnt : na
    
    llSum = array.get(llStats, 0)
    llCnt = array.get(llStats, 1)
    llAvg = llCnt > 0 ? llSum / llCnt : na
    
    // Bin samples (total and per-bin distribution)
    totalSamples = array.sum(cntArr)
    numBins = array.size(cntArr)
    
    // Bin distribution (min/max/avg samples per bin)
    minBin = numBins > 0 ? array.min(cntArr) : 0
    maxBin = numBins > 0 ? array.max(cntArr) : 0
    avgBin = numBins > 0 ? totalSamples / numBins : 0
    
    // Win rate (overall calibrated base rate)
    totalUp = array.sum(upArr)
    baseRate = totalSamples > 0 ? totalUp * 100.0 / totalSamples : 50.0
    
    // Convergence check: Is Platt A stable (should be near 1.0 if well-calibrated)?
    plattStable = (plattA >= 0.7 and plattA <= 1.5) and (plattB >= -0.5 and plattB <= 0.5)
    convStatus = plattStable ? "âœ… Converged" : (plattA < 0.3 or plattA > 3.0) ? "âš ï¸ Unstable" : "ðŸ”„ Adjusting"
    convColor = plattStable ? color.lime : (plattA < 0.3 or plattA > 3.0) ? color.red : color.yellow
    
    // Quality grade
    qualityGrade = na(brierAvg) ? "â€”" : brierAvg < 0.18 ? "A (Excellent)" : brierAvg < 0.22 ? "B (Good)" : brierAvg < 0.25 ? "C (Baseline)" : brierAvg < 0.30 ? "D (Poor)" : "F (No Skill)"
    qualityColor = na(brierAvg) ? color.gray : brierAvg < 0.18 ? color.lime : brierAvg < 0.22 ? color.green : brierAvg < 0.25 ? color.yellow : brierAvg < 0.30 ? color.orange : color.red
    
    // Row 0: Header
    table.cell(diagTbl, 0, 0, "ðŸ”§ Calibration Diagnostics", text_color=color.white, bgcolor=color.new(color.blue, 70), text_size=size.small)
    table.cell(diagTbl, 1, 0, diagHorizon + " / " + diagModel, text_color=color.aqua, bgcolor=color.new(color.blue, 70), text_size=size.small)
    
    // Row 1: Platt A
    table.cell(diagTbl, 0, 1, "Platt A (slope)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 1, str.tostring(plattA, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 2: Platt B
    table.cell(diagTbl, 0, 2, "Platt B (intercept)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 2, str.tostring(plattB, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 3: Convergence status
    table.cell(diagTbl, 0, 3, "SGD Status", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 3, convStatus, text_color=convColor, text_size=size.tiny)
    
    // Row 4: Separator
    table.cell(diagTbl, 0, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 5: Brier Score
    table.cell(diagTbl, 0, 5, "Brier Score", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 5, na(brierAvg) ? "â€”" : str.tostring(brierAvg, "#.####"), text_color=na(brierAvg) ? color.gray : brierAvg < 0.25 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 6: LogLoss
    table.cell(diagTbl, 0, 6, "LogLoss", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 6, na(llAvg) ? "â€”" : str.tostring(llAvg, "#.####"), text_color=na(llAvg) ? color.gray : llAvg < 0.65 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 7: Quality Grade
    table.cell(diagTbl, 0, 7, "Quality Grade", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 7, qualityGrade, text_color=qualityColor, text_size=size.tiny)
    
    // Row 8: Separator
    table.cell(diagTbl, 0, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 9: Total samples
    table.cell(diagTbl, 0, 9, "Total Samples", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 9, str.tostring(totalSamples), text_color=totalSamples >= calMinSamples * numBins ? color.lime : color.yellow, text_size=size.tiny)

//====================
// Calibration Export Alert
//====================
f_get_export_state() =>
    exportHorizon == "F1" ? tf1State : exportHorizon == "F2" ? tf2State : exportHorizon == "F3" ? tf3State : exportHorizon == "F4" ? tf4State : exportHorizon == "F5" ? tf5State : exportHorizon == "F6" ? tf6State : tf7State

if exportCalibration and barstate.isconfirmed and barstate.isrealtime and (bar_index % exportInterval == 0)
    expSt = f_get_export_state()

    pAN = array.get(expSt.plattN, 0)
    pBN = array.get(expSt.plattN, 1)
    pA1 = array.get(expSt.platt1, 0)
    pB1 = array.get(expSt.platt1, 1)

    // Brier/LogLoss stats
    brierSumN = array.get(expSt.brierStatsN, 0)
    brierCntN = array.get(expSt.brierStatsN, 1)
    brierAvgN = brierCntN > 0 ? brierSumN / brierCntN : 0

    llSumN = array.get(expSt.llStatsN, 0)
    llCntN = array.get(expSt.llStatsN, 1)
    llAvgN = llCntN > 0 ? llSumN / llCntN : 0

    totalSamplesN = array.sum(expSt.cntN)

    // Build JSON payload (single line to avoid line continuation issues)
    jsonPayload = '{"ticker":"' + syminfo.ticker + '","horizon":"' + exportHorizon + '","bar_index":' + str.tostring(bar_index) + ',"timestamp":"' + str.tostring(timenow) + '","platt_N":{"a":' + str.tostring(pAN, "#.####") + ',"b":' + str.tostring(pBN, "#.####") + '},"platt_1":{"a":' + str.tostring(pA1, "#.####") + ',"b":' + str.tostring(pB1, "#.####") + '},"brier_avg":' + str.tostring(brierAvgN, "#.####") + ',"logloss_avg":' + str.tostring(llAvgN, "#.####") + ',"samples":' + str.tostring(totalSamplesN) + ',"resolutions":' + str.tostring(int(brierCntN)) + '}'

    alert(jsonPayload, alert.freq_once_per_bar)

//====================
// Trend Regime Export Alert (for monitoring)
//====================
atrNormCur = atr / nz(close, 1)
curTrendRegime = f_trend_regime(emaF, emaS, atrNormCur)
trendLabel = curTrendRegime > 0.5 ? "BULL" : curTrendRegime < -0.5 ? "BEAR" : "SIDEWAYS"
alertcondition(curTrendRegime > 0.5 and curTrendRegime[1] <= 0.5, title="Regime: BULL", message="{{ticker}} entered BULL regime")
alertcondition(curTrendRegime < -0.5 and curTrendRegime[1] >= -0.5, title="Regime: BEAR", message="{{ticker}} entered BEAR regime")
alertcondition(math.abs(curTrendRegime) <= 0.5 and math.abs(curTrendRegime[1]) > 0.5, title="Regime: SIDEWAYS", message="{{ticker}} entered SIDEWAYS regime")

//====================
// Strategy Execution (Backtest Mode)
//====================
if buySignal
    strategy.entry("L", strategy.long, comment="Brier=" + str.tostring(curBrier, "#.##"))
if shortSignal
    strategy.entry("S", strategy.short, comment="Brier=" + str.tostring(curBrier, "#.##"))
if exitSignal
    strategy.close("L")
if coverSignal
    strategy.close("S")

