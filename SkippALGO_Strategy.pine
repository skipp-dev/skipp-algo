// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6
// SkippALGO Strategy (Deep Upgrade v6.1)
// - Synchronized with Main Indicator v6.1
// - Target Profiles (Fixed, KReturn, KATR, TPorSL)
// - Ensemble Score (Algo + Pullback + Regime)
// - 2D Binning (Score x Volatility)
// - Platt Scaling (SGD Probability Calibration)
strategy("SkippALGO Strategy (Deep Upgrade v6.1)", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_labels_count=500, max_lines_count=500)

//====================
// Inputs â€” Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose", "TRIG (legacy)"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

//====================
// Constants â€” Avoid Magic Numbers
//====================
// Volatility regime thresholds
VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

// Statistical constants
Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)

// Rolling buffer recalculation interval (prevent FP drift)
ROLL_RECALC_INTERVAL = 500

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels  = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers   = input.bool(true, "Show SET markers")
showTable        = input.bool(true, "Show Outlook/Forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

//====================
// Inputs â€” Forecast Calibration Enhancements (Deep Upgrade v6.1)
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])
atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpATRM    = input.float(0.80, "Path TP", step=0.05, group=grp_mid)
slATRM    = input.float(0.50, "Path SL", step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.20, "Path TP", step=0.05, group=grp_slow)
slATRS    = input.float(0.80, "Path SL", step=0.05, group=grp_slow)

// Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"], group="Policy")
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"], group="Policy")

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")

// --- Phase 4: Online Calibration ---
grp_cal = "Calibration Settings (Phase 4)"
usePlatt = input.bool(true, "Use Platt Scaling (Online SGD)", group=grp_cal)
lrPlatt  = input.float(0.01, "Learning Rate (SGD)", minval=0.001, maxval=0.1, step=0.001, group=grp_cal)

// Bins & Smoothing
predBinsN = input.int(3, "Pred bins (N) stable", minval=2, maxval=9, group="Engine")
predBins1 = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3, group="Engine")
dim2Bins  = 3 // Volatility Low/Mid/Hi

alphaN = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1, group="Engine")
alpha1 = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1, group="Engine")
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000, tooltip="Higher = pull bin probability closer to global TF average", group="Engine")

calMinSamples = input.int(40, "Min samples per bin (activate)", minval=5, maxval=1000, group="Engine")

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01, group="Signals")
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01, group="Signals")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7"], group="Maintenance")
resetNow   = input.bool(false, "Reset selected calibration NOW", group="Maintenance")

//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F6", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")
relFilterModel = input.string("N", "Filter Model", options=["N", "1"], tooltip="N=Multi-factor, 1=Single-factor")

//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ECE/Drift)")
evalWhichHead   = input.string("N", "Evaluate head", options=["N","1"])  // N=stable bins, 1=reactive bins

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"])

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)

//====================
// Inputs â€” Calibration Diagnostics (Debug Panel)
//====================
grp_diag = "ðŸ”§ Calibration Diagnostics"
showDiagPanel   = input.bool(false, "Show Calibration Debug Panel", group=grp_diag, tooltip="Displays Platt params, convergence, bin samples")
diagHorizon     = input.string("F1", "Diagnostic Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_diag)
diagModel       = input.string("N", "Diagnostic Model", options=["N","1"], group=grp_diag, tooltip="N=Multi-factor, 1=Single-factor")

//====================
// Inputs â€” Calibration Export (Webhook)
//====================
grp_export = "ðŸ“¤ Calibration Export"
exportCalibration = input.bool(false, "Enable Calibration Export Alert", group=grp_export, tooltip="Fires alert with JSON calibration state")
exportInterval    = input.int(100, "Export Every N Bars", minval=10, maxval=1000, group=grp_export)
exportHorizon     = input.string("F1", "Export Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_export)

//====================
// Calibration storage â€” TfState UDT (replaces 100+ global arrays)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    int[]   cntN
    int[]   upN
    int[]   cnt1
    int[]   up1
    // Queues
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    // Stats
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    // Evaluation N
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    // Evaluation 1
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1

// Helper to initialize TfState
f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
      array.new_int(nBinsN * dim2, 0), array.new_int(nBinsN * dim2, 0),
      array.new_int(nBins1 * dim2, 0), array.new_int(nBins1 * dim2, 0),
      array.new_int(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.from(1.0, 0.0), array.from(1.0, 0.0),
      // Eval N
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float(),
      // Eval 1
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float()
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBuckets)

//====================
// Table colors (navy + soft-blue frame)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

//====================
// Helpers
//====================
// --- Sum int array (total resolved samples across all bins)
f_sum_int_array(a) =>
    int s = 0
    for i = 0 to array.size(a) - 1
        s += array.get(a, i)
    s

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

// @function Clamp value to arbitrary [lo, hi] range
// @param val Value to clamp
// @param lo Minimum bound
// @param hi Maximum bound
// @returns Clamped value
f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" : tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  : tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "â€”" : v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") : v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") : v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") : str.tostring(v, "#")

f_chance_word() =>
    anyWin = fcTargetF == "PathTPvsSL" or fcTargetM == "PathTPvsSL" or fcTargetS == "PathTPvsSL"
    anyWin ? "Win" : "Up"

f_ci95_halfwidth(p, n) =>
    n <= 0 ? na : Z_95 * math.sqrt(p * (1.0 - p) / n)

f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= 0.05 ? "strong" : hw <= 0.10 ? "ok" : "weak"
    lbl

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    trend = emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = sec <= 300 // <= 5m
    isMid  = sec <= 3600 // <= 1h
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     isFast ? tpATRF    : isMid ? tpATRM    : tpATRS, 
     isFast ? slATRF    : isMid ? slATRM    : slATRS]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    math.log(pc / (1.0 - pc))

f_sigmoid(x) =>
    1.0 / (1.0 + math.exp(-x))

f_platt_prob(pRaw, a, b) =>
    usePlatt ? f_sigmoid(a * f_logit(pRaw) + b) : pRaw

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Simplified: Normalized distance
    float s = 0.0
    if bias == 1
        if c > ef
            s := 0.5
        else if c > es
            s := 1.0 // Sweet spot
        else
            s := -1.0 // Broken
    else
        if c < ef
            s := 0.5
        else if c < es
            s := 1.0
        else
            s := -1.0
    s

// @function Computes trend regime score (bull/bear/sideways)
// @param emaF Fast EMA value
// @param emaS Slow EMA value
// @param atrNorm ATR normalized by close (for sideways detection)
// @returns Score in [-1, 1]: +1=bull, -1=bear, 0=sideways/choppy
f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / nz(emaS, 1)
    // Strong trend: EMAs diverging significantly (>0.5% gap)
    // Sideways: EMAs close together AND low volatility
    isSideways = math.abs(emaDiff) < 0.005 and atrNorm < 0.015
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

f_ensemble(sA, sB, sC, wA, wB, wC) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Regime Score (-1..1)
    num = wA * sA + wB * sB + wC * sC
    den = wA + wB + wC
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    // sA: Algo State (-1..1)
    // sB: Pullback Score (-1..1)
    // sC: Vol Regime Score (-1..1)
    // sD: Trend Regime Score (-1..1): bull/bear/sideways
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// --- Phase 2 Helpers: 2D Binning ---
// @function Computes 2D bin index from score and volatility rank
// @param score Ensemble score in [-1, 1]
// @param volRank Volatility percentile rank in [0, 1]
// @param binsScore Number of bins for score dimension
// @param binsVol Number of bins for volatility dimension (typically 3)
// @returns Flattened bin index
f_bin2D(score, volRank, binsScore, binsVol) =>
    // Score bin (0..binsScore-1) - map [-1,1] to [0,1] then to bin index
    uS = (score + 1.0) * 0.5
    bS = int(math.floor(uS * binsScore))
    bS := math.max(0, math.min(binsScore - 1, bS))
    
    // Vol bin (0..binsVol-1) usually 3
    // Low (<LOW), Mid (LOW-HIGH), High (>=HIGH) - matches indicator logic
    bV = 0
    if volRank >= VOL_THRESH_HIGH
        bV := 2
    else if volRank >= VOL_THRESH_LOW
        bV := 1
    
    // Flattened Index
    int(bS * binsVol + bV)

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

f_tf_pack(tf) =>
    request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(ta.atr(atrLen)/close, volRankLen)], // Added Phase 2 Vol Rank
        barmerge.gaps_off,
        barmerge.lookahead_off
    )

f_score_tf(tf) =>
    [c, ef, es, r] = request.security(
            syminfo.tickerid,
            tf,
            [close,
             ta.ema(close, emaFastLen),
             ta.ema(close, emaSlowLen),
             ta.rsi(close, rsiStateLen)],
            barmerge.gaps_off,
            barmerge.lookahead_off
        )
    f_state_score(c, ef, es, r)



// @function Computes Laplace-smoothed probability with division safety
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter (default typically 1.0)
// @returns Probability in (0, 1), defaults to 0.5 if denominator is zero
f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_update(cntArr, upArr, bin, isUp) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    array.set(cntArr, bin, n0 + 1)
    array.set(upArr,  bin, u0 + (isUp ? 1 : 0))

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Bin raw
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "â€”" : n < calMinSamples ? "â€¦" : pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) : n < calMinSamples ? color.new(color.white, 60) : pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_pupText(pUp, n, canCal) =>
    if not canCal
        "OFF"
    else if n == 0
        "â€”"
    else if n < calMinSamples
        "Warm " + str.tostring(n) + "/" + str.tostring(calMinSamples)
    else
        if fcDisplay == "Edge pp (N)"
            edge = (pUp - 0.5) * 100.0
            sign = edge > 0 ? "+" : ""
            // example: +2.3pp (203)
            sign + str.tostring(edge, "#.0") + "pp (" + str.tostring(n) + ")"
        else
            // example: Up 49.8% (203)
            "Up " + str.tostring(pUp * 100.0, "#.0") + "% (" + str.tostring(n) + ")"

// Helper: Brier Score (MSE)
f_brier(p, isEvent) =>
    y = isEvent ? 1.0 : 0.0
    math.pow(p - y, 2)

// Helper: Log Loss (clipped)
f_logloss(p, isEvent) =>
    y = isEvent ? 1.0 : 0.0
    pClip = f_clamp(p, 0.01, 0.99)
    -(y * math.log(pClip) + (1.0 - y) * math.log(1.0 - pClip))

// Helper: Update one Evaluation struct
f_eval_update_one(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, 
                  evCalCnt, evCalSumP, evCalSumY, evCalBBuf, evCalPBuf, evCalYBuf, 
                  pPred, isUp, rollScore, rollShort, rollLong, buckets) =>
    // 1. Calc instance scores
    bs = f_brier(pPred, isUp)
    ll = f_logloss(pPred, isUp)
    y  = isUp ? 1.0 : 0.0
    
    // 2. Rolling Brier/LogLoss
    array.push(evBrier, bs)
    array.push(evLog, ll)
    sb = array.get(evSumBrier, 0) + bs
    sl = array.get(evSumLog, 0) + ll
    if array.size(evBrier) > rollScore
        sb := sb - array.shift(evBrier)
        sl := sl - array.shift(evLog)
    // Periodic recalculation to prevent FP drift
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(evBrier) > 0
        sb := array.sum(evBrier)
        sl := array.sum(evLog)
    array.set(evSumBrier, 0, sb)
    array.set(evSumLog, 0, sl)

    // 3. Drift (YS vs YL)
    array.push(evYS, y)
    array.push(evYL, y)
    sys = array.get(evSumYS, 0) + y
    syl = array.get(evSumYL, 0) + y
    if array.size(evYS) > rollShort
        sys := sys - array.shift(evYS)
    if array.size(evYL) > rollLong
        syl := syl - array.shift(evYL)
    // Periodic recalculation to prevent FP drift
    if bar_index % ROLL_RECALC_INTERVAL == 0
        if array.size(evYS) > 0
            sys := array.sum(evYS)
        if array.size(evYL) > 0
            syl := array.sum(evYL)
    array.set(evSumYS, 0, sys)
    array.set(evSumYL, 0, syl)

    // 4. Calibration (ECE Buckets)
    bIdx = math.min(math.floor(pPred * buckets), buckets - 1)
    
    // Rolling buffer for ECE (remove old events to keep ECE "live")
    // We store [bIdx, pPred, y] in parallel arrays or similar structure
    array.push(evCalBBuf, int(bIdx))
    array.push(evCalPBuf, pPred)
    array.push(evCalYBuf, y)
    
    // Add to buckets
    array.set(evCalCnt,  bIdx, array.get(evCalCnt,  bIdx) + 1)
    array.set(evCalSumP, bIdx, array.get(evCalSumP, bIdx) + pPred)
    array.set(evCalSumY, bIdx, array.get(evCalSumY, bIdx) + y)

    // Expire old
    // Use rollScore for ECE window as well for simplicity (or separate param)
    if array.size(evCalBBuf) > rollScore
        oldB = array.shift(evCalBBuf)
        oldP = array.shift(evCalPBuf)
        oldY = array.shift(evCalYBuf)
        // Remove from buckets
        cOld = array.get(evCalCnt, oldB)
        if cOld > 0
            array.set(evCalCnt, oldB, cOld - 1)
            array.set(evCalSumP, oldB, array.get(evCalSumP, oldB) - oldP)
            array.set(evCalSumY, oldB, array.get(evCalSumY, oldB) - oldY)

f_eval_on_resolve(TfState st, pPredN, pPred1, isUp) =>
    modeN = (evalWhichHead == "N") or (evalWhichHead == "Both")
    mode1 = (evalWhichHead == "1") or (evalWhichHead == "Both")
    
    if modeN
        f_eval_update_one(st.evBrierN, st.evLogN, st.evSumBrierN, st.evSumLogN, st.evYS_N, st.evYL_N, st.evSumYS_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN, pPredN, isUp, evalRollScore, evalRollShort, evalRollLong, evalBuckets)
    if mode1
        f_eval_update_one(st.evBrier1, st.evLog1, st.evSumBrier1, st.evSumLog1, st.evYS_1, st.evYL_1, st.evSumYS_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1, pPred1, isUp, evalRollScore, evalRollShort, evalRollLong, evalBuckets)

// Helper: Get Eval Stats [Brier, LogLoss, ECE, DriftPP, Count]
f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY) =>
    n = array.size(evBrier)
    if n < evalMinEvents
        [float(na), float(na), float(na), float(na), float(n)]
    else
        // Brier, Log
        bs = array.get(evSumBrier, 0) / n
        ll = array.get(evSumLog, 0) / n
        
        // ECE
        eceSum = 0.0
        totCal = 0
        for i = 0 to evalBuckets - 1
            bn = array.get(evCalCnt, i)
            if bn > 0
                bp = array.get(evCalSumP, i) / bn
                by = array.get(evCalSumY, i) / bn
                eceSum := eceSum + bn * math.abs(bp - by)
                totCal := totCal + bn
        ece = totCal > 0 ? eceSum / totCal : 0.0
        
        // Drift
        // Only if short/long windows are filled
        nS = array.size(evYS)
        nL = array.size(evYL)
        drift = 0.0
        if nS >= evalRollShort and nL >= evalRollLong
            avgS = array.get(evSumYS, 0) / nS
            avgL = array.get(evSumYL, 0) / nL
            drift := (avgS - avgL) * 100.0 // in pp
        else
            drift := float(na)
            
        [bs, ll, ece, drift, float(n)]

// Table Helpers
f_colLowerBetter(val, goodThr, badThr) =>
    na(val) ? color.new(color.gray, 60) :
      val < goodThr ? color.new(color.lime, 30) :
      val > badThr ? color.new(color.red, 30) :
      color.new(color.yellow, 30)

f_ppSigned(val) =>
    na(val) ? "â€”" :
     (val > 0 ? "+" : "") + str.tostring(val, "#.1") + "pp"

f_rowEval(tid, titleStr, evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY, rIdx) =>
    [bs, ll, ece, drift, n] = f_eval_get(evBrier, evLog, evSumBrier, evSumLog, evYS, evYL, evSumYS, evSumYL, evCalCnt, evCalSumP, evCalSumY)
    
    // Header
    table.cell(tbl, 0, rIdx, titleStr, text_halign=text.align_left, text_size=size.small, bgcolor=color.new(color.gray, 90))
    
    if na(bs)
        table.cell(tbl, 1, rIdx, "Wait (" + str.tostring(n, "#") + ")", text_size=size.small)
    else
        // Brier
        // scale: typically 0.25 is max entropy. <0.20 is good. <0.15 is great.
        // Let's color based on general intuition
        cBs = f_colLowerBetter(bs, 0.18, 0.23)
        table.cell(tbl, 1, rIdx, str.tostring(bs, "#.3f"), bgcolor=cBs, text_size=size.small)
        
        // LogL
        // scale: ~0.693 is rand. <0.60 is good.
        cLl = f_colLowerBetter(ll, 0.55, 0.65)
        table.cell(tbl, 2, rIdx, str.tostring(ll, "#.3f"), bgcolor=cLl, text_size=size.small)
        
        // ECE
        cEce = f_colLowerBetter(ece, 0.05, 0.10)
        table.cell(tbl, 3, rIdx, str.tostring(ece*100, "#.1")+"%", bgcolor=cEce, text_size=size.small)
        
        // Drift
        cDr = math.abs(drift) > driftWarnPP ? color.new(color.red, 30) : color.new(color.gray, 90)
        table.cell(tbl, 4, rIdx, f_ppSigned(drift), bgcolor=cDr, text_size=size.small)


f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0), array.fill(st.upN, 0)
    array.fill(st.cnt1, 0), array.fill(st.up1, 0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN), array.clear(st.evSumBrierN), array.clear(st.evLogN), array.clear(st.evSumLogN), array.clear(st.evYS_N), array.clear(st.evSumYS_N), array.clear(st.evYL_N), array.clear(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1), array.clear(st.evSumBrier1), array.clear(st.evLog1), array.clear(st.evSumLog1), array.clear(st.evYS_1), array.clear(st.evSumYS_1), array.clear(st.evYL_1), array.clear(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// Process one TF calibration step (updates on new TF bar)
f_process_tf(newTfBar, sA, 
             cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
             TfState st,
             fcTgt, kB, aThr, pH, tpA, slA,
             alphaNVal, alpha1Val, shrinkKVal, wStateVal, wPullbackVal, wRegimeVal, wTrendVal) =>

    if newTfBar
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = array.get(st.qAge,   i)
            entry_i = array.get(st.qEntry, i)
            atr_i   = array.get(st.qAtr,   i)
            mh_i    = array.get(st.qMaxH,  i)
            ml_i    = array.get(st.qMinL,  i)
            bN_i    = array.get(st.qBinN,  i)
            b1_i    = array.get(st.qBin1,  i)

            // Stored at entry
            probN_i = array.get(st.qProbN,  i)
            prob1_i = array.get(st.qProb1,  i)
            lgtN_i  = array.get(st.qLogitN, i)
            lgt1_i  = array.get(st.qLogit1, i)
            predN_i = array.get(st.qPredN,  i)
            pred1_i = array.get(st.qPred1,  i)

            resolved = false
            doUpdate = false
            isUp     = false

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    isUp := cNow > entry_i

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    isUp := cNow > entry_i

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                    else
                        doUpdate := true
                        retATR = (cNow - entry_i) / atr_i
                        isUp := retATR >= aThr

            else // PathTPvsSL
                tpPx = entry_i + tpA * atr_i
                slPx = entry_i - slA * atr_i
                winHit  = mh_i >= tpPx
                lossHit = ml_i <= slPx

                if winHit or lossHit
                    resolved := true
                    doUpdate := true
                    if winHit and lossHit
                        if pathTiePolicy == "Win"
                            isUp := true
                        else if pathTiePolicy == "Neutral"
                            doUpdate := false
                        else
                            isUp := false
                    else
                        isUp := winHit and not lossHit

                else if age_i >= pH
                    resolved := true
                    if noHitPolicy == "Loss"
                        doUpdate := true
                        isUp := false
                    else
                        doUpdate := false

            if resolved
                if doUpdate
                    f_cal_update(st.cntN, st.upN, bN_i, isUp)
                    f_cal_update(st.cnt1, st.up1, b1_i, isUp)
                    
                    outcomeVal = isUp ? 1.0 : 0.0
                    
                    // --- Evaluation (Live Scoring) ---
                    // Score based on the final prediction we made (predN_i / pred1_i)
                    if (evalMode == "History+Live") or (evalMode == "LiveOnly" and barstate.isrealtime)
                        f_eval_on_resolve(st, predN_i, pred1_i, isUp)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    nBinN_cur = array.get(st.cntN, bN_i)
                    if nBinN_cur >= calMinSamples
                        // Brier on raw prob
                        sqErrN = math.pow(outcomeVal - probN_i, 2)
                        curSumN = array.get(st.brierStatsN, 0)
                        curCntN = array.get(st.brierStatsN, 1)
                        array.set(st.brierStatsN, 0, curSumN + sqErrN)
                        array.set(st.brierStatsN, 1, curCntN + 1.0)
                        
                        // Platt SGD
                        if usePlatt
                            aN = array.get(st.plattN, 0)
                            bN = array.get(st.plattN, 1)
                            pAdj = f_sigmoid(aN * lgtN_i + bN)
                            err = pAdj - outcomeVal
                            da = err * lgtN_i
                            db = err
                            // Update
                            aN := math.max(0.1, math.min(5.0, aN - lrPlatt * da)) 
                            bN := math.max(-3.0, math.min(3.0, bN - lrPlatt * db))
                            array.set(st.plattN, 0, aN)
                            array.set(st.plattN, 1, bN)
                            
                            // LogLoss
                            pLL = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj))
                            ll = -(outcomeVal * math.log(pLL) + (1.0 - outcomeVal) * math.log(1.0 - pLL))
                            curSumLL = array.get(st.llStatsN, 0)
                            curCntLL = array.get(st.llStatsN, 1)
                            array.set(st.llStatsN, 0, curSumLL + ll)
                            array.set(st.llStatsN, 1, curCntLL + 1.0)
                    
                    // --- Phase 4: SGD Update & LogLoss (1) ---
                    sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                    curSum1 = array.get(st.brierStats1, 0)
                    curCnt1 = array.get(st.brierStats1, 1)
                    array.set(st.brierStats1, 0, curSum1 + sqErr1)
                    array.set(st.brierStats1, 1, curCnt1 + 1.0)

                    if usePlatt
                        a1 = array.get(st.platt1, 0)
                        b1 = array.get(st.platt1, 1)
                        pAdj1 = f_sigmoid(a1 * lgt1_i + b1)
                        err1 = pAdj1 - outcomeVal
                        da1 = err1 * lgt1_i
                        db1 = err1
                        a1 := math.max(0.1, math.min(5.0, a1 - lrPlatt * da1))
                        b1 := math.max(-3.0, math.min(3.0, b1 - lrPlatt * db1))
                        array.set(st.platt1, 0, a1)
                        array.set(st.platt1, 1, b1)
                        
                        pLL1 = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj1))
                        ll1 = -(outcomeVal * math.log(pLL1) + (1.0 - outcomeVal) * math.log(1.0 - pLL1))
                        curSumLL1 = array.get(st.llStats1, 0)
                        curCntLL1 = array.get(st.llStats1, 1)
                        array.set(st.llStats1, 0, curSumLL1 + ll1)
                        array.set(st.llStats1, 1, curCntLL1 + 1.0)

                array.remove(st.qAge,   i)
                array.remove(st.qMaxH,  i)
                array.remove(st.qMinL,  i)
                array.remove(st.qAtr,   i)
                array.remove(st.qEntry, i)
                array.remove(st.qBinN,  i)
                array.remove(st.qBin1,  i)
                array.remove(st.qProbN, i)
                array.remove(st.qProb1, i)
                array.remove(st.qLogitN, i)
                array.remove(st.qLogit1, i)
                array.remove(st.qPredN, i)
                array.remove(st.qPred1, i)

            i -= 1

        // 3) Push new pending item
        // --- Phase 3: Ensemble Score ---
        bias = emaFNow > emaSNow ? 1 : -1
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        atrNorm = atrNow / nz(cNow, 1)
        sD = f_trend_regime(emaFNow, emaSNow, atrNorm)
        sEns = f_ensemble4(sA, sB, sC, sD, wStateVal, wPullbackVal, wRegimeVal, wTrendVal)
        
        // --- Phase 2: 2D Binning ---
        bN = f_bin2D(sEns, volRankNow, predBinsN, dim2Bins)
        b1 = f_bin2D(sEns, volRankNow, predBins1, dim2Bins)

        // Capture current probabilities
        [pNowN, _nN] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
        [pNow1, _n1] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)
        
        // Logits (Phase 4)
        lgtN = f_logit(pNowN)
        lgt1 = f_logit(pNow1)

        // Platt Adjust (Display/Predict)
        aN = array.get(st.plattN, 0)
        bN_p = array.get(st.plattN, 1)
        pAdjN = f_sigmoid(aN * lgtN + bN_p)
        
        a1 = array.get(st.platt1, 0)
        b1_p = array.get(st.platt1, 1)
        pAdj1 = f_sigmoid(a1 * lgt1 + b1_p)
        
        // Use adjusted if Platt enabled, else raw
        pFinalN = usePlatt ? pAdjN : pNowN
        pFinal1 = usePlatt ? pAdj1 : pNow1

        array.push(st.qBinN,  bN)
        array.push(st.qBin1,  b1)
        array.push(st.qEntry, cNow)
        array.push(st.qAtr,   atrNow)

        array.push(st.qMaxH,  cNow)
        array.push(st.qMinL,  cNow)

        array.push(st.qAge,   0)
        
        array.push(st.qProbN, pNowN)
        array.push(st.qProb1, pNow1)
        array.push(st.qLogitN, lgtN)
        array.push(st.qLogit1, lgt1)
        array.push(st.qPredN, pFinalN)
        array.push(st.qPred1, pFinal1)

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ?
     ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("300"))  ? rsiLenFastTF :
      (not na(baseSecs) and baseSecs <= timeframe.in_seconds("3600")) ? rsiLenMidTF  :
                                                                        rsiLenSlowTF) :
     rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime
atrRank = f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? volRankRaw : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // global per-bar
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)

    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier =
     config == "Standard"      ? 1.00 :
     config == "Pro"           ? 1.05 :
     config == "V2 Essential"  ? 0.95 :
     config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30"))  ? "Short" :
           (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown
gateLongNow  = (confidence >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidence >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice =
     zoneAnchor == "Entry"    and not na(entryPrice) ? entryPrice :
     zoneAnchor == "VWAP"     ? vwapVal :
     zoneAnchor == "MA200"    ? sma200Val :
     zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "â€”"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)

f_getBrier(tfSel, modSel) =>
    float score = 0.5 // default safe
    
    // Select array pair stats
    float[] stats = na
    if tfSel == "F1"
        stats := (modSel == "N") ? tf1State.brierStatsN : tf1State.brierStats1
    else if tfSel == "F2"
        stats := (modSel == "N") ? tf2State.brierStatsN : tf2State.brierStats1
    else if tfSel == "F3"
        stats := (modSel == "N") ? tf3State.brierStatsN : tf3State.brierStats1
    else if tfSel == "F4"
        stats := (modSel == "N") ? tf4State.brierStatsN : tf4State.brierStats1
    else if tfSel == "F5"
        stats := (modSel == "N") ? tf5State.brierStatsN : tf5State.brierStats1
    else if tfSel == "F6"
        stats := (modSel == "N") ? tf6State.brierStatsN : tf6State.brierStats1
    else if tfSel == "F7"
        stats := (modSel == "N") ? tf7State.brierStatsN : tf7State.brierStats1
    
    if not na(stats)
        s = array.get(stats, 0)
        c = array.get(stats, 1)
        if c > 0
            score := s / c
    score

curBrier = f_getBrier(relFilterTF, relFilterModel)
reliabilityOk = (not useRelFilter) or (curBrier <= maxBrier)

allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose and reliabilityOk
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 25))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Outlook/Forecast packs (one security call per horizon TF)
//====================
[t1, c1, h1, l1, ef1, es1, r1, a1, vr1] = f_tf_pack(tfF1)
[t2, c2, h2, l2, ef2, es2, r2, a2, vr2] = f_tf_pack(tfF2)
[t3, c3, h3, l3, ef3, es3, r3, a3, vr3] = f_tf_pack(tfF3)
[t4, c4, h4, l4, ef4, es4, r4, a4, vr4] = f_tf_pack(tfF4)
[t5, c5, h5, l5, ef5, es5, r5, a5, vr5] = f_tf_pack(tfF5)
[t6, c6, h6, l6, ef6, es6, r6, a6, vr6] = f_tf_pack(tfF6)
[t7, c7, h7, l7, ef7, es7, r7, a7, vr7] = f_tf_pack(tfF7)

// Get Target Params per TF
[fcT1, kB1, aT1, pH1, tp1, sl1] = f_get_params(tfF1)
[fcT2, kB2, aT2, pH2, tp2, sl2] = f_get_params(tfF2)
[fcT3, kB3, aT3, pH3, tp3, sl3] = f_get_params(tfF3)
[fcT4, kB4, aT4, pH4, tp4, sl4] = f_get_params(tfF4)
[fcT5, kB5, aT5, pH5, tp5, sl5] = f_get_params(tfF5)
[fcT6, kB6, aT6, pH6, tp6, sl6] = f_get_params(tfF6)
[fcT7, kB7, aT7, pH7, tp7, sl7] = f_get_params(tfF7)

chgT1 = ta.change(t1)
chgT2 = ta.change(t2)
chgT3 = ta.change(t3)
chgT4 = ta.change(t4)
chgT5 = ta.change(t5)
chgT6 = ta.change(t6)
chgT7 = ta.change(t7)

newF1 = not na(t1) and (chgT1 != 0)
newF2 = not na(t2) and (chgT2 != 0)
newF3 = not na(t3) and (chgT3 != 0)
newF4 = not na(t4) and (chgT4 != 0)
newF5 = not na(t5) and (chgT5 != 0)
newF6 = not na(t6) and (chgT6 != 0)
newF7 = not na(t7) and (chgT7 != 0)

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

[t1c, m1c, l1c] = f_state_tml(c1, ef1, es1, r1)
[t2c, m2c, l2c] = f_state_tml(c2, ef2, es2, r2)
[t3c, m3c, l3c] = f_state_tml(c3, ef3, es3, r3)
[t4c, m4c, l4c] = f_state_tml(c4, ef4, es4, r4)
[t5c, m5c, l5c] = f_state_tml(c5, ef5, es5, r5)
[t6c, m6c, l6c] = f_state_tml(c6, ef6, es6, r6)
[t7c, m7c, l7c] = f_state_tml(c7, ef7, es7, r7)

outSym(score) => score > 0.05 ? "â–²" : score < -0.05 ? "â–¼" : "âˆ’"
outCol(score) => score > 0.05 ? color.lime : score < -0.05 ? color.red : tblText

//====================
// Calibration storage â€” per horizon TF (Removed - moved to top)
//====================
// (Moved to top level state)

//====================
// Reset handling (rising edge) â€” per horizon F1..F7
//====================
var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All"
        f_reset_eval_all()
    else 
        if resetWhich == "F1"
           f_reset_tf(tf1State)
        if resetWhich == "F2"
           f_reset_tf(tf2State)
        if resetWhich == "F3"
           f_reset_tf(tf3State)
        if resetWhich == "F4"
           f_reset_tf(tf4State)
        if resetWhich == "F5"
           f_reset_tf(tf5State)
        if resetWhich == "F6"
           f_reset_tf(tf6State)
        if resetWhich == "F7"
           f_reset_tf(tf7State)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed
if doCal
    f_process_tf(newF1, outScore1, c1, h1, l1, a1, vr1, ef1, es1, tf1State, fcT1, kB1, aT1, pH1, tp1, sl1, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(newF2, outScore2, c2, h2, l2, a2, vr2, ef2, es2, tf2State, fcT2, kB2, aT2, pH2, tp2, sl2, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(newF3, outScore3, c3, h3, l3, a3, vr3, ef3, es3, tf3State, fcT3, kB3, aT3, pH3, tp3, sl3, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(newF4, outScore4, c4, h4, l4, a4, vr4, ef4, es4, tf4State, fcT4, kB4, aT4, pH4, tp4, sl4, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(newF5, outScore5, c5, h5, l5, a5, vr5, ef5, es5, tf5State, fcT5, kB5, aT5, pH5, tp5, sl5, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(newF6, outScore6, c6, h6, l6, a6, vr6, ef6, es6, tf6State, fcT6, kB6, aT6, pH6, tp6, sl6, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)
    f_process_tf(newF7, outScore7, c7, h7, l7, a7, vr7, ef7, es7, tf7State, fcT7, kB7, aT7, pH7, tp7, sl7, alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

f_get_disp_vals(sA, c, atrVal, ef, es, vr, TfState st) =>
    bias = ef > es ? 1 : -1
    sB = f_pullback_score(c, ef, es, bias)
    sC = vr >= VOL_THRESH_HIGH ? -1.0 : (vr <= VOL_THRESH_LOW ? 1.0 : 0.0)
    atrNorm = atrVal / nz(c, 1)
    sD = f_trend_regime(ef, es, atrNorm)
    sEns = f_ensemble4(sA, sB, sC, sD, wState, wPullback, wRegime, wTrend)
    bN = f_bin2D(sEns, vr, predBinsN, dim2Bins)
    b1 = f_bin2D(sEns, vr, predBins1, dim2Bins)
    [pN, nN] = f_cal_cur(st.cntN, st.upN, bN, alphaN, kShrink)
    [p1, n1] = f_cal_cur(st.cnt1, st.up1, b1, alpha1, kShrink)
    aN = array.get(st.plattN, 0)
    b_N = array.get(st.plattN, 1)
    pAdjN = f_platt_prob(pN, aN, b_N)
    a1 = array.get(st.platt1, 0)
    b_1 = array.get(st.platt1, 1)
    pAdj1 = f_platt_prob(p1, a1, b_1)
    [pAdjN, nN, pAdj1, n1]

//====================
// Display values â€” N and 1 per horizon
//====================
[pN1, nN1, p11p, n11p] = f_get_disp_vals(outScore1, c1, a1, ef1, es1, vr1, tf1State)
[pN2, nN2, p12p, n12p] = f_get_disp_vals(outScore2, c2, a2, ef2, es2, vr2, tf2State)
[pN3, nN3, p13p, n13p] = f_get_disp_vals(outScore3, c3, a3, ef3, es3, vr3, tf3State)
[pN4, nN4, p14p, n14p] = f_get_disp_vals(outScore4, c4, a4, ef4, es4, vr4, tf4State)
[pN5, nN5, p15p, n15p] = f_get_disp_vals(outScore5, c5, a5, ef5, es5, vr5, tf5State)
[pN6, nN6, p16p, n16p] = f_get_disp_vals(outScore6, c6, a6, ef6, es6, vr6, tf6State)
[pN7, nN7, p17p, n17p] = f_get_disp_vals(outScore7, c7, a7, ef7, es7, vr7, tf7State)

// --- Total resolved samples per TF (across all bins)
totN1 = f_sum_int_array(tf1State.cntN)
totN2 = f_sum_int_array(tf2State.cntN)
totN3 = f_sum_int_array(tf3State.cntN)
totN4 = f_sum_int_array(tf4State.cntN)
totN5 = f_sum_int_array(tf5State.cntN)
totN6 = f_sum_int_array(tf6State.cntN)
totN7 = f_sum_int_array(tf7State.cntN)

tot11 = f_sum_int_array(tf1State.cnt1)
tot12 = f_sum_int_array(tf2State.cnt1)
tot13 = f_sum_int_array(tf3State.cnt1)
tot14 = f_sum_int_array(tf4State.cnt1)
tot15 = f_sum_int_array(tf5State.cnt1)
tot16 = f_sum_int_array(tf6State.cnt1)
tot17 = f_sum_int_array(tf7State.cnt1)

// calibration â€œenabled for displayâ€ if forecast enabled + we have any resolved samples in that TF
can1N = enableForecast and (totN1 > 0)
can2N = enableForecast and (totN2 > 0)
can3N = enableForecast and (totN3 > 0)
can4N = enableForecast and (totN4 > 0)
can5N = enableForecast and (totN5 > 0)
can6N = enableForecast and (totN6 > 0)
can7N = enableForecast and (totN7 > 0)

can11 = enableForecast and (tot11 > 0)
can12 = enableForecast and (tot12 > 0)
can13 = enableForecast and (tot13 > 0)
can14 = enableForecast and (tot14 > 0)
can15 = enableForecast and (tot15 > 0)
can16 = enableForecast and (tot16 > 0)
can17 = enableForecast and (tot17 > 0)

//====================
// Table helpers MUST be global (cannot be defined inside if-block)
//====================
var table gT = na
if na(gT)
    gT := table.new(position.middle_right, 5, 35, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

f_rowOut(tf, score, tC, mC, lC, rV, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 1, rRow, outSym(score),  text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, rRow, str.tostring(tC) + "/" + str.tostring(mC) + "/" + str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

f_rowFc(tf, pN, nN, canN, p1, n1, can1, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)

    symN = f_predSymbolP(pN, nN, canN)
    colN = f_predColorP(pN, nN, canN, tblText)
    table.cell(gT, 1, rRow, symN, text_color=colN, bgcolor=tblCell, text_size=size.tiny)

    sym1 = f_predSymbolP(p1, n1, can1)
    col1 = f_predColorP(p1, n1, can1, tblText)
    table.cell(gT, 2, rRow, sym1, text_color=col1, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 3, rRow, f_pupText(pN, nN, canN), text_color=f_predColorP(pN, nN, canN, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, f_pupText(p1, n1, can1), text_color=f_predColorP(p1, n1, can1, tblText), bgcolor=tblCell, text_size=size.tiny)

f_fmtBrier(stats) =>
    s = array.get(stats, 0)
    c = array.get(stats, 1)
    val = c > 0 ? s / c : na
    txt = na(val) ? "â€”" : str.tostring(val, "#.###")
    col = na(val) ? tblTextDim : val < 0.20 ? color.green : val < 0.25 ? color.lime : val < 0.30 ? color.yellow : color.red
    [txt, col]

f_fmtCnt(stats) =>
    c = array.get(stats, 1)
    [str.tostring(c, "#"), c < 10 ? tblTextDim : tblText]

f_rowRel(tf, statsN, stats1, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    
    [tN, cN] = f_fmtBrier(statsN)
    table.cell(gT, 1, rRow, tN, text_color=cN, bgcolor=tblCell, text_size=size.tiny)
    
    [t1, c1] = f_fmtBrier(stats1)
    table.cell(gT, 2, rRow, t1, text_color=c1, bgcolor=tblCell, text_size=size.tiny)
    
    [tcN, ccN] = f_fmtCnt(statsN)
    table.cell(gT, 3, rRow, tcN, text_color=ccN, bgcolor=tblCell, text_size=size.tiny)
    
    [tc1, cc1] = f_fmtCnt(stats1)
    table.cell(gT, 4, rRow, tc1, text_color=cc1, bgcolor=tblCell, text_size=size.tiny)

//====================
// Table (5 columns) â€” rendered on confirmed bars (stable)
//====================
mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow
c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblText

targetDesc = "Multi-Profile (See Settings). Fast: " + fcTargetF + ", Mid: " + fcTargetM + ", Slow: " + fcTargetS

if showTable and barstate.isconfirmed
    table.clear(gT, 0, 0, 4, 33)

    // Status rows
    table.cell(gT, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(gT, 2, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 2, volStr,   text_color=c_vol,      bgcolor=tblCell,   text_size=size.tiny)

    table.cell(gT, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 3, strengthStr, text_color=c_strength, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    // Outlook header
    table.cell(gT, 0, 8, "Outlook", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 8, "Bias",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 2, 8, "Score",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 8, "T/M/L",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 4, 8, "RSI",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    f_rowOut(tfF1, outScore1, t1c, m1c, l1c, r1,  9)
    f_rowOut(tfF2, outScore2, t2c, m2c, l2c, r2, 10)
    f_rowOut(tfF3, outScore3, t3c, m3c, l3c, r3, 11)
    f_rowOut(tfF4, outScore4, t4c, m4c, l4c, r4, 12)
    f_rowOut(tfF5, outScore5, t5c, m5c, l5c, r5, 13)
    f_rowOut(tfF6, outScore6, t6c, m6c, l6c, r6, 14)
    f_rowOut(tfF7, outScore7, t7c, m7c, l7c, r7, 15)

    // Forecast header
    table.cell(gT, 0, 16, "Forecast", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 16, "Pred(N)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 2, 16, "Pred(1)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    pHdrN = fcDisplay == "Edge pp (N)" ? "Edge(N)" : "Up%(N)"
    pHdr1 = fcDisplay == "Edge pp (N)" ? "Edge(1)" : "Up%(1)"

    table.cell(gT, 3, 16, pHdrN, text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 4, 16, pHdr1, text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    f_rowFc(tfF1, pN1, nN1, can1N, p11p, n11p, can11, 17)
    f_rowFc(tfF2, pN2, nN2, can2N, p12p, n12p, can12, 18)
    f_rowFc(tfF3, pN3, nN3, can3N, p13p, n13p, can13, 19)
    f_rowFc(tfF4, pN4, nN4, can4N, p14p, n14p, can14, 20)
    f_rowFc(tfF5, pN5, nN5, can5N, p15p, n15p, can15, 21)
    f_rowFc(tfF6, pN6, nN6, can6N, p16p, n16p, can16, 22)
    f_rowFc(tfF7, pN7, nN7, can7N, p17p, n17p, can17, 23)

    // Evaluation (live scoring)
    if showEvalSection
        // Header
        table.cell(gT, 0, 24, "Eval(" + evalWhichHead + ")", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
        table.cell(gT, 1, 24, "Brier",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
        table.cell(gT, 2, 24, "LogL",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
        table.cell(gT, 3, 24, "ECE",      text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
        table.cell(gT, 4, 24, "Drift",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

        // Select N or 1 logic
        isN = evalWhichHead != "1"
        
        f_rowEval(tfF1, f_tfLabel(tfF1), isN ? tf1State.evBrierN : tf1State.evBrier1, isN ? tf1State.evLogN : tf1State.evLog1, isN ? tf1State.evSumBrierN : tf1State.evSumBrier1, isN ? tf1State.evSumLogN : tf1State.evSumLog1, isN ? tf1State.evYS_N : tf1State.evYS_1, isN ? tf1State.evYL_N : tf1State.evYL_1, isN ? tf1State.evSumYS_N : tf1State.evSumYS_1, isN ? tf1State.evSumYL_N : tf1State.evSumYL_1, isN ? tf1State.evCalCntN : tf1State.evCalCnt1, isN ? tf1State.evCalSumPN : tf1State.evCalSumP1, isN ? tf1State.evCalSumYN : tf1State.evCalSumY1, 25)
        f_rowEval(tfF2, f_tfLabel(tfF2), isN ? tf2State.evBrierN : tf2State.evBrier1, isN ? tf2State.evLogN : tf2State.evLog1, isN ? tf2State.evSumBrierN : tf2State.evSumBrier1, isN ? tf2State.evSumLogN : tf2State.evSumLog1, isN ? tf2State.evYS_N : tf2State.evYS_1, isN ? tf2State.evYL_N : tf2State.evYL_1, isN ? tf2State.evSumYS_N : tf2State.evSumYS_1, isN ? tf2State.evSumYL_N : tf2State.evSumYL_1, isN ? tf2State.evCalCntN : tf2State.evCalCnt1, isN ? tf2State.evCalSumPN : tf2State.evCalSumP1, isN ? tf2State.evCalSumYN : tf2State.evCalSumY1, 26)
        f_rowEval(tfF3, f_tfLabel(tfF3), isN ? tf3State.evBrierN : tf3State.evBrier1, isN ? tf3State.evLogN : tf3State.evLog1, isN ? tf3State.evSumBrierN : tf3State.evSumBrier1, isN ? tf3State.evSumLogN : tf3State.evSumLog1, isN ? tf3State.evYS_N : tf3State.evYS_1, isN ? tf3State.evYL_N : tf3State.evYL_1, isN ? tf3State.evSumYS_N : tf3State.evSumYS_1, isN ? tf3State.evSumYL_N : tf3State.evSumYL_1, isN ? tf3State.evCalCntN : tf3State.evCalCnt1, isN ? tf3State.evCalSumPN : tf3State.evCalSumP1, isN ? tf3State.evCalSumYN : tf3State.evCalSumY1, 27)
        f_rowEval(tfF4, f_tfLabel(tfF4), isN ? tf4State.evBrierN : tf4State.evBrier1, isN ? tf4State.evLogN : tf4State.evLog1, isN ? tf4State.evSumBrierN : tf4State.evSumBrier1, isN ? tf4State.evSumLogN : tf4State.evSumLog1, isN ? tf4State.evYS_N : tf4State.evYS_1, isN ? tf4State.evYL_N : tf4State.evYL_1, isN ? tf4State.evSumYS_N : tf4State.evSumYS_1, isN ? tf4State.evSumYL_N : tf4State.evSumYL_1, isN ? tf4State.evCalCntN : tf4State.evCalCnt1, isN ? tf4State.evCalSumPN : tf4State.evCalSumP1, isN ? tf4State.evCalSumYN : tf4State.evCalSumY1, 28)
        f_rowEval(tfF5, f_tfLabel(tfF5), isN ? tf5State.evBrierN : tf5State.evBrier1, isN ? tf5State.evLogN : tf5State.evLog1, isN ? tf5State.evSumBrierN : tf5State.evSumBrier1, isN ? tf5State.evSumLogN : tf5State.evSumLog1, isN ? tf5State.evYS_N : tf5State.evYS_1, isN ? tf5State.evYL_N : tf5State.evYL_1, isN ? tf5State.evSumYS_N : tf5State.evSumYS_1, isN ? tf5State.evSumYL_N : tf5State.evSumYL_1, isN ? tf5State.evCalCntN : tf5State.evCalCnt1, isN ? tf5State.evCalSumPN : tf5State.evCalSumP1, isN ? tf5State.evCalSumYN : tf5State.evCalSumY1, 29)
        f_rowEval(tfF6, f_tfLabel(tfF6), isN ? tf6State.evBrierN : tf6State.evBrier1, isN ? tf6State.evLogN : tf6State.evLog1, isN ? tf6State.evSumBrierN : tf6State.evSumBrier1, isN ? tf6State.evSumLogN : tf6State.evSumLog1, isN ? tf6State.evYS_N : tf6State.evYS_1, isN ? tf6State.evYL_N : tf6State.evYL_1, isN ? tf6State.evSumYS_N : tf6State.evSumYS_1, isN ? tf6State.evSumYL_N : tf6State.evSumYL_1, isN ? tf6State.evCalCntN : tf6State.evCalCnt1, isN ? tf6State.evCalSumPN : tf6State.evCalSumP1, isN ? tf6State.evCalSumYN : tf6State.evCalSumY1, 30)
        f_rowEval(tfF7, f_tfLabel(tfF7), isN ? tf7State.evBrierN : tf7State.evBrier1, isN ? tf7State.evLogN : tf7State.evLog1, isN ? tf7State.evSumBrierN : tf7State.evSumBrier1, isN ? tf7State.evSumLogN : tf7State.evSumLog1, isN ? tf7State.evYS_N : tf7State.evYS_1, isN ? tf7State.evYL_N : tf7State.evYL_1, isN ? tf7State.evSumYS_N : tf7State.evSumYS_1, isN ? tf7State.evSumYL_N : tf7State.evSumYL_1, isN ? tf7State.evCalCntN : tf7State.evCalCnt1, isN ? tf7State.evCalSumPN : tf7State.evCalSumP1, isN ? tf7State.evCalSumYN : tf7State.evCalSumY1, 31)

    // Footer
    table.cell(gT, 0, 32, "Target", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 32, targetDesc, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.merge_cells(gT, 1, 32, 4, 32)

    table.cell(gT, 0, 33, "Note", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 33,
     "Forecast: Shrinkage k=5.0 active. Accuracy: Brier Score (0-1). <0.25=Skill.",
     text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.merge_cells(gT, 1, 33, 4, 33)

//====================
// Calibration Diagnostics Panel (Debug)
//====================
var table diagTbl = na
if showDiagPanel and na(diagTbl)
    diagTbl := table.new(position.top_right, 2, 18, bgcolor=color.new(color.black, 85), frame_color=color.gray, frame_width=1, border_color=color.gray, border_width=1)

// Helper to get selected TfState
f_get_diag_state() =>
    diagHorizon == "F1" ? tf1State : diagHorizon == "F2" ? tf2State : diagHorizon == "F3" ? tf3State : diagHorizon == "F4" ? tf4State : diagHorizon == "F5" ? tf5State : diagHorizon == "F6" ? tf6State : tf7State

if showDiagPanel and barstate.islast
    st = f_get_diag_state()
    
    // Select model arrays
    cntArr = diagModel == "N" ? st.cntN : st.cnt1
    upArr  = diagModel == "N" ? st.upN  : st.up1
    plattArr = diagModel == "N" ? st.plattN : st.platt1
    brierStats = diagModel == "N" ? st.brierStatsN : st.brierStats1
    llStats = diagModel == "N" ? st.llStatsN : st.llStats1
    
    // Platt params
    plattA = array.get(plattArr, 0)
    plattB = array.get(plattArr, 1)
    
    // Brier/LogLoss
    brierSum = array.get(brierStats, 0)
    brierCnt = array.get(brierStats, 1)
    brierAvg = brierCnt > 0 ? brierSum / brierCnt : na
    
    llSum = array.get(llStats, 0)
    llCnt = array.get(llStats, 1)
    llAvg = llCnt > 0 ? llSum / llCnt : na
    
    // Bin samples (total and per-bin distribution)
    totalSamples = array.sum(cntArr)
    numBins = array.size(cntArr)
    
    // Bin distribution (min/max/avg samples per bin)
    minBin = numBins > 0 ? array.min(cntArr) : 0
    maxBin = numBins > 0 ? array.max(cntArr) : 0
    avgBin = numBins > 0 ? totalSamples / numBins : 0
    
    // Win rate (overall calibrated base rate)
    totalUp = array.sum(upArr)
    baseRate = totalSamples > 0 ? totalUp * 100.0 / totalSamples : 50.0
    
    // Convergence check: Is Platt A stable (should be near 1.0 if well-calibrated)?
    plattStable = (plattA >= 0.7 and plattA <= 1.5) and (plattB >= -0.5 and plattB <= 0.5)
    convStatus = plattStable ? "âœ… Converged" : (plattA < 0.3 or plattA > 3.0) ? "âš ï¸ Unstable" : "ðŸ”„ Adjusting"
    convColor = plattStable ? color.lime : (plattA < 0.3 or plattA > 3.0) ? color.red : color.yellow
    
    // Quality grade
    qualityGrade = na(brierAvg) ? "â€”" : brierAvg < 0.18 ? "A (Excellent)" : brierAvg < 0.22 ? "B (Good)" : brierAvg < 0.25 ? "C (Baseline)" : brierAvg < 0.30 ? "D (Poor)" : "F (No Skill)"
    qualityColor = na(brierAvg) ? color.gray : brierAvg < 0.18 ? color.lime : brierAvg < 0.22 ? color.green : brierAvg < 0.25 ? color.yellow : brierAvg < 0.30 ? color.orange : color.red
    
    // Row 0: Header
    table.cell(diagTbl, 0, 0, "ðŸ”§ Calibration Diagnostics", text_color=color.white, bgcolor=color.new(color.blue, 70), text_size=size.small)
    table.cell(diagTbl, 1, 0, diagHorizon + " / " + diagModel, text_color=color.aqua, bgcolor=color.new(color.blue, 70), text_size=size.small)
    
    // Row 1: Platt A
    table.cell(diagTbl, 0, 1, "Platt A (slope)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 1, str.tostring(plattA, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 2: Platt B
    table.cell(diagTbl, 0, 2, "Platt B (intercept)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 2, str.tostring(plattB, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 3: Convergence status
    table.cell(diagTbl, 0, 3, "SGD Status", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 3, convStatus, text_color=convColor, text_size=size.tiny)
    
    // Row 4: Separator
    table.cell(diagTbl, 0, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 5: Brier Score
    table.cell(diagTbl, 0, 5, "Brier Score", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 5, na(brierAvg) ? "â€”" : str.tostring(brierAvg, "#.####"), text_color=na(brierAvg) ? color.gray : brierAvg < 0.25 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 6: LogLoss
    table.cell(diagTbl, 0, 6, "LogLoss", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 6, na(llAvg) ? "â€”" : str.tostring(llAvg, "#.####"), text_color=na(llAvg) ? color.gray : llAvg < 0.65 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 7: Quality Grade
    table.cell(diagTbl, 0, 7, "Quality Grade", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 7, qualityGrade, text_color=qualityColor, text_size=size.tiny)
    
    // Row 8: Separator
    table.cell(diagTbl, 0, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 9: Total samples
    table.cell(diagTbl, 0, 9, "Total Samples", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 9, str.tostring(totalSamples), text_color=totalSamples >= calMinSamples * numBins ? color.lime : color.yellow, text_size=size.tiny)
    
    // Row 10: Bin distribution
    table.cell(diagTbl, 0, 10, "Bin Min/Avg/Max", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 10, str.tostring(minBin) + "/" + str.tostring(avgBin, "#") + "/" + str.tostring(maxBin), text_color=color.white, text_size=size.tiny)
    
    // Row 11: Warmup progress
    warmupPct = math.min(100, totalSamples * 100.0 / (calMinSamples * numBins))
    table.cell(diagTbl, 0, 11, "Warmup Progress", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 11, str.tostring(warmupPct, "#.0") + "%", text_color=warmupPct >= 100 ? color.lime : warmupPct >= 50 ? color.yellow : color.red, text_size=size.tiny)
    
    // Row 12: Base Rate
    table.cell(diagTbl, 0, 12, "Base Rate (Up%)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 12, str.tostring(baseRate, "#.1") + "%", text_color=math.abs(baseRate - 50) > 15 ? color.orange : color.white, text_size=size.tiny)
    
    // Row 13: Observations count
    table.cell(diagTbl, 0, 13, "Resolutions", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 13, str.tostring(int(brierCnt)), text_color=color.white, text_size=size.tiny)
    
    // Row 14: Separator for new section
    table.cell(diagTbl, 0, 14, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 14, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 15: Current Trend Regime
    atrNormDiag = atr / nz(close, 1)
    trendRegimeDiag = f_trend_regime(emaF, emaS, atrNormDiag)
    trendLabelDiag = trendRegimeDiag > 0.5 ? "ðŸŸ¢ BULL" : trendRegimeDiag < -0.5 ? "ðŸ”´ BEAR" : "ðŸŸ¡ SIDEWAYS"
    trendColorDiag = trendRegimeDiag > 0.5 ? color.lime : trendRegimeDiag < -0.5 ? color.red : color.yellow
    table.cell(diagTbl, 0, 15, "Trend Regime", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 15, trendLabelDiag, text_color=trendColorDiag, text_size=size.tiny)
    
    // Row 16: Vol Regime
    volRegimeDiag = atrRank >= VOL_THRESH_HIGH ? "âš¡ HIGH" : atrRank <= VOL_THRESH_LOW ? "ðŸ¢ LOW" : "â€” NORMAL"
    volColorDiag = atrRank >= VOL_THRESH_HIGH ? color.red : atrRank <= VOL_THRESH_LOW ? color.aqua : color.white
    table.cell(diagTbl, 0, 16, "Vol Regime", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 16, volRegimeDiag + " (" + str.tostring(atrRank * 100, "#") + "%)", text_color=volColorDiag, text_size=size.tiny)
    
    // Row 17: Ensemble Weights Summary
    wSum = wState + wPullback + wRegime + wTrend
    table.cell(diagTbl, 0, 17, "Weights (S/P/V/T)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 17, str.tostring(wState,"#.#")+"/"+str.tostring(wPullback,"#.#")+"/"+str.tostring(wRegime,"#.#")+"/"+str.tostring(wTrend,"#.#"), text_color=color.white, text_size=size.tiny)

//====================
// Alerts (bar close)
//====================
alertcondition(buySignal,   title="BUY (bar close)",   message="BUY {{ticker}} @ {{close}}")
alertcondition(exitSignal,  title="EXIT (bar close)",  message="EXIT {{ticker}} @ {{close}}")
alertcondition(shortSignal, title="SHORT (bar close)", message="SHORT {{ticker}} @ {{close}}")
alertcondition(coverSignal, title="COVER (bar close)", message="COVER {{ticker}} @ {{close}}")

//====================
// Calibration Export Alert (Webhook)
//====================
// Helper to get export TfState
f_get_export_state() =>
    exportHorizon == "F1" ? tf1State : exportHorizon == "F2" ? tf2State : exportHorizon == "F3" ? tf3State : exportHorizon == "F4" ? tf4State : exportHorizon == "F5" ? tf5State : exportHorizon == "F6" ? tf6State : tf7State

// Export calibration state as JSON every N bars
doExport = exportCalibration and barstate.isconfirmed and bar_index % exportInterval == 0
if doExport
    expSt = f_get_export_state()
    
    // Platt params for N and 1 models
    pAN = array.get(expSt.plattN, 0)
    pBN = array.get(expSt.plattN, 1)
    pA1 = array.get(expSt.platt1, 0)
    pB1 = array.get(expSt.platt1, 1)
    
    // Brier/LogLoss stats
    brierSumN = array.get(expSt.brierStatsN, 0)
    brierCntN = array.get(expSt.brierStatsN, 1)
    brierAvgN = brierCntN > 0 ? brierSumN / brierCntN : 0
    
    llSumN = array.get(expSt.llStatsN, 0)
    llCntN = array.get(expSt.llStatsN, 1)
    llAvgN = llCntN > 0 ? llSumN / llCntN : 0
    
    totalSamplesN = array.sum(expSt.cntN)
    
    // Build JSON payload
    jsonPayload = '{' +
        '"ticker":"' + syminfo.ticker + '",' +
        '"horizon":"' + exportHorizon + '",' +
        '"bar_index":' + str.tostring(bar_index) + ',' +
        '"timestamp":"' + str.tostring(timenow) + '",' +
        '"platt_N":{"a":' + str.tostring(pAN, "#.####") + ',"b":' + str.tostring(pBN, "#.####") + '},' +
        '"platt_1":{"a":' + str.tostring(pA1, "#.####") + ',"b":' + str.tostring(pB1, "#.####") + '},' +
        '"brier_avg":' + str.tostring(brierAvgN, "#.####") + ',' +
        '"logloss_avg":' + str.tostring(llAvgN, "#.####") + ',' +
        '"samples":' + str.tostring(totalSamplesN) + ',' +
        '"resolutions":' + str.tostring(int(brierCntN)) +
        '}'
    
    alert(jsonPayload, alert.freq_once_per_bar)

//====================
// Trend Regime Export Alert (for monitoring)
//====================
atrNormCur = atr / nz(close, 1)
curTrendRegime = f_trend_regime(emaF, emaS, atrNormCur)
trendLabel = curTrendRegime > 0.5 ? "BULL" : curTrendRegime < -0.5 ? "BEAR" : "SIDEWAYS"
alertcondition(curTrendRegime > 0.5 and curTrendRegime[1] <= 0.5, title="Regime: BULL", message="{{ticker}} entered BULL regime")
alertcondition(curTrendRegime < -0.5 and curTrendRegime[1] >= -0.5, title="Regime: BEAR", message="{{ticker}} entered BEAR regime")
alertcondition(math.abs(curTrendRegime) <= 0.5 and math.abs(curTrendRegime[1]) > 0.5, title="Regime: SIDEWAYS", message="{{ticker}} entered SIDEWAYS regime")

//====================
// Strategy Execution (Backtest Mode)
//====================
if buySignal
    strategy.entry("L", strategy.long, comment="Brier=" + str.tostring(curBrier, "#.##"))
if shortSignal
    strategy.entry("S", strategy.short, comment="Brier=" + str.tostring(curBrier, "#.##"))
if exitSignal
    strategy.close("L")
if coverSignal
    strategy.close("S")

