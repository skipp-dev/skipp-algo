// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6

indicator("SkippALGO v6.3.13", overlay=true, max_labels_count=500, max_lines_count=500)

config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

engine       = input.string("Hybrid", "Signal engine", options=["Hybrid","Breakout","Trend+Pullback","Loose"])
allowNeuralReversals = input.bool(true, "Allow Neural Reversals (ChoCH)", tooltip="Allows early ChoCH-based reversals. Off = only standard engine entries.")

useForecastGateEntry = input.bool(true, "Entry gate: require forecast edge (3-way)")
entryFcTF    = input.string("F3", "Entry horizon", options=["F1","F2","F3","F4","F5","F6","F7"])
minEdgePP    = input.float(0.10, "Min edge (pp) vs mid", minval=0.00, maxval=0.50, step=0.01)
requireRelOk = input.bool(false, "Entry gate: require bin reliability ok/strong")
requirePathTargetEntry = input.bool(true, "Entry gate: require PathTPvsSL target")
useChopAbstain = input.bool(true, "Chop abstain when Flat high")
flatAbstainThr = input.float(0.55, "Chop abstain: Flat prob â‰¥", minval=0.34, maxval=0.80, step=0.01)

requireSET   = input.bool(false, "Entry gate: require SET (CRSI confluence)")

pbLookback = input.int(12, "Pullback lookback", minval=2)
pbMinATR   = input.float(0.20, "Pullback min depth (ATR)", minval=0.0, step=0.05)
pbMaxATR   = input.float(3.00, "Pullback max depth (ATR)", minval=0.1, step=0.05)

useVolConfirm = input.bool(false, "Volume confirmation")
volLen   = input.int(20, "Volume SMA len", minval=2)
volMult  = input.float(1.20, "Volume mult", minval=0.1, step=0.05)

useAtrRisk = input.bool(true, "ATR Risk Model (Stops/TP/Trail)")
stopATR  = input.float(2.00, "Stop ATR (Initial)", minval=0.1, step=0.10, tooltip="Initial Hard Stop. Wide to survive entry noise.")
tpATR    = input.float(5.00, "Take Profit ATR (Initial)", minval=0.1, step=0.10)
useInfiniteTP = input.bool(false, "Infinite TP (Trailing Stop Only)", tooltip="No fixed TP. Trade exits via SL/Trail and other enabled exit rules.")
useDynamicSlProfile = input.bool(true, "Dynamic SL Profile", tooltip="Adaptive stop: optional early widen, then tighten with growing R.")
dynamicSlWidenUntilR = input.float(0.30, "Dynamic SL widen until R", minval=0.0, step=0.05, tooltip="Early widening phase. 0 disables widening.")
dynamicSlMaxWidenATR = input.float(0.30, "Dynamic SL max widen ATR", minval=0.0, step=0.05, tooltip="Max ATR added to stop distance during widening.")
dynamicSlTightenStartR = input.float(1.00, "Dynamic SL tighten starts at R", minval=0.0, step=0.10, tooltip="From this R, stop distance tightens progressively.")
dynamicSlTightenATRPerR = input.float(0.25, "Dynamic SL tighten ATR per +1R", minval=0.0, step=0.05, tooltip="ATR reduction per additional +1R.")
dynamicSlMaxTightenATR = input.float(1.50, "Dynamic SL max tighten ATR", minval=0.0, step=0.10, tooltip="Max ATR reduction applied by dynamic tightening.")
dynamicSlRequireTrend = input.bool(true, "Dynamic SL requires trend context", tooltip="Long needs bullish trend, short needs bearish trend.")
dynamicSlRequireConf = input.bool(false, "Dynamic SL requires confidence", tooltip="Apply dynamic SL only if confidence is above threshold.")
dynamicSlMinConf = input.float(0.55, "Dynamic SL min confidence", minval=0.0, maxval=1.0, step=0.01)
dynSlPreset30m = input.string("Manual", "All-TF Dynamic SL preset", options=["Manual", "Conservative", "Balanced", "Runner", "Super Runner"], tooltip="All TFs: Conservative 1.00/2.30, Balanced 0.90/2.00, Runner 0.75/1.70, Super Runner 0.65/1.40 (Stop/Trail).")
useDynamicTpExpansion = input.bool(true, "Dynamic TP Expansion", tooltip="TP can expand outward as unrealized R grows.")
dynamicTpKickInR = input.float(1.00, "Dynamic TP starts at R", minval=0.0, step=0.10, tooltip="TP expansion starts at this unrealized R.")
dynamicTpAddATRPerR = input.float(0.50, "Dynamic TP add ATR per +1R", minval=0.0, step=0.05, tooltip="Extra TP ATR added per +1R after kick-in.")
dynamicTpMaxAddATR = input.float(2.50, "Dynamic TP max extra ATR", minval=0.0, step=0.10, tooltip="Cap for additional TP distance from dynamic expansion.")
dynamicTpRequireTrend = input.bool(true, "Dynamic TP requires trend context", tooltip="Long needs bullish trend, short needs bearish trend.")
dynamicTpRequireConf = input.bool(false, "Dynamic TP requires confidence", tooltip="Apply dynamic TP only if confidence is above threshold.")
dynamicTpMinConf = input.float(0.55, "Dynamic TP min confidence", minval=0.0, maxval=1.0, step=0.01)
tpPreset30m = input.string("Manual", "All-TF TP preset", options=["Manual", "Conservative", "Balanced", "Runner", "Super Runner"], tooltip="All TFs: Conservative TP2.5/SL1.1, Balanced TP3.0/SL1.0, Runner TP3.8/SL0.85, Super Runner TP4.4/SL0.75.")
trailATR = input.float(2.50, "Trail ATR", minval=0.1, step=0.10)
trailAfterR = input.float(1.50, "Trail activates after R", minval=0.0, step=0.10)

useRiskDecay = input.bool(true, "Dynamic Risk Decay (Linear Tightening)", tooltip="Interpolates Stop/TP from Initial to Sustained values over N bars.")
decayStopATR = input.float(1.00, "Sustained Stop ATR", minval=0.1)
decayTpATR   = input.float(3.00, "Sustained TP ATR", minval=0.1)
decayBars    = input.int(3, "Decay Duration (Bars)", minval=1, tooltip="Time to transition from Initial Risk to Sustained Risk. Note: if decayBars < exitGraceBars, stop reaches sustained before structural exits are allowed â€” this is intentional to tighten risk while giving the trade time to develop.")

swingL = input.int(5, "Breakout swing left (L)", minval=1, maxval=20)
swingR = input.int(3, "Breakout swing right (R)", minval=1, maxval=20, tooltip="Lower 'R' values detect new structure levels faster.")
swingMaxAgeBars = input.int(0, "Breakout swing max age (bars)", minval=0, maxval=2000, tooltip="0 disables expiry of old swings")
breakoutSource = input.string("Close", "Breakout Source", options=["Close", "Wick"], tooltip="Determines if a breakout requires a candle Close or just a Wick cross.")
structureLogic = input.string("Standard", "Structure Logic", options=["Standard", "SMC+Sweep"], tooltip="Standard: ChoCH = Trend Reversal (Break of Swing Low). SMC+Sweep: ChoCH includes Failed Breakouts (Reclaim of Level).")
chochScalpPreset = input.bool(false, "ChoCH Scalp Fast preset", tooltip="Preset: breakoutSource=Wick, mode=Ping (Fast), swingREff=max(swingR,1). Fast+Safer has priority if both are on.")
chochScalpSaferPreset = input.bool(false, "ChoCH Fast+Safer preset", tooltip="Preset: breakoutSource=Wick, mode=Ping+Verify, swingREff=max(swingR,1).")

useStructureTags = input.bool(true, "Show BOS / ChoCH structure tags")
chochSignalMode  = input.string("Ping+Verify", "ChoCH signal mode", options=["Ping (Fast)", "Verify (Safer)", "Ping+Verify"], tooltip="Manual mode if no preset is active. Fast => Ping, Fast+Safer => Ping+Verify.")
showChochPing    = input.bool(true, "Show ChoCH Ping markers")
chochMinProb     = input.float(0.50, "ChoCH Min Confidence (Prob)", minval=0.34, maxval=0.95, step=0.01)
chochReqVol      = input.bool(true, "ChoCH Require Volume?")

enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(2, "Cooldown bars", minval=0)

cooldownMode = input.string("Bars", "Cooldown mode", options=["Bars", "Minutes"])
cooldownMinutes = input.int(30, "Cooldown minutes", minval=1)
cooldownTriggers = input.string("ExitsOnly", "Cooldown triggers", options=["ExitsOnly", "AllSignals", "EntriesOnly"])
allowSameBarBuyAfterCover = input.bool(false, "Allow same-bar BUY after COVER", tooltip="If enabled, BUY can re-open on the same confirmed bar as a prior COVER. If disabled, BUY waits at least until the next bar.")
allowSameBarShortAfterExit = input.bool(false, "Allow same-bar SHORT after EXIT", tooltip="If enabled, SHORT can re-open on the same confirmed bar as a prior EXIT. If disabled, SHORT waits at least until the next bar.")

grp_sigfilt = "Signal Filters"
usePreMomentum = input.bool(false, "Pre-signal momentum gate", group=grp_sigfilt, tooltip="Require RSI alignment with trade direction")
preMomRsiHi    = input.int(65, "Pre-signal RSI high (long)", minval=55, maxval=80, group=grp_sigfilt)
preMomRsiLo    = input.int(35, "Pre-signal RSI low (short)", minval=20, maxval=45, group=grp_sigfilt)
reqEngulfing = input.bool(false, "Engulfing filter (3 candles)", group=grp_sigfilt, tooltip="Require 3 opposite candles before engulfing candle for BUY/SHORT entries.")
engulfingRequireBodyDominance = input.bool(true, "Engulfing: body > prev body", group=grp_sigfilt, tooltip="Require engulfing candle body to be larger than previous candle body.")
useEmaAccel    = input.bool(false, "EMA acceleration filter", group=grp_sigfilt, tooltip="Check that EMA gap is expanding")
useVwap        = input.bool(false, "VWAP alignment filter", group=grp_sigfilt, tooltip="Long above VWAP, short below (intraday only)")
useSmoothTrend = input.bool(false, "Smooth trend regime", group=grp_sigfilt, tooltip="Replace discrete trend with continuous [-1,1]")
useAdx         = input.bool(false, "ADX trend strength filter", group=grp_sigfilt, tooltip="Require ADX above threshold for trending entries")
adxLen         = input.int(14, "ADX length", minval=5, maxval=50, group=grp_sigfilt)
adxThresh      = input.float(20.0, "ADX min threshold", minval=5.0, maxval=50.0, step=1.0, group=grp_sigfilt)

useRegSlope    = input.bool(false, "Regression Slope filter", group=grp_sigfilt, tooltip="Require positive slope osc for Longs, negative for Shorts")
rsMaxRange     = input.int(100, "RegSlope Max Range", minval=10, group=grp_sigfilt)
rsMinRange     = input.int(10, "RegSlope Min Range", minval=5, group=grp_sigfilt)
rsStep         = input.int(5, "RegSlope Step", minval=1, group=grp_sigfilt)

useAtrRegimeOverlay = input.bool(false, "ATR regime overlay", group=grp_sigfilt, tooltip="Show volatility regime background based on ATR ratio to baseline.")
atrRegimeBaselineLen = input.int(50, "ATR regime baseline len", minval=20, maxval=300, group=grp_sigfilt)
atrRegimeBaselineType = input.string("SMA", "ATR regime baseline", options=["SMA", "EMA"], group=grp_sigfilt)
atrCompressionThr = input.float(0.70, "ATR compression threshold", minval=0.30, maxval=0.95, step=0.05, group=grp_sigfilt)
atrExpansionThr = input.float(1.15, "ATR expansion threshold", minval=1.00, maxval=2.00, step=0.05, group=grp_sigfilt)
atrHighVolThr = input.float(1.40, "ATR high-vol threshold", minval=1.10, maxval=3.00, step=0.05, group=grp_sigfilt)
atrExhaustLookback = input.int(5, "ATR exhaustion lookback", minval=3, maxval=30, group=grp_sigfilt)
enableAtrPercentile = input.bool(false, "ATR percentile context", group=grp_sigfilt, tooltip="Compute ATR percentile rank for context (0..100).")
atrPercentileLookback = input.int(100, "ATR percentile lookback", minval=50, maxval=500, group=grp_sigfilt)

useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

f_zl_src(src, len) =>
    e1 = ta.ema(src, len)
    e2 = ta.ema(e1, len)
    2.0 * e1 - e2

f_zl_src_pct(_src, _len, _pct) =>
    int lag = math.max(1, int(math.floor((_len - 1) / 2)))
    float lead = na(_src) or na(_src[lag]) ? na : (_src - _src[lag])
    float k = float(_pct) / 100.0
    float out = na(lead) ? _src : (_src + k * lead)
    out

f_zl_trend_core(_src, _len, _aggr) =>
    emaBase = ta.ema(_src, _len)
    zlBase = f_zl_src(_src, _len)
    na(zlBase) ? emaBase : (emaBase + _aggr * (zlBase - emaBase))

tfF1 = input.timeframe("1",   "Forecast 1")
tfF2 = input.timeframe("5",   "Forecast 2")
tfF3 = input.timeframe("15",  "Forecast 3")
tfF4 = input.timeframe("30",  "Forecast 4")
tfF5 = input.timeframe("60",  "Forecast 5")
tfF6 = input.timeframe("240", "Forecast 6")
tfF7 = input.timeframe("D",   "Forecast 7")

trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

f_log_regression_single(src, length) =>
    if length < 2
        0.0
    else
        float sumX      = 0.0
        float sumY      = 0.0
        float sumXSqr   = 0.0
        float sumXY     = 0.0
        bool failed     = false
        for i = 0 to length - 1
            v = src[i]
            if na(v) or v <= 0
                failed := true
                break
            val = math.log(v)
            per = i + 1.0
            sumX += per
            sumY += val
            sumXSqr += per * per
            sumXY += val * per
        
        if failed
            float(na)
        else
            slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)
            slope * -1

f_calc_reg_slope_osc(src, minR, maxR, stepV) =>
    float slopeSum = 0.0
    int slopeCount = 0
    for i = minR to maxR by stepV
        res = f_log_regression_single(src, i)
        if not na(res)
            slopeSum += res
            slopeCount += 1
    slopeCount > 0 ? slopeSum / slopeCount : 0.0

SEC_5M  = 5 * 60
SEC_15M = 15 * 60
SEC_30M = 30 * 60
SEC_1H  = 60 * 60
SEC_4H  = 4 * 60 * 60

VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)
LOGIT_CLAMP     = 20.0    // Clamp for logit to limit extreme values
PRICE_EPS       = 0.0001  // Epsilon for price/ATR divisions

ROLL_RECALC_INTERVAL = 500

SIDEWAYS_EMA_THRESH = 0.005   // Max EMA diff ratio for sideways
SIDEWAYS_ATR_THRESH = 0.015   // Max ATR norm for sideways

SCORE_NEUTRAL_BAND  = 0.05    // MTF & outSym neutral dead-zone
TREND_SMOOTH_THRESH = 0.3     // Smooth trend strength threshold

HW_STRONG           = 0.05    // CI half-width: strong calibration
HW_OK               = 0.10    // CI half-width: acceptable calibration
ECE_GOOD            = 0.05    // ECE: well-calibrated
ECE_FAIR            = 0.10    // ECE: fair calibration
BRIER_EXCELLENT     = 0.18    // Brier score: A grade
BRIER_GOOD          = 0.22    // Brier score: B grade
BRIER_BASELINE      = 0.25    // Brier score: C grade (random)
BRIER_POOR          = 0.30    // Brier score: D grade

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showLongLabels   = input.bool(true, "Show Long labels (BUY / EXIT)")
showShortLabels  = input.bool(true, "Show Short labels (SHORT / COVER)")
// Removed showDebugLabels to cleanup user interface
showPreEntryLabels = input.bool(true, "Show PRE labels (PRE-BUY / PRE-SHORT)")
preWarnDistATR     = input.float(0.25, "PRE: proximity threshold (ATR)", minval=0.0, step=0.05, tooltip="Used for pre-warnings (Breakout / Trend+Pullback / Loose)")
preSetPulseOnly    = input.bool(true, "PRE: pulse-only SET", tooltip="When enabled, PRE labels require a fresh SET transition (pulse) instead of a steady SET state")
setPulseOnly     = input.bool(true, "SET: pulse only", tooltip="When enabled, SET prints only on the transition into a SET state")
// [REMOVED] Table UI toggles (table rendering disabled for token budget)
// [REMOVED] Unused Engulf Stats inputs (token reduction)

labelPriceMode    = input.string("Bar Extremes", "Label price", options=["Bar Extremes","Entry Price","Close"])

// Alerts
alertOnBarCloseOnly = input.bool(false,  "Alerts: bar close only")
strictMtfMargin = input.float(0.02, "Strict: MTF extra margin", minval=0.0, maxval=0.20, step=0.01, tooltip="Additional margin above/below SCORE_NEUTRAL_BAND required for strict BUY/SHORT confirmation.")
strictChochConfirmBars = input.int(1, "Strict: ChoCH confirm bars", minval=1, maxval=5, tooltip="For REV entries in strict mode, ChoCH must remain recent within this many bars on confirmation.")
useAdaptiveStrictMargin = input.bool(false, "Strict: adaptive MTF margin", tooltip="Adapts strictMtfMargin by ATR regime: stricter in high vol, looser in calm markets.")
strictAdaptiveRange = input.float(0.02, "Strict: adaptive range", minval=0.0, maxval=0.10, step=0.005, tooltip="Max additional/subtracted margin around strictMtfMargin based on ATR regime.")
strictAdaptiveLen = input.int(100, "Strict: adaptive ATR rank len", minval=20, maxval=500)
showStrictSignalMarkers = input.bool(true, "Show Strict confirmed markers")
strictMarkerStyle = input.string("Icon", "Strict marker style", options=["Icon", "Label", "Both"])

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

useRevOpenWindow  = input.bool(true, "Bypass pU/pD near market open", tooltip="Allow BUY/REV-BUY/SHORT/REV-SHORT to fire regardless of directional probability (pU/pD) during a window around the stock exchange open.")
rthOpenHour       = input.int(9,  "RTH open hour (exchange tz)", minval=0, maxval=23)
rthOpenMinute     = input.int(30, "RTH open minute", minval=0, maxval=59)
revOpenWindowLongMins = input.int(10, "Open window LONG Â± min", minval=1, maxval=120, tooltip="Long-side bypass window around RTH open.")
revOpenWindowShortMins = input.int(10, "Open window SHORT Â± min", minval=1, maxval=120, tooltip="Short-side bypass window around RTH open.")
revOpenWindowMode = input.string("All Entries", "Open window applies to", options=["All Entries", "Reversals Only"], tooltip="All Entries: bypass forecast gate + reversal pU/pD. Reversals Only: bypass only REV probability filter.")
revOpenWindowEngine = input.string("All", "Open window engine scope", options=["All", "Hybrid", "Breakout", "Trend+Pullback", "Loose"], tooltip="Limit open-window bypass to specific engines.")

//====================
// Inputs â€” Forecast Calibration Enhancements
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")
allowForecastOnNonFixed = input.bool(false, "Forecast: allow on non-fixed TFs", tooltip="If chart timeframe can't be resolved to seconds, allow forecast gating instead of disabling it")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])

//====================
// Liquidity Concepts (SMC)
//====================
grp_smc = "Liquidity Concepts (SMC)"
useLiqSweep     = input.bool(true, "Filter Reversals by Liquidity Sweep", group=grp_smc, tooltip="Only take Reversal entries if a Liquidity Sweep (stop hunt) occurred recently.")
liqSweepLookback= input.int(10, "Sweep Lookback (Bars)", minval=1, group=grp_smc)

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", minval=0.01, step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", minval=0.01, step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", minval=0.01, step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", minval=0.01, step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpATRM    = input.float(0.80, "Path TP", minval=0.01, step=0.05, group=grp_mid)
slATRM    = input.float(1.00, "Path SL", minval=0.01, step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", minval=0.01, step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.00, "Path TP", minval=0.01, step=0.05, group=grp_slow)
slATRS    = input.float(1.00, "Path SL", minval=0.01, step=0.05, group=grp_slow)

// Global Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"])
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"])
atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)
exitGraceBars = input.int(5, "Exit Grace Period (Bars)", minval=0, tooltip="Prevents structural exits (trend flips) for the first N bars after entry to avoid immediate wicks/noise.")

//====================
// Automation Inputs (TradersPost / Webhooks)
//====================
grp_auto   = "Automation"
useJsonAlerts = input.bool(false, "Enable JSON Webhook Payloads", group=grp_auto, tooltip="Formats alerts as JSON for TradersPost or other bots. If disabled, sends human-readable text.")

//====================
// Inputs â€” Forecast 3-way (Up/Flat/Down)
//====================
grp_tri = "Forecast 3-way (Up/Flat/Down)"
use3Way = input.bool(true, "3-way probs: Up/Flat/Down", group=grp_tri)

deadbandFast = input.float(0.15, "Deadband Ã— ATR (Fast <=5m)", minval=0.0, step=0.01, group=grp_tri)
deadbandMid  = input.float(0.10, "Deadband Ã— ATR (Mid <=1h)",  minval=0.0, step=0.01, group=grp_tri)
deadbandSlow = input.float(0.07, "Deadband Ã— ATR (Slow >1h)",  minval=0.0, step=0.01, group=grp_tri)

flatPriorFast = input.float(0.42, "Warmup prior: Flat (Fast)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorMid  = input.float(0.30, "Warmup prior: Flat (Mid)",  step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorSlow = input.float(0.22, "Warmup prior: Flat (Slow)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)

tiltMaxFast = input.float(0.10, "Warmup tilt max (Fast)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxMid  = input.float(0.12, "Warmup tilt max (Mid)",  step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxSlow = input.float(0.15, "Warmup tilt max (Slow)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)


calibratorMode = input.string("Vector", "3-way calibrator", options=["Off","Temp","Vector"], group=grp_tri)
lrCal = input.float(0.01, "Calibrator LR", step=0.001, minval=0.0001, group=grp_tri)
tempMin = input.float(0.5, "Temp min", step=0.1, minval=0.1, group=grp_tri)
tempMax = input.float(5.0, "Temp max", step=0.1, minval=0.5, group=grp_tri)
vecAMin = input.float(0.25, "Vec A min", step=0.05, minval=0.05, group=grp_tri)
vecAMax = input.float(3.0, "Vec A max", step=0.05, minval=0.5, group=grp_tri)
vecBMin = input.float(-2.0, "Vec B min", step=0.1, group=grp_tri)
vecBMax = input.float(2.0, "Vec B max", step=0.1, group=grp_tri)
cal3AutoFallback = input.bool(true, "3-way auto fallback (weak bins)", group=grp_tri)
cal3MinSamples  = input.int(90, "3-way min samples for calibrator", minval=10, maxval=5000, group=grp_tri)
calRegStrength  = input.float(0.002, "Calibrator stabilize strength", minval=0.0, step=0.001, group=grp_tri)
useBullBearCal = input.bool(true, "Separate bull/bear calibrators", group=grp_tri)
countDecay = input.float(0.9995, "Count decay (1.0=none)", minval=0.80, maxval=1.0, step=0.0005, group=grp_tri)
kShrinkReg = input.int(20, "Regime shrinkage k", minval=0, maxval=1000, group=grp_tri)

// --- Phase 2: Calibration Dimensions ---
predBinsN     = input.int(4, "Pred bins (N) state", minval=2, maxval=9)
dim2Bins      = 3 // Fixed: Trend regime bins (bear/sideways/bull)

predBins1     = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3)

// Quantile binning (score dimension)
useQuantileBins = input.bool(true, "Use quantile bins (score)")
quantileWindow = input.int(500, "Quantile window (samples)", minval=100, maxval=5000)
quantileUpdate = input.int(25, "Quantile update interval (bars)", minval=10, maxval=1000)
quantileMinSamples = input.int(200, "Quantile min samples", minval=50, maxval=5000)
calibrateInBackground = input.bool(true, "Calibrate even if table hidden")

alphaN  = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1)
alpha1  = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1)
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000)

calMinSamples = input.int(30, "Min samples per bin (activate)", minval=5, maxval=1000)

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01)
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01)

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", minval=0.0, step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", minval=0.0, step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", minval=0.0, step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", minval=0.0, step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")
// B2 â€“ ROC factor in ensemble
wRoc      = input.float(0.0, "Weight: ROC factor", minval=0.0, step=0.1, group=grp_ens, tooltip="Rate of Change momentum (0=off)")
rocLen    = input.int(10, "ROC length", minval=2, maxval=50, group=grp_ens)
// B4 â€“ Volume in ensemble
wVol      = input.float(0.0, "Weight: Volume factor", minval=0.0, step=0.1, group=grp_ens, tooltip="Volume vs SMA ratio (0=off)")
volEnsLen = input.int(20, "Volume ensemble SMA len", minval=2, maxval=100, group=grp_ens)

// --- Phase 4: Platt Scaling (Online Calibration) ---
usePlatt = input.bool(true, "Phase 4: Use Platt Scaling (SGD)", group="Calibration Tuning")
lrPlatt  = input.float(0.005, "Learning Rate", step=0.001, group="Calibration Tuning")
// A2 â€“ SGD Momentum (Adam-lite)
useSgdMomentum = input.bool(false, "SGD momentum (Adam-lite)", group="Calibration Tuning", tooltip="EMA of gradients for smoother convergence")
sgdBeta        = input.float(0.9, "SGD momentum beta", minval=0.5, maxval=0.99, step=0.01, group="Calibration Tuning")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7","ChartTF"])
resetNow   = input.bool(false, "Reset selected calibration NOW")


//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F3", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")

// Evidence / coverage gating
evidenceGate = input.bool(false, "Evidence gate (block weak bins)")
evidenceMinTotal = input.int(120, "Evidence min total samples", minval=1, maxval=10000)
abstainGate = input.bool(true, "Abstain on weak decisions")
abstainMinEdge = input.float(0.08, "Abstain min edge (pp)", minval=0.0, maxval=0.50, step=0.01)
// New: Allow strong signals significantly trusted by the model to bypass the "Min Samples" gate
abstainOverrideConf = input.float(0.85, "Abstain override: High Conf", minval=0.5, step=0.05, tooltip="If Confidence > this level, ignore sample size gates. Allows rare but high-quality signals.")

// Trade-gate thresholds (separate from calibration thresholds)
tradeMinBinSamples   = input.int(10, "Trade gate: min BIN samples", minval=0, maxval=200)
tradeMinTotalSamples = input.int(0,  "Trade gate: min TOTAL samples (0=off)", minval=0, maxval=20000)
rescueVolMult = input.float(1.5, "Rescue Mode: Min Volume (xSMA)", minval=1.0, maxval=50.0, step=0.1, tooltip="Volume ratio required to trigger Rescue Mode (bypasses gates).")
rescueImpulseATR = input.float(0.7, "Rescue Mode: Min Impulse (xATR)", minval=0.1, step=0.1, tooltip="Minimum candle body size (in ATR) to validate a Rescue Reversal.")
revMinProb       = input.float(0.50, "REV: Min dir prob", minval=0.20, maxval=0.80, step=0.01, tooltip="Minimum directional probability for REV-BUY / REV-SHORT (normal path). Raise to require stronger forecast conviction for reversals.")
revRecencyBars   = input.int(5, "Rev Recency (bars)", minval=1, maxval=20, tooltip="Max bars since ChoCH for a reversal signal to be considered recent enough.")


//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ConfErr/Drift)")

evalInBackground = input.bool(true, "Eval in background (when Eval section hidden)")

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"], tooltip="History+Live: counts confirmed historical + live outcomes, so Success rate is visible immediately (example: 62% (N=500)). LiveOnly: counts confirmed realtime outcomes only, so it starts at 0% (N=0) on history and grows during live bars (example: 66% (N=15)).")

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

evalBucketCount = use3Way ? evalBuckets * 3 : evalBuckets

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)
useEceGate      = input.bool(false, "Gate entries by ECE")
eceMax          = input.float(0.10, "Max ECE (gate)", minval=0.01, maxval=0.50, step=0.01)
useDriftGate    = input.bool(false, "Gate entries by drift")
driftMaxPP      = input.float(12.0, "Max drift (pp, gate)", minval=1.0, maxval=50.0, step=0.5)
useEvalPenalty  = input.bool(true, "Soft penalty on eval degrade")
eceWarn         = input.float(0.08, "ECE warn threshold", minval=0.01, maxval=0.50, step=0.01)
evalPenalty     = input.float(0.10, "Eval penalty (confidence)", minval=0.0, maxval=0.50, step=0.01)
// A5 â€“ ECE-triggered recalibration
useEceRecal     = input.bool(false, "ECE-triggered recal (boost LR)", tooltip="Temporarily boost Platt LR when ECE exceeds warn")
eceRecalBoost   = input.float(3.0, "ECE recal LR multiplier", minval=1.5, maxval=10.0, step=0.5)

//====================
// Inputs â€” USI Quantum Pulse (visual overlay only â€” no signal influence)
//====================
useUsi          = input.bool(true, "Enable USI Quantum Pulse", group="âš¡ USI Quantum Pulse", tooltip="Multi-length RSI stacking overlay. Also used by trend/score filters and reversal quality gates when enabled.")
usiLen1         = input.int(13, "Length 1 (slowest / Blue)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen2         = input.int(11, "Length 2 (Green)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen3         = input.int(7,  "Length 3 (Yellow)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen4         = input.int(5,  "Length 4 (Orange)", minval=2, group="âš¡ USI Quantum Pulse")
usiLen5         = input.int(3,  "Length 5 (fastest / Red)", minval=1, group="âš¡ USI Quantum Pulse")
usiZeroLag      = input.bool(true, "Zero-Lag mode", group="âš¡ USI Quantum Pulse", tooltip="Error-corrected EMA on source before RSI. Gives 2-5 bar lead over standard RSI.")
// USI: Zero-Lag red line (Option 2)
useUsiZeroLagRed = input.bool(false, "USI: Zero-Lag Red (earlier flips)", group="âš¡ USI Quantum Pulse")
usiZlAggressiveness = input.int(100, "USI ZL aggressiveness %", minval=0, maxval=200, group="âš¡ USI Quantum Pulse")
usiMinStack     = input.int(2, "Min stacking for visual highlight", minval=2, maxval=5, group="âš¡ USI Quantum Pulse", tooltip="Lines in correct order (out of 4 pairs) for visual stacking highlight.")
usiFlipMode     = input.string("Tier A: Red vs Blue", "USI Flip Logic", options=["Tier A: Red vs Blue", "Tier B: Red vs Avg", "Tier C: Envelope"], group="âš¡ USI Quantum Pulse", tooltip="Tier A (Fast): Red crosses Blue line. Tier B (Balanced): Red crosses Avg of lines. Tier C (Strict): Red crosses entire Envelope.")

// v6.3.3: USI Fast+Verify Inputs
usiTfGate = input.timeframe("30", "Gate TF (Regime)", group="âš¡ USI Quantum Pulse")
usiEmaLen = input.int(100, "EMA Length (Gate)", minval=1, group="âš¡ USI Quantum Pulse")
usiTightFactor  = input.float(0.40, "USI Tight Spread Factor", minval=0.05, step=0.05, group="âš¡ USI Quantum Pulse") 
usiSpreadLookback = input.int(100, "Spread Lookback", minval=20, group="âš¡ USI Quantum Pulse")
hardenHold      = input.bool(true, "Hardened Hold (L5 > L4)", group="âš¡ USI Quantum Pulse", tooltip="Requires L5 to be above/below L4 in addition to Cluster, reducing fakeouts.")
usiAggressiveSameBarVerify = input.bool(false, "USI Aggressive: same-bar verify", group="âš¡ USI Quantum Pulse", tooltip="Uses the current bar cross for verification instead of waiting for [1] cross memory.")
usiAggressiveOneOfThree = input.bool(false, "USI Aggressive: verify 1-of-3", group="âš¡ USI Quantum Pulse", tooltip="Relaxes standard verify voting from 2-of-3 to 1-of-3 (tight-spread strict mode remains Hold+Continuation).")
usiAggressiveTightSpreadVotes = input.bool(false, "USI Aggressive: tight-spread votes", group="âš¡ USI Quantum Pulse", tooltip="When enabled, tight-spread mode also uses vote logic (2-of-3 or 1-of-3) instead of strict Hold+Continuation only.")
useUsiTrendOverride = input.bool(true, "USI blocks contrary entries", group="âš¡ USI Quantum Pulse", tooltip="When enabled, USI bearish state blocks long entries and bullish state blocks short entries. Disable to let scoring handle USI influence only (symmetric with useUsi).")

//====================
// Inputs â€” RFC v6.4 Phase 1 Scaffold (default-off)
//====================
grp_phase1 = "RFC v6.4 Phase 1"
useZeroLagTrendCore = input.bool(false, "Use Zero-Lag Trend Core", group=grp_phase1)
trendCoreMode = input.string("AdaptiveHybrid", "Trend Core Mode", options=["ClassicEMA","ZeroLagEMA","AdaptiveHybrid"], group=grp_phase1)
zlTrendLenFast = input.int(13, "ZL Fast Length", minval=2, group=grp_phase1)
zlTrendLenSlow = input.int(34, "ZL Slow Length", minval=3, group=grp_phase1)
zlTrendAggressiveness = input.float(0.35, "ZL Aggressiveness", minval=0.0, maxval=1.0, step=0.05, group=grp_phase1)
zlTrendNoiseGuard = input.float(0.15, "ZL Noise Guard", minval=0.0, maxval=1.0, step=0.05, group=grp_phase1)
// [REMOVED] Regime Classifier 2.0 inputs + runtime (dead code â€” token reduction)

//====================
// Inputs â€” Score Engine (Option C)
//====================
grp_score = "Score Engine (Option C)"
lockPresetOverrides = input.bool(false, "Preserve current settings (lock preset overrides)", group=grp_score, tooltip="When enabled, Intraday/Swing preset auto-overrides are ignored and your current input values are kept.")
entryPreset = input.string("Manual", "Entry preset", options=["Manual", "Intraday", "Swing"], group=grp_score)
entryBehaviorProfile = input.string("Legacy (v6.3.9-like)", "Entry behavior profile", options=["Current (v6.3.12)", "Legacy (v6.3.9-like)", "Scalp Early (v6.3.12-fast)"], group=grp_score, tooltip="Current keeps the stricter v6.3.12 score/context/chop behavior. Legacy loosens entry strictness to approximate v6.3.9 timing. Scalp Early keeps v6.3.12 structure but lowers entry thresholds for earlier confirmations.")
presetAutoCooldown = input.bool(false, "Preset controls cooldown", group=grp_score, tooltip="If enabled, Intraday/Swing preset also overrides cooldown mode/minutes/triggers.")
useScoreEntries = input.bool(true, "Enable Score-Based Entries", group=grp_score, tooltip="Alternative entry logic based on accumulative evidence score.")
minDirProbLong = input.float(0.42, "Min dir prob (Long)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
minDirProbShort = input.float(0.42, "Min dir prob (Short)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
scoreThresholdLong = input.int(6, "Score Threshold (Long)", minval=1, group=grp_score)
scoreThresholdShort = input.int(6, "Score Threshold (Short)", minval=1, group=grp_score)
scoreUseProbGate = input.bool(true, "Score requires min dir prob", group=grp_score, tooltip="When enabled, score BUY/SHORT needs minimum directional probability (pU/pD).")
scoreMinProbLong = input.float(0.35, "Score min pU (Long)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
scoreMinProbShort = input.float(0.35, "Score min pD (Short)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
enforceGlobalProbFloor = input.bool(true, "Enforce score min pU/pD on all entries", group=grp_score, tooltip="When enabled, Score min pU (Long) and Score min pD (Short) are applied as hard floors to all entry paths (engine, score, and reversal).")
scoreUseConfGate = input.bool(true, "Score requires min confidence", group=grp_score, tooltip="Optional hard filter: score BUY/SHORT requires minimum model confidence.")
scoreMinConfLong = input.float(0.50, "Score min confidence (Long)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
scoreMinConfShort = input.float(0.50, "Score min confidence (Short)", minval=0.0, maxval=1.0, step=0.01, group=grp_score)
scoreRequireDirectionalContext = input.bool(true, "Score requires directional context", group=grp_score, tooltip="If enabled, score-based BUY needs bullish context (Trend/USI), and score-based SHORT needs bearish context.")
wUsi        = input.int(4, "Weight: USI Cross", minval=0, group=grp_score)
wLiquidity  = input.int(2, "Weight: Liquidity/Sweep", minval=0, group=grp_score)
wMomentum   = input.int(2, "Weight: Momentum", minval=0, group=grp_score)
wEngulfing  = input.int(2, "Weight: Engulfing", minval=0, group=grp_score)
wTrendContext = input.int(1, "Weight: Trend Context", minval=0, group=grp_score)
wChopPenalty = input.int(-3, "Penalty: Chop/Consolidation", maxval=0, group=grp_score, tooltip="Negative points applied during low volatility phases.")

//====================
// Inputs â€” VWT Trend Filter
//====================
grp_vwt = "VWT Trend Filter"
useVwtTrendFilter = input.bool(false, "Enable VWT Trend Filter", group=grp_vwt)
vwtPreset = input.string("Auto", "VWT preset", options=["Auto", "Default", "Fast Response", "Smooth Trend", "Custom"], group=grp_vwt)
vwtLengthInput = input.int(55, "VWT length", minval=2, group=grp_vwt)
vwtAtrMultInput = input.float(1.6, "VWT ATR multiplier", minval=0.1, step=0.1, group=grp_vwt)
vwtReversalOnly = input.bool(true, "VWT only on reversal entries", group=grp_vwt)
vwtReversalWindowBars = input.int(12, "VWT reversal window (bars)", minval=1, group=grp_vwt)
showVwtTrendBackground = input.bool(false, "Show VWT trend background", group=grp_vwt)

//====================
// Inputs â€” Debug
//====================
// Removed showEvidencePackDebug and debugProbeTime to cleanup user interface
showOpsRow = input.bool(true, "Ops row (always-on safety HUD)", group="ðŸ”§ Debug", tooltip="Shows coverage + EP + INV! + health glyph even when Evaluation rows are hidden")

//====================
// Inputs â€” Exit Filters
//====================
grp_exit = "Exit Filters (Confidence)"
chochGraceBars = input.int(2, "ChoCH Exit Grace (bars)", minval=0, maxval=10, group=grp_exit, tooltip="Min bars after entry before ChoCH can trigger an exit. Prevents same-bar exit.")
useStrictEmaExit = input.bool(false, "Strict EMA Exit (Close < Slow)", group=grp_exit, tooltip="If disabled, exits only occur on full EMA trend flips (EmaF crosses EmaS), ignoring price closes below Slow EMA.")


//====================
// Calibration storage â€” per horizon TF (Global State)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    float[] cntN
    float[] upN
    float[] dnN
    float[] cnt1
    float[] up1
    float[] dn1
    float[] cntN_bull
    float[] upN_bull
    float[] dnN_bull
    float[] cntN_bear
    float[] upN_bear
    float[] dnN_bear
    float[] cnt1_bull
    float[] up1_bull
    float[] dn1_bull
    float[] cnt1_bear
    float[] up1_bear
    float[] dn1_bear
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    int[]   qBias
    bool[]  qUseForecast
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    float[] qPUpN
    float[] qPFlN
    float[] qPDnN
    float[] qPUp1
    float[] qPFl1
    float[] qPDn1
    float[] qZUpN
    float[] qZFlN
    float[] qZDnN
    float[] qZUp1
    float[] qZFl1
    float[] qZDn1
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    float[] tempN
    float[] temp1
    float[] vecAN
    float[] vecBN
    float[] vecA1
    float[] vecB1
    float[] tempN_bull
    float[] temp1_bull
    float[] vecAN_bull
    float[] vecBN_bull
    float[] vecA1_bull
    float[] vecB1_bull
    float[] tempN_bear
    float[] temp1_bear
    float[] vecAN_bear
    float[] vecBN_bear
    float[] vecA1_bear
    float[] vecB1_bear
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1
    float[] cntN_raw
    float[] upN_raw
    float[] dnN_raw
    float[] cnt1_raw
    float[] up1_raw
    float[] dn1_raw
    float[] cntN_bull_raw
    float[] upN_bull_raw
    float[] dnN_bull_raw
    float[] cntN_bear_raw
    float[] upN_bear_raw
    float[] dnN_bear_raw
    float[] cnt1_bull_raw
    float[] up1_bull_raw
    float[] dn1_bull_raw
    float[] cnt1_bear_raw
    float[] up1_bear_raw
    float[] dn1_bear_raw
    float[] momPlattN
    float[] momPlatt1
    float[] qScoreBuf
    float[] qCutsN
    float[] qCuts1
    float[] evBrierBaseU_N
    float[] evSumBrierBaseU_N
    float[] evLogBaseU_N
    float[] evSumLogBaseU_N
    float[] evBrierBaseU_1
    float[] evSumBrierBaseU_1
    float[] evLogBaseU_1
    float[] evSumLogBaseU_1
    float[] evBrierBaseP_N
    float[] evSumBrierBaseP_N
    float[] evLogBaseP_N
    float[] evSumLogBaseP_N
    float[] evBrierBaseP_1
    float[] evSumBrierBaseP_1
    float[] evLogBaseP_1
    float[] evSumLogBaseP_1
    float[] priorCounts3
    float[] evBrierN_Elig
    float[] evSumBrierN_Elig
    float[] evLogN_Elig
    float[] evSumLogN_Elig
    float[] evBrier1_Elig
    float[] evSumBrier1_Elig
    float[] evLog1_Elig
    float[] evSumLog1_Elig
    float[] evBrierBaseU_N_Elig
    float[] evSumBrierBaseU_N_Elig
    float[] evLogBaseU_N_Elig
    float[] evSumLogBaseU_N_Elig
    float[] evBrierBaseP_N_Elig
    float[] evSumBrierBaseP_N_Elig
    float[] evLogBaseP_N_Elig
    float[] evSumLogBaseP_N_Elig
    float[] priorCounts3_Elig
    int enqCount
    int resolvedScored
    int enqCountElig
    int resolvedScoredElig
    int skipBias0
    int skipAtrInvalid
    int skipIgnore
    int skipTieNeutral2Way
    int skipTotalElig
    int skipBias0Elig
    int skipAtrInvalidElig
    int skipIgnoreElig
    int skipTieNeutral2WayElig
    float[] ageAtResolve
    float[] sumAgeResolve
    int prevQDepth

f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
            array.new_int(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
            array.new_int(),
            array.new_bool(),
            array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.from(1.0, 0.0), array.from(1.0, 0.0),
    array.from(1.0), array.from(1.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0), array.from(1.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0), array.from(1.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
        array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float(),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
    array.new_int(), array.new_float(), array.new_float(),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
    array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.new_float(), array.new_float(int(math.max(nBinsN - 1, 0)), na), array.new_float(int(math.max(nBins1 - 1, 0)), na),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(3, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
    array.new_float(3, 0.0),
    0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0,
    array.new_float(),
    array.new_float(1, 0.0),
    na
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)

//====================
// Helpers
//====================

f_safe_remove_float(float[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

f_safe_remove_int(int[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

f_safe_get_float(float[] arr, int idx, float fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

f_safe_get_int(int[] arr, int idx, int fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

f_safe_remove_bool(bool[] arr, int idx) =>
    if idx >= 0 and idx < array.size(arr)
        array.remove(arr, idx)

f_safe_get_bool(bool[] arr, int idx, bool fallback) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : fallback

f_fill_cuts(sorted, cuts, bins) =>
    cutCount = bins - 1
    if cutCount > 0
        n = array.size(sorted)
        for i = 0 to cutCount - 1
            frac = (i + 1.0) / bins
            idx = int(math.floor(frac * (n - 1)))
            array.set(cuts, i, array.get(sorted, idx))

f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = int(math.floor(u * bins))
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b

f_update_quantiles(TfState st, score) =>
    if useQuantileBins and (calibrateInBackground or showEvalSection)
        array.push(st.qScoreBuf, score)
        if array.size(st.qScoreBuf) > quantileWindow
            array.shift(st.qScoreBuf)
        if bar_index % quantileUpdate == 0 and array.size(st.qScoreBuf) >= quantileMinSamples
            tmp = array.copy(st.qScoreBuf)
            array.sort(tmp, order.ascending)
            f_fill_cuts(tmp, st.qCutsN, predBinsN)
            f_fill_cuts(tmp, st.qCuts1, predBins1)

f_bin_quantile(score, cuts, bins) =>
    if (not useQuantileBins) or array.size(cuts) == 0 or na(array.get(cuts, 0))
        f_bin(score, bins)
    else
        b = 0
        for i = 0 to array.size(cuts) - 1
            if score <= array.get(cuts, i)
                b := i
                break
            else
                b := i + 1
        math.max(0, math.min(bins - 1, b))

f_regime_bin(trendScore) =>
    trendScore > 0.5 ? 2 : trendScore < -0.5 ? 0 : 1

// --- 95% CI half-width (approx) for Bernoulli p with n samples
f_ci95_halfwidth(p, n) =>
    if na(p) or na(n) or n <= 0
        na
    else
        z2 = Z_95 * Z_95
        den = 1.0 + z2 / n
        half = (Z_95 * math.sqrt((p * (1.0 - p) / n) + (z2 / (4.0 * n * n)))) / den
        half

// --- Reliability label based on CI half-width
f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= HW_STRONG ? "strong" : hw <= HW_OK ? "ok" : "weak"
    lbl

//====================
// Forecast display helpers (human formatting)
//====================

// [REMOVED] f_profile / f_target_for_tf / f_target_profile_desc / f_target_footer_text
// Token Reduction 105


//====================
// Helpers â€” Evaluation (proper scoring + rolling stats)
//====================
f_epsClamp(p) =>
    eps = PROB_EPS
    math.max(eps, math.min(1.0 - eps, p))

f_brier(p, y) =>
    // y in {0.0, 1.0}
    d = p - y
    d * d

f_logloss(p, y) =>
    // y in {0.0, 1.0}
    pc = f_epsClamp(p)
    if na(pc) or na(y)
        float(na)
    else
        -(y * math.log(pc) + (1.0 - y) * math.log(1.0 - pc))

f_update_accum_stats(statsArr, val) =>
    if not na(val)
        curSum = array.get(statsArr, 0)
        curCnt = array.get(statsArr, 1)
        array.set(statsArr, 0, curSum + val)
        array.set(statsArr, 1, curCnt + 1.0)

f_roll_add(buf, sumArr, v, maxLen) =>
    array.push(buf, v)
    array.set(sumArr, 0, array.get(sumArr, 0) + v)
    if array.size(buf) > maxLen
        old = array.shift(buf)
        array.set(sumArr, 0, array.get(sumArr, 0) - old)
    // Periodic recalculation to prevent floating-point drift
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(buf) > 0
        array.set(sumArr, 0, array.sum(buf))

// @function Reset single-element sum arrays safely
// @param sumArr Single-element array holding running sum
f_reset_sum1(sumArr) =>
    if array.size(sumArr) == 0
        array.push(sumArr, 0.0)
    else
        array.set(sumArr, 0, 0.0)

f_bucket(p, B) =>
    // p in [0,1], B buckets
    b = int(math.floor(p * B))
    b < 0 ? 0 : b > (B - 1) ? (B - 1) : b

f_cal_roll_update(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, p, y, maxLen) =>
    B = array.size(calCnt)
    bi = f_bucket(p, B)

    // push
    array.push(bBuf, bi)
    array.push(pBuf, p)
    array.push(yBuf, y)

    // increment bucket accumulators
    array.set(calCnt,  bi, array.get(calCnt,  bi) + 1)
    array.set(calSumP, bi, array.get(calSumP, bi) + p)
    array.set(calSumY, bi, array.get(calSumY, bi) + y)

    // enforce rolling length
    if array.size(bBuf) > maxLen
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_cal_roll_update3(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, pU, pF, pD, outcome, maxLen) =>
    B = evalBuckets
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0

    biU = f_bucket(pU, B)
    biF = f_bucket(pF, B)
    biD = f_bucket(pD, B)

    idxU = 0 * B + biU
    idxF = 1 * B + biF
    idxD = 2 * B + biD

    array.push(bBuf, idxU), array.push(pBuf, pU), array.push(yBuf, yU)
    array.push(bBuf, idxF), array.push(pBuf, pF), array.push(yBuf, yF)
    array.push(bBuf, idxD), array.push(pBuf, pD), array.push(yBuf, yD)

    array.set(calCnt,  idxU, array.get(calCnt,  idxU) + 1)
    array.set(calSumP, idxU, array.get(calSumP, idxU) + pU)
    array.set(calSumY, idxU, array.get(calSumY, idxU) + yU)

    array.set(calCnt,  idxF, array.get(calCnt,  idxF) + 1)
    array.set(calSumP, idxF, array.get(calSumP, idxF) + pF)
    array.set(calSumY, idxF, array.get(calSumY, idxF) + yF)

    array.set(calCnt,  idxD, array.get(calCnt,  idxD) + 1)
    array.set(calSumP, idxD, array.get(calSumP, idxD) + pD)
    array.set(calSumY, idxD, array.get(calSumY, idxD) + yD)

    maxLen3 = maxLen * 3
    while array.size(bBuf) > maxLen3
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_eval_stats_one(brierBuf, sumBrier, logBuf, sumLog, ySBuf, sumYS, yLBuf, sumYL, calCnt, calSumP, calSumY) =>
    nScore = array.size(brierBuf)
    brierAvg = nScore == 0 ? na : array.get(sumBrier, 0) / nScore
    logAvg   = nScore == 0 ? na : array.get(sumLog,   0) / nScore

    nS = array.size(ySBuf)
    nL = array.size(yLBuf)
    wS = nS == 0 ? na : array.get(sumYS, 0) / nS
    wL = nL == 0 ? na : array.get(sumYL, 0) / nL
    drift = (na(wS) or na(wL)) ? na : (wS - wL)

    // ECE from rolling buckets (binary or multiclass)
    ece = float(na)
    maxErr = float(na)
    B = evalBuckets
    sizeCnt = array.size(calCnt)
    if sizeCnt == B
        tot = 0
        for i = 0 to sizeCnt - 1
            tot += array.get(calCnt, i)
        if tot > 0
            e = 0.0
            m = 0.0
            for i = 0 to sizeCnt - 1
                c = array.get(calCnt, i)
                if c > 0
                    ap = array.get(calSumP, i) / c
                    ay = array.get(calSumY, i) / c
                    err = math.abs(ap - ay)
                    e += err * (c / tot)
                    m := math.max(m, err)
            ece := e
            maxErr := m
    else if sizeCnt == B * 3
        eTot = 0.0
        mTot = 0.0
        for cls = 0 to 2
            totC = 0
            for i = 0 to B - 1
                totC += array.get(calCnt, cls * B + i)
            if totC > 0
                eC = 0.0
                mC = 0.0
                for i = 0 to B - 1
                    idx = cls * B + i
                    c = array.get(calCnt, idx)
                    if c > 0
                        ap = array.get(calSumP, idx) / c
                        ay = array.get(calSumY, idx) / c
                        err = math.abs(ap - ay)
                        eC += err * (c / totC)
                        mC := math.max(mC, err)
                eTot += eC
                mTot := math.max(mTot, mC)
        ece := eTot / 3.0
        maxErr := mTot

    [brierAvg, logAvg, ece, maxErr, wS, wL, drift, nScore]

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_min_sec(a, b) =>
    na(a) ? b : na(b) ? a : math.min(a, b)

f_forecast_allowed() =>
    baseSec = timeframe.in_seconds(timeframe.period)
    s1 = timeframe.in_seconds(tfF1)
    s2 = timeframe.in_seconds(tfF2)
    s3 = timeframe.in_seconds(tfF3)
    s4 = timeframe.in_seconds(tfF4)
    s5 = timeframe.in_seconds(tfF5)
    s6 = timeframe.in_seconds(tfF6)
    s7 = timeframe.in_seconds(tfF7)
    minSec = f_min_sec(s1, f_min_sec(s2, f_min_sec(s3, f_min_sec(s4, f_min_sec(s5, f_min_sec(s6, s7))))))
    if na(baseSec) or na(minSec)
        allowForecastOnNonFixed
    else
        baseSec <= minSec

f_eval_mode_allow() =>
    barstate.isconfirmed and ((evalMode != "LiveOnly") or barstate.isrealtime)

f_tf_from_horizon(h) =>
    if h == "F1"
        tfF1
    else if h == "F2"
        tfF2
    else if h == "F3"
        tfF3
    else if h == "F4"
        tfF4
    else if h == "F5"
        tfF5
    else if h == "F6"
        tfF6
    else
        tfF7

// D1 â€“ Continuous trend strength [-1, 1] (smooth alternative to discrete f_trend_regime)
f_trend_strength(emaF, emaS) =>
    emaDiff = (emaF - emaS) / math.max(nz(emaS, 1), PRICE_EPS)
    math.max(-1.0, math.min(1.0, emaDiff / math.max(SIDEWAYS_EMA_THRESH, PRICE_EPS)))

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    // B1 â€“ Continuous trend: smooth EMA gap vs binary
    trend = useSmoothTrend ? f_trend_strength(emaF_tf, emaS_tf) : (emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0)
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

f_apply_tp_sl_preset(baseTp, baseSl) =>
    tpEff = tpPreset30m == "Manual" ? baseTp : tpPreset30m == "Conservative" ? 2.5 : tpPreset30m == "Balanced" ? 3.0 : tpPreset30m == "Runner" ? 3.8 : 4.4
    slEff = tpPreset30m == "Manual" ? baseSl : tpPreset30m == "Conservative" ? 1.1 : tpPreset30m == "Balanced" ? 1.0 : tpPreset30m == "Runner" ? 0.85 : 0.75
    [tpEff, slEff]

f_dyn_sl_preset_vals(baseStop, baseTrail) =>
    // Dynamic SL presets now apply across all timeframes.
    dStop = dynSlPreset30m == "Manual" ? baseStop : dynSlPreset30m == "Conservative" ? 1.00 : dynSlPreset30m == "Balanced" ? 0.90 : dynSlPreset30m == "Runner" ? 0.75 : 0.65
    dTrail = dynSlPreset30m == "Manual" ? baseTrail : dynSlPreset30m == "Conservative" ? 2.30 : dynSlPreset30m == "Balanced" ? 2.00 : dynSlPreset30m == "Runner" ? 1.70 : 1.40
    [dStop, dTrail]

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = (not na(sec)) and sec <= SEC_5M // <= 5m
    isMid  = (not na(sec)) and sec <= SEC_1H // <= 1h
    baseTp = isFast ? tpATRF : isMid ? tpATRM : tpATRS
    baseSl = isFast ? slATRF : isMid ? slATRM : slATRS
    [tpEff, slEff] = f_apply_tp_sl_preset(baseTp, baseSl)
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     tpEff,
     slEff]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    // Clamp output to prevent extreme values
    math.max(-LOGIT_CLAMP, math.min(LOGIT_CLAMP, math.log(pc / (1.0 - pc))))

f_sigmoid(x) =>
    // Prevent overflow for extreme x values
    x < -500 ? 0.0 : x > 500 ? 1.0 : 1.0 / (1.0 + math.exp(-x))

f_platt_prob(pRaw, a, b) =>
    f_sigmoid(a * f_logit(pRaw) + b)

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Bias -1 (Bear): mirror logic
    bias == 1 ? (c > ef ? 0.5 : c > es ? 1.0 : -1.0) : bias == -1 ? (c < ef ? 0.5 : c < es ? 1.0 : -1.0) : 0.0

f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / math.max(nz(emaS, 1), PRICE_EPS)
    isSideways = math.abs(emaDiff) < SIDEWAYS_EMA_THRESH and atrNorm < SIDEWAYS_ATR_THRESH
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// B2 â€“ ROC (Rate of Change) score: momentum via price change [-1, 1]
f_roc_score(c, rocL) =>
    roc = ta.roc(c, rocL)
    r = na(roc) ? 0.0 : roc
    // Normalise: Â±5% => Â±1
    math.max(-1.0, math.min(1.0, r / 5.0))

// B4 â€“ Volume score: above/below SMA [-1, 1]
f_vol_score(vol, volSmaLen) =>
    sma = ta.sma(vol, volSmaLen)
    if na(vol) or vol == 0
        0.0
    else
        ratio = na(sma) or sma == 0.0 ? 0.0 : (vol / sma - 1.0)
        math.max(-1.0, math.min(1.0, ratio))


f_tf_pack(tf) =>
    [t, c, h, l, ef, es, r, a, vr] = request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(ta.atr(atrLen) / math.max(close, PRICE_EPS), volRankLen)],
        barmerge.gaps_off,
        barmerge.lookahead_off
    )
    // NOTE: barstate.isconfirmed moved outside request.security() to avoid
    //       TradingView repainting warning that blocks alert creation.
    // Patch A: Return clear HTF data (without forced LTF confirmation boolean)
    [t, c, h, l, ef, es, r, a, vr]

f_score_tf(c, ef, es, r) =>
    f_state_score(c, ef, es, r)

// Phase 2: 2D Binning (Score + Regime)
f_bin2D(score, trendScore, binsA, binsB, cutsArr) =>
    bA = f_bin_quantile(score, cutsArr, binsA)
    bB = f_regime_bin(trendScore)
    idx = int(bA * binsB + bB)
    maxIdx = binsA * binsB - 1
    idx < 0 ? 0 : idx > maxIdx ? maxIdx : idx

f_db_mult(tf) =>
    sec = timeframe.in_seconds(tf)
    na(sec) ? deadbandSlow : sec <= SEC_5M ? deadbandFast : sec <= SEC_1H ? deadbandMid : deadbandSlow

f_outcome3(delta, db) =>
    delta > db ? 1 : delta < -db ? -1 : 0

f_bias_from_score(score) =>
    score > 0 ? 1 : score < 0 ? -1 : 0

f_is_bull_bias(score, emaF_tf, emaS_tf) =>
    b = f_bias_from_score(score)
    b == 0 ? (emaF_tf >= emaS_tf) : b == 1

f_decay_counts(cntArr, upArr, dnArr, decay) =>
    if decay < 0.9999
        for i = 0 to array.size(cntArr) - 1
            array.set(cntArr, i, array.get(cntArr, i) * decay)
            array.set(upArr,  i, array.get(upArr,  i) * decay)
            array.set(dnArr,  i, array.get(dnArr,  i) * decay)

f_cal_update3(cntArr, upArr, dnArr, bin, outcome) =>
    if na(bin) or array.size(cntArr) == 0
        na
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
        n0 = array.get(cntArr, b)
        u0 = array.get(upArr,  b)
        d0 = array.get(dnArr,  b)
        array.set(cntArr, b, n0 + 1.0)
        array.set(upArr,  b, u0 + (outcome == 1 ? 1.0 : 0.0))
        array.set(dnArr,  b, d0 + (outcome == -1 ? 1.0 : 0.0))

f_prob3(u, f, d, n, alpha) =>
    denom = n + 3.0 * alpha
    if denom == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [(u + alpha) / denom, (f + alpha) / denom, (d + alpha) / denom]

f_cal_cur3(cntArr, upArr, dnArr, bin, alpha, shrinkK, shrinkReg) =>
    if na(bin) or array.size(cntArr) == 0
        [float(na), float(na), float(na), float(na)]
    else
        b = int(bin)
        maxIdx = array.size(cntArr) - 1
        b := b < 0 ? 0 : b > maxIdx ? maxIdx : b

        n = array.get(cntArr, b)
        u = array.get(upArr,  b)
        d = array.get(dnArr,  b)
        f = math.max(0, n - u - d)

        [pUb_t, pFb_t, pDb_t] = f_prob3(u, f, d, n, alpha)
        pUb = pUb_t
        pFb = pFb_t
        pDb = pDb_t

        regBin = b % dim2Bins
        binsScore = int(array.size(cntArr) / dim2Bins)
        nReg = 0.0
        uReg = 0.0
        dReg = 0.0
        for i = 0 to binsScore - 1
            idx = i * dim2Bins + regBin
            nReg += array.get(cntArr, idx)
            uReg += array.get(upArr,  idx)
            dReg += array.get(dnArr,  idx)
        fReg = math.max(0, nReg - uReg - dReg)
        [pUr_t, pFr_t, pDr_t] = f_prob3(uReg, fReg, dReg, nReg, alpha)
        pUr = pUr_t
        pFr = pFr_t
        pDr = pDr_t

        nBase = array.sum(cntArr)
        uBase = array.sum(upArr)
        dBase = array.sum(dnArr)
        fBase = math.max(0, nBase - uBase - dBase)
        [pU0_t, pF0_t, pD0_t] = f_prob3(uBase, fBase, dBase, nBase, alpha)
        pU0 = pU0_t
        pF0 = pF0_t
        pD0 = pD0_t

        wReg = (shrinkReg <= 0) ? 1.0 : (n / (n + shrinkReg + 0.0))
        pUreg = wReg * pUb + (1.0 - wReg) * pUr
        pFreg = wReg * pFb + (1.0 - wReg) * pFr
        pDreg = wReg * pDb + (1.0 - wReg) * pDr

        w = (shrinkK <= 0) ? 1.0 : (nReg / (nReg + shrinkK + 0.0))
        pU = w * pUreg + (1.0 - w) * pU0
        pF = w * pFreg + (1.0 - w) * pF0
        pD = w * pDreg + (1.0 - w) * pD0

        s = pU + pF + pD
        if s == 0.0
            [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, n]
        else
            [pU / s, pF / s, pD / s, n]

f_safe_log(p) =>
    math.log(math.max(PROB_EPS, p))

f_softmax3(zU, zF, zD) =>
    zMax = math.max(zU, math.max(zF, zD))
    eU = math.exp(zU - zMax)
    eF = math.exp(zF - zMax)
    eD = math.exp(zD - zMax)
    s = eU + eF + eD
    if s == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [eU / s, eF / s, eD / s]

f_can_cal3(nBin) =>
    calibratorMode != "Off" and (not cal3AutoFallback or nBin >= cal3MinSamples)

f_cal_apply(zU, zF, zD, tempArr, aArr, bArr) =>
    zUo = zU
    zFo = zF
    zDo = zD
    if calibratorMode == "Temp"
        t = array.get(tempArr, 0)
        t := t <= 0.0 ? 1.0 : t
        zUo := zU / t
        zFo := zF / t
        zDo := zD / t
    else if calibratorMode == "Vector"
        aU = array.get(aArr, 0)
        aF = array.get(aArr, 1)
        aD = array.get(aArr, 2)
        bU = array.get(bArr, 0)
        bF = array.get(bArr, 1)
        bD = array.get(bArr, 2)
        zUo := aU * zU + bU
        zFo := aF * zF + bF
        zDo := aD * zD + bD
    f_softmax3(zUo, zFo, zDo)

f_brier3(pU, pF, pD, outcome) =>
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0
    ((pU - yU) * (pU - yU) + (pF - yF) * (pF - yF) + (pD - yD) * (pD - yD)) / 3.0

f_logloss3(pU, pF, pD, outcome) =>
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD
    -math.log(f_epsClamp(pTrue))

f_prior3(tf, outScore) =>
    sec = timeframe.in_seconds(tf)
    isFast = (not na(sec)) and sec <= SEC_5M
    isMid  = (not na(sec)) and sec <= SEC_1H
    baseFlat = isFast ? flatPriorFast : isMid ? flatPriorMid : flatPriorSlow
    tiltMax  = isFast ? tiltMaxFast  : isMid ? tiltMaxMid  : tiltMaxSlow

    baseSide = (1.0 - baseFlat) * 0.5
    tilt = f_clamp(outScore, -1.0, 1.0) * tiltMax

    pU = f_clamp(baseSide + tilt, 0.0, 1.0)
    pD = f_clamp(baseSide - tilt, 0.0, 1.0)
    pF = f_clamp(baseFlat, 0.0, 1.0)

    s = pU + pF + pD
    if s == 0.0
        [1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0]
    else
        [pU / s, pF / s, pD / s]

f_blend_prior(pU, pF, pD, pUpr, pFpr, pDpr, nRaw) =>
    eff = na(nRaw) ? 0.0 : nRaw
    w = calMinSamples <= 0 ? 1.0 : math.min(1.0, math.max(0.0, eff / calMinSamples))
    [pU * w + pUpr * (1.0 - w),
     pF * w + pFpr * (1.0 - w),
     pD * w + pDpr * (1.0 - w)]

f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Clamp bin to valid range (defensive, mirrors f_cal_update)
    b = int(bin)
    maxIdx = array.size(cntArr) - 1
    b := b < 0 ? 0 : b > maxIdx ? maxIdx : b
    // Bin raw
    n = array.get(cntArr, b)
    u = array.get(upArr,  b)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_eval_update_one(p, y,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: section visible/background + confirmed bar + mode gate.
    evalAllow = f_eval_mode_allow()
    canEval = (showEvalSection or evalInBackground) and evalAllow
    if canEval
        pc = f_epsClamp(p)

        // rolling scores
        f_roll_add(brierBuf, sumBrier, f_brier(pc, y), evalRollScore)
        f_roll_add(logBuf,   sumLog,   f_logloss(pc, y), evalRollScore)

        // rolling win rates
        f_roll_add(ySBuf, sumYS, y, evalRollShort)
        f_roll_add(yLBuf, sumYL, y, evalRollLong)

        // rolling calibration buckets (ECE)
        f_cal_roll_update(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pc, y, evalRollScore)

f_eval_update_one3(pU, pF, pD, outcome,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: section visible/background + confirmed bar + mode gate.
    evalAllow = f_eval_mode_allow()
    canEval = (showEvalSection or evalInBackground) and evalAllow
    if canEval
        b3 = f_brier3(pU, pF, pD, outcome)
        ll = f_logloss3(pU, pF, pD, outcome)
        yUp = outcome == 1 ? 1.0 : 0.0
        pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD

        f_roll_add(brierBuf, sumBrier, b3, evalRollScore)
        f_roll_add(logBuf,   sumLog,   ll, evalRollScore)

        f_roll_add(ySBuf, sumYS, yUp, evalRollShort)
        f_roll_add(yLBuf, sumYL, yUp, evalRollLong)

        f_cal_roll_update3(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pU, pF, pD, outcome, evalRollScore)

f_eval_on_resolve(TfState st, pN, p1, isUpBool) =>
    y = isUpBool ? 1.0 : 0.0

    f_eval_update_one(pN, y, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
    f_eval_update_one(p1, y, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0.0), array.fill(st.upN, 0.0), array.fill(st.dnN, 0.0)
    array.fill(st.cnt1, 0.0), array.fill(st.up1, 0.0), array.fill(st.dn1, 0.0)
    array.fill(st.cntN_bull, 0.0), array.fill(st.upN_bull, 0.0), array.fill(st.dnN_bull, 0.0)
    array.fill(st.cntN_bear, 0.0), array.fill(st.upN_bear, 0.0), array.fill(st.dnN_bear, 0.0)
    array.fill(st.cnt1_bull, 0.0), array.fill(st.up1_bull, 0.0), array.fill(st.dn1_bull, 0.0)
    array.fill(st.cnt1_bear, 0.0), array.fill(st.up1_bear, 0.0), array.fill(st.dn1_bear, 0.0)
    array.fill(st.cntN_raw, 0.0), array.fill(st.upN_raw, 0.0), array.fill(st.dnN_raw, 0.0)
    array.fill(st.cnt1_raw, 0.0), array.fill(st.up1_raw, 0.0), array.fill(st.dn1_raw, 0.0)
    array.fill(st.cntN_bull_raw, 0.0), array.fill(st.upN_bull_raw, 0.0), array.fill(st.dnN_bull_raw, 0.0)
    array.fill(st.cntN_bear_raw, 0.0), array.fill(st.upN_bear_raw, 0.0), array.fill(st.dnN_bear_raw, 0.0)
    array.fill(st.cnt1_bull_raw, 0.0), array.fill(st.up1_bull_raw, 0.0), array.fill(st.dn1_bull_raw, 0.0)
    array.fill(st.cnt1_bear_raw, 0.0), array.fill(st.up1_bear_raw, 0.0), array.fill(st.dn1_bear_raw, 0.0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    array.clear(st.qBias)
    array.clear(st.qUseForecast)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    array.clear(st.qPUpN)
    array.clear(st.qPFlN)
    array.clear(st.qPDnN)
    array.clear(st.qPUp1)
    array.clear(st.qPFl1)
    array.clear(st.qPDn1)
    array.clear(st.qZUpN)
    array.clear(st.qZFlN)
    array.clear(st.qZDnN)
    array.clear(st.qZUp1)
    array.clear(st.qZFl1)
    array.clear(st.qZDn1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)
    array.set(st.tempN, 0, 1.0)
    array.set(st.temp1, 0, 1.0)
    array.set(st.vecAN, 0, 1.0)
    array.set(st.vecAN, 1, 1.0)
    array.set(st.vecAN, 2, 1.0)
    array.set(st.vecBN, 0, 0.0)
    array.set(st.vecBN, 1, 0.0)
    array.set(st.vecBN, 2, 0.0)
    array.set(st.vecA1, 0, 1.0)
    array.set(st.vecA1, 1, 1.0)
    array.set(st.vecA1, 2, 1.0)
    array.set(st.vecB1, 0, 0.0)
    array.set(st.vecB1, 1, 0.0)
    array.set(st.vecB1, 2, 0.0)

    array.set(st.tempN_bull, 0, 1.0)
    array.set(st.temp1_bull, 0, 1.0)
    array.set(st.vecAN_bull, 0, 1.0)
    array.set(st.vecAN_bull, 1, 1.0)
    array.set(st.vecAN_bull, 2, 1.0)
    array.set(st.vecBN_bull, 0, 0.0)
    array.set(st.vecBN_bull, 1, 0.0)
    array.set(st.vecBN_bull, 2, 0.0)
    array.set(st.vecA1_bull, 0, 1.0)
    array.set(st.vecA1_bull, 1, 1.0)
    array.set(st.vecA1_bull, 2, 1.0)
    array.set(st.vecB1_bull, 0, 0.0)
    array.set(st.vecB1_bull, 1, 0.0)
    array.set(st.vecB1_bull, 2, 0.0)

    array.set(st.tempN_bear, 0, 1.0)
    array.set(st.temp1_bear, 0, 1.0)
    array.set(st.vecAN_bear, 0, 1.0)
    array.set(st.vecAN_bear, 1, 1.0)
    array.set(st.vecAN_bear, 2, 1.0)
    array.set(st.vecBN_bear, 0, 0.0)
    array.set(st.vecBN_bear, 1, 0.0)
    array.set(st.vecBN_bear, 2, 0.0)
    array.set(st.vecA1_bear, 0, 1.0)
    array.set(st.vecA1_bear, 1, 1.0)
    array.set(st.vecA1_bear, 2, 1.0)
    array.set(st.vecB1_bear, 0, 0.0)
    array.set(st.vecB1_bear, 1, 0.0)
    array.set(st.vecB1_bear, 2, 0.0)

    array.clear(st.qScoreBuf)
    array.fill(st.qCutsN, na)
    array.fill(st.qCuts1, na)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN)
    f_reset_sum1(st.evSumBrierN)
    array.clear(st.evLogN)
    f_reset_sum1(st.evSumLogN)
    array.clear(st.evYS_N)
    f_reset_sum1(st.evSumYS_N)
    array.clear(st.evYL_N)
    f_reset_sum1(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1)
    f_reset_sum1(st.evSumBrier1)
    array.clear(st.evLog1)
    f_reset_sum1(st.evSumLog1)
    array.clear(st.evYS_1)
    f_reset_sum1(st.evSumYS_1)
    array.clear(st.evYL_1)
    f_reset_sum1(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)
    // Baseline comparators
    array.clear(st.evBrierBaseU_N), f_reset_sum1(st.evSumBrierBaseU_N)
    array.clear(st.evLogBaseU_N),   f_reset_sum1(st.evSumLogBaseU_N)
    array.clear(st.evBrierBaseU_1), f_reset_sum1(st.evSumBrierBaseU_1)
    array.clear(st.evLogBaseU_1),   f_reset_sum1(st.evSumLogBaseU_1)
    array.clear(st.evBrierBaseP_N), f_reset_sum1(st.evSumBrierBaseP_N)
    array.clear(st.evLogBaseP_N),   f_reset_sum1(st.evSumLogBaseP_N)
    array.clear(st.evBrierBaseP_1), f_reset_sum1(st.evSumBrierBaseP_1)
    array.clear(st.evLogBaseP_1),   f_reset_sum1(st.evSumLogBaseP_1)
    array.fill(st.priorCounts3, 0.0)
    // Eligible population
    array.clear(st.evBrierN_Elig), f_reset_sum1(st.evSumBrierN_Elig)
    array.clear(st.evLogN_Elig),   f_reset_sum1(st.evSumLogN_Elig)
    array.clear(st.evBrier1_Elig), f_reset_sum1(st.evSumBrier1_Elig)
    array.clear(st.evLog1_Elig),   f_reset_sum1(st.evSumLog1_Elig)
    array.clear(st.evBrierBaseU_N_Elig), f_reset_sum1(st.evSumBrierBaseU_N_Elig)
    array.clear(st.evLogBaseU_N_Elig),   f_reset_sum1(st.evSumLogBaseU_N_Elig)
    array.clear(st.evBrierBaseP_N_Elig), f_reset_sum1(st.evSumBrierBaseP_N_Elig)
    array.clear(st.evLogBaseP_N_Elig),   f_reset_sum1(st.evSumLogBaseP_N_Elig)
    array.fill(st.priorCounts3_Elig, 0.0)
    // Coverage & skip diagnostics
    st.enqCount := 0, st.resolvedScored := 0
    st.enqCountElig := 0, st.resolvedScoredElig := 0
    st.skipBias0 := 0, st.skipAtrInvalid := 0, st.skipIgnore := 0, st.skipTieNeutral2Way := 0, st.skipTotalElig := 0
    st.skipBias0Elig := 0, st.skipAtrInvalidElig := 0, st.skipIgnoreElig := 0, st.skipTieNeutral2WayElig := 0
    array.clear(st.ageAtResolve), f_reset_sum1(st.sumAgeResolve)
    st.prevQDepth := na

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// A5 â€“ ECE-triggered recalibration: boost Platt LR when model is poorly calibrated
var float prevEvalEce = na
lrPlattEff = lrPlatt
if useEceRecal and not na(prevEvalEce) and prevEvalEce >= eceWarn
    lrPlattEff := math.min(lrPlatt * eceRecalBoost, 0.05)

f_process_tf(_hid, _tf, tfBarConfirmed, sA, 
             cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
             TfState st,
             fcTgt, kB, aThr, pH, tpA, slA,
             alphaNVal, alpha1Val, shrinkKVal, wAVal, wBVal, wCVal, wDVal) =>

    if tfBarConfirmed
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = f_safe_get_int(st.qAge,   i, 0)
            entry_i = f_safe_get_float(st.qEntry, i, na)
            atr_i   = f_safe_get_float(st.qAtr,   i, na)
            mh_i    = f_safe_get_float(st.qMaxH,  i, na)
            ml_i    = f_safe_get_float(st.qMinL,  i, na)
            bN_i    = f_safe_get_int(st.qBinN,  i, 0)
            b1_i    = f_safe_get_int(st.qBin1,  i, 0)
            bias_i  = f_safe_get_int(st.qBias,  i, 0)
            useFc_i = f_safe_get_bool(st.qUseForecast, i, false)

            // Stored at entry
            float probN_i = na
            float prob1_i = na
            float lgtN_i = na
            float lgt1_i = na
            float pPredN_i = na
            float pPred1_i = na
            if not use3Way
                probN_i := f_safe_get_float(st.qProbN,  i, na)
                prob1_i := f_safe_get_float(st.qProb1,  i, na)
                lgtN_i  := f_safe_get_float(st.qLogitN, i, na)
                lgt1_i  := f_safe_get_float(st.qLogit1, i, na)
                pPredN_i := f_safe_get_float(st.qPredN, i, na)
                pPred1_i := f_safe_get_float(st.qPred1, i, na)

            // 3-way stored probs/logits
            float pUpN_i = na
            float pFlN_i = na
            float pDnN_i = na
            float pUp1_i = na
            float pFl1_i = na
            float pDn1_i = na
            float zUpN_i = na
            float zFlN_i = na
            float zDnN_i = na
            float zUp1_i = na
            float zFl1_i = na
            float zDn1_i = na
            if use3Way
                pUpN_i := f_safe_get_float(st.qPUpN, i, na)
                pFlN_i := f_safe_get_float(st.qPFlN, i, na)
                pDnN_i := f_safe_get_float(st.qPDnN, i, na)
                pUp1_i := f_safe_get_float(st.qPUp1, i, na)
                pFl1_i := f_safe_get_float(st.qPFl1, i, na)
                pDn1_i := f_safe_get_float(st.qPDn1, i, na)
                zUpN_i := f_safe_get_float(st.qZUpN, i, na)
                zFlN_i := f_safe_get_float(st.qZFlN, i, na)
                zDnN_i := f_safe_get_float(st.qZDnN, i, na)
                zUp1_i := f_safe_get_float(st.qZUp1, i, na)
                zFl1_i := f_safe_get_float(st.qZFl1, i, na)
                zDn1_i := f_safe_get_float(st.qZDn1, i, na)

            resolved = false
            doUpdate = false
            isUp     = false
            int outcome = 0
            int skipReason = 0  // 0=none, 1=bias0, 2=atrInvalid, 3=ignore, 4=tieNeutral2way

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                        skipReason := 2
                    else
                        doUpdate := true
                        if use3Way
                            db = f_db_mult(_tf) * atr_i
                            delta = cNow - entry_i
                            outcome := f_outcome3(delta, db)
                            isUp := outcome == 1
                        else
                            retATR = (cNow - entry_i) / atr_i
                            isUp := retATR >= aThr
                            outcome := isUp ? 1 : -1

            else // PathTPvsSL (directional by stored bias)
                if bias_i == 0
                    if age_i >= pH
                        resolved := true
                        doUpdate := false
                        skipReason := 1
                else if na(atr_i) or atr_i <= 0.0
                    if age_i >= pH
                        resolved := true
                        doUpdate := false
                        skipReason := 2
                else
                    dir = bias_i > 0 ? 1 : -1
                    tpPx = dir == 1 ? (entry_i + tpA * atr_i) : (entry_i - tpA * atr_i)
                    slPx = dir == 1 ? (entry_i - slA * atr_i) : (entry_i + slA * atr_i)
                    winHit  = dir == 1 ? (mh_i >= tpPx) : (ml_i <= tpPx)
                    lossHit = dir == 1 ? (ml_i <= slPx) : (mh_i >= slPx)

                    if winHit or lossHit
                        resolved := true
                        doUpdate := true
                        if winHit and lossHit
                            if pathTiePolicy == "Win"
                                outcome := dir
                            else if pathTiePolicy == "Neutral"
                                if use3Way
                                    outcome := 0
                                else
                                    doUpdate := false
                                    skipReason := 4
                            else
                                outcome := -dir
                            isUp := outcome == 1
                        else
                            outcome := winHit ? dir : -dir
                            isUp := outcome == 1

                    else if age_i >= pH
                        resolved := true
                        if noHitPolicy == "Loss"
                            doUpdate := true
                            outcome := -dir
                            isUp := outcome == 1
                        else if use3Way and noHitPolicy == "Neutral"
                            doUpdate := true
                            outcome := 0
                        else
                            doUpdate := false
                            skipReason := 3

            if resolved
                if doUpdate
                    // Coverage: count scorable resolve + age
                    st.resolvedScored += 1
                    f_roll_add(st.ageAtResolve, st.sumAgeResolve, age_i, evalRollScore)
                    if useFc_i
                        st.resolvedScoredElig += 1
                    if not use3Way
                        outcome := isUp ? 1 : -1
                    if use3Way
                        f_decay_counts(st.cntN, st.upN, st.dnN, countDecay)
                        f_decay_counts(st.cnt1, st.up1, st.dn1, countDecay)
                    f_cal_update3(st.cntN, st.upN, st.dnN, bN_i, outcome)
                    f_cal_update3(st.cnt1, st.up1, st.dn1, b1_i, outcome)
                    f_cal_update3(st.cntN_raw, st.upN_raw, st.dnN_raw, bN_i, outcome)
                    f_cal_update3(st.cnt1_raw, st.up1_raw, st.dn1_raw, b1_i, outcome)

                    if use3Way and useBullBearCal and bias_i != 0
                        useBull = bias_i > 0
                        cntN_sel = useBull ? st.cntN_bull : st.cntN_bear
                        upN_sel  = useBull ? st.upN_bull  : st.upN_bear
                        dnN_sel  = useBull ? st.dnN_bull  : st.dnN_bear
                        cnt1_sel = useBull ? st.cnt1_bull : st.cnt1_bear
                        up1_sel  = useBull ? st.up1_bull  : st.up1_bear
                        dn1_sel  = useBull ? st.dn1_bull  : st.dn1_bear
                        cntN_raw_sel = useBull ? st.cntN_bull_raw : st.cntN_bear_raw
                        upN_raw_sel  = useBull ? st.upN_bull_raw  : st.upN_bear_raw
                        dnN_raw_sel  = useBull ? st.dnN_bull_raw  : st.dnN_bear_raw
                        cnt1_raw_sel = useBull ? st.cnt1_bull_raw : st.cnt1_bear_raw
                        up1_raw_sel  = useBull ? st.up1_bull_raw  : st.up1_bear_raw
                        dn1_raw_sel  = useBull ? st.dn1_bull_raw  : st.dn1_bear_raw
                        f_decay_counts(cntN_sel, upN_sel, dnN_sel, countDecay)
                        f_decay_counts(cnt1_sel, up1_sel, dn1_sel, countDecay)
                        f_cal_update3(cntN_sel, upN_sel, dnN_sel, bN_i, outcome)
                        f_cal_update3(cnt1_sel, up1_sel, dn1_sel, b1_i, outcome)
                        f_cal_update3(cntN_raw_sel, upN_raw_sel, dnN_raw_sel, bN_i, outcome)
                        f_cal_update3(cnt1_raw_sel, up1_raw_sel, dn1_raw_sel, b1_i, outcome)
                    
                    outcomeVal = isUp ? 1.0 : 0.0

                    // evaluation scoring (NEW)
                    if use3Way
                        f_eval_update_one3(pUpN_i, pFlN_i, pDnN_i, outcome, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
                        f_eval_update_one3(pUp1_i, pFl1_i, pDn1_i, outcome, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

                        // --- Baseline scoring (same event population, no leakage) ---
                        evalAllow = f_eval_mode_allow()
                        canEvalBase = (showEvalSection or evalInBackground) and evalAllow
                        if canEvalBase
                            // A) Uniform baseline: 1/3 each class
                            uProb = 1.0 / 3.0
                            uB3 = f_brier3(uProb, uProb, uProb, outcome)
                            uLL  = f_logloss3(uProb, uProb, uProb, outcome)
                            f_roll_add(st.evBrierBaseU_N, st.evSumBrierBaseU_N, uB3, evalRollScore)
                            f_roll_add(st.evLogBaseU_N,   st.evSumLogBaseU_N,   uLL, evalRollScore)
                            f_roll_add(st.evBrierBaseU_1, st.evSumBrierBaseU_1, uB3, evalRollScore)
                            f_roll_add(st.evLogBaseU_1,   st.evSumLogBaseU_1,   uLL, evalRollScore)

                            // B) Prior baseline (Laplace / Dirichlet(1,1,1) smoothing)
                            nUp_pr = array.get(st.priorCounts3, 0)
                            nFl_pr = array.get(st.priorCounts3, 1)
                            nDn_pr = array.get(st.priorCounts3, 2)
                            nTot_pr = nUp_pr + nFl_pr + nDn_pr
                            prU = (nUp_pr + 1.0) / (nTot_pr + 3.0)
                            prF = (nFl_pr + 1.0) / (nTot_pr + 3.0)
                            prD = (nDn_pr + 1.0) / (nTot_pr + 3.0)
                            pB3 = f_brier3(prU, prF, prD, outcome)
                            pLL = f_logloss3(prU, prF, prD, outcome)
                            f_roll_add(st.evBrierBaseP_N, st.evSumBrierBaseP_N, pB3, evalRollScore)
                            f_roll_add(st.evLogBaseP_N,   st.evSumLogBaseP_N,   pLL, evalRollScore)
                            f_roll_add(st.evBrierBaseP_1, st.evSumBrierBaseP_1, pB3, evalRollScore)
                            f_roll_add(st.evLogBaseP_1,   st.evSumLogBaseP_1,   pLL, evalRollScore)

                            // Update prior counts AFTER scoring (no leakage)
                            if outcome == 1
                                array.set(st.priorCounts3, 0, nUp_pr + 1.0)
                            else if outcome == 0
                                array.set(st.priorCounts3, 1, nFl_pr + 1.0)
                            else
                                array.set(st.priorCounts3, 2, nDn_pr + 1.0)

                            // --- Eligible population scoring (Variant B active at enqueue) ---
                            if useFc_i
                                // Model eligible
                                b3_eN = f_brier3(pUpN_i, pFlN_i, pDnN_i, outcome)
                                ll_eN = f_logloss3(pUpN_i, pFlN_i, pDnN_i, outcome)
                                f_roll_add(st.evBrierN_Elig, st.evSumBrierN_Elig, b3_eN, evalRollScore)
                                f_roll_add(st.evLogN_Elig,   st.evSumLogN_Elig,   ll_eN, evalRollScore)
                                b3_e1 = f_brier3(pUp1_i, pFl1_i, pDn1_i, outcome)
                                ll_e1 = f_logloss3(pUp1_i, pFl1_i, pDn1_i, outcome)
                                f_roll_add(st.evBrier1_Elig, st.evSumBrier1_Elig, b3_e1, evalRollScore)
                                f_roll_add(st.evLog1_Elig,   st.evSumLog1_Elig,   ll_e1, evalRollScore)
                                // Uniform baseline eligible
                                f_roll_add(st.evBrierBaseU_N_Elig, st.evSumBrierBaseU_N_Elig, uB3, evalRollScore)
                                f_roll_add(st.evLogBaseU_N_Elig,   st.evSumLogBaseU_N_Elig,   uLL, evalRollScore)
                                // Prior baseline eligible (separate prior counts)
                                neUp = array.get(st.priorCounts3_Elig, 0)
                                neFl = array.get(st.priorCounts3_Elig, 1)
                                neDn = array.get(st.priorCounts3_Elig, 2)
                                neTot = neUp + neFl + neDn
                                peU = (neUp + 1.0) / (neTot + 3.0)
                                peF = (neFl + 1.0) / (neTot + 3.0)
                                peD = (neDn + 1.0) / (neTot + 3.0)
                                peB3 = f_brier3(peU, peF, peD, outcome)
                                peLL = f_logloss3(peU, peF, peD, outcome)
                                f_roll_add(st.evBrierBaseP_N_Elig, st.evSumBrierBaseP_N_Elig, peB3, evalRollScore)
                                f_roll_add(st.evLogBaseP_N_Elig,   st.evSumLogBaseP_N_Elig,   peLL, evalRollScore)
                                // Update eligible prior AFTER scoring (no leakage)
                                if outcome == 1
                                    array.set(st.priorCounts3_Elig, 0, neUp + 1.0)
                                else if outcome == 0
                                    array.set(st.priorCounts3_Elig, 1, neFl + 1.0)
                                else
                                    array.set(st.priorCounts3_Elig, 2, neDn + 1.0)

                    else
                        f_eval_on_resolve(st, pPredN_i, pPred1_i, isUp)

                    if use3Way and calibratorMode != "Off"
                        nBinN_cur = array.get(st.cntN, bN_i)
                        nBin1_cur = array.get(st.cnt1, b1_i)
                        canCalN = not cal3AutoFallback or nBinN_cur >= cal3MinSamples
                        canCal1 = not cal3AutoFallback or nBin1_cur >= cal3MinSamples
                        regW_N = calRegStrength * (cal3MinSamples <= 0 ? 0.0 : math.max(0.0, 1.0 - math.min(1.0, nBinN_cur / cal3MinSamples)))
                        regW_1 = calRegStrength * (cal3MinSamples <= 0 ? 0.0 : math.max(0.0, 1.0 - math.min(1.0, nBin1_cur / cal3MinSamples)))
                        yU = outcome == 1 ? 1.0 : 0.0
                        yF = outcome == 0 ? 1.0 : 0.0
                        yD = outcome == -1 ? 1.0 : 0.0
                        tempN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
                        temp1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
                        vecAN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
                        vecBN_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
                        vecA1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
                        vecB1_sel = (useBullBearCal and bias_i != 0) ? (bias_i > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1

                        if calibratorMode == "Temp"
                            if canCalN
                                tN = array.get(tempN_sel, 0)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(zUpN_i / tN, zFlN_i / tN, zDnN_i / tN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                gradN = ((pUNc - yU) * zUpN_i + (pFNc - yF) * zFlN_i + (pDNc - yD) * zDnN_i) / (tN * tN)
                                tN := f_clamp(tN - lrCal * gradN - regW_N * (tN - 1.0), tempMin, tempMax)
                                array.set(tempN_sel, 0, tN)

                            if canCal1
                                t1 = array.get(temp1_sel, 0)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(zUp1_i / t1, zFl1_i / t1, zDn1_i / t1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                grad1 = ((pU1c - yU) * zUp1_i + (pF1c - yF) * zFl1_i + (pD1c - yD) * zDn1_i) / (t1 * t1)
                                t1 := f_clamp(t1 - lrCal * grad1 - regW_1 * (t1 - 1.0), tempMin, tempMax)
                                array.set(temp1_sel, 0, t1)
                        else if calibratorMode == "Vector"
                            if canCalN
                                aUN = array.get(vecAN_sel, 0)
                                aFN = array.get(vecAN_sel, 1)
                                aDN = array.get(vecAN_sel, 2)
                                bUN = array.get(vecBN_sel, 0)
                                bFN = array.get(vecBN_sel, 1)
                                bDN = array.get(vecBN_sel, 2)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(aUN * zUpN_i + bUN, aFN * zFlN_i + bFN, aDN * zDnN_i + bDN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                aUN := f_clamp(aUN - lrCal * (pUNc - yU) * zUpN_i - regW_N * (aUN - 1.0), vecAMin, vecAMax)
                                aFN := f_clamp(aFN - lrCal * (pFNc - yF) * zFlN_i - regW_N * (aFN - 1.0), vecAMin, vecAMax)
                                aDN := f_clamp(aDN - lrCal * (pDNc - yD) * zDnN_i - regW_N * (aDN - 1.0), vecAMin, vecAMax)
                                bUN := f_clamp(bUN - lrCal * (pUNc - yU) - regW_N * bUN, vecBMin, vecBMax)
                                bFN := f_clamp(bFN - lrCal * (pFNc - yF) - regW_N * bFN, vecBMin, vecBMax)
                                bDN := f_clamp(bDN - lrCal * (pDNc - yD) - regW_N * bDN, vecBMin, vecBMax)
                                array.set(vecAN_sel, 0, aUN)
                                array.set(vecAN_sel, 1, aFN)
                                array.set(vecAN_sel, 2, aDN)
                                array.set(vecBN_sel, 0, bUN)
                                array.set(vecBN_sel, 1, bFN)
                                array.set(vecBN_sel, 2, bDN)

                            if canCal1
                                aU1 = array.get(vecA1_sel, 0)
                                aF1 = array.get(vecA1_sel, 1)
                                aD1 = array.get(vecA1_sel, 2)
                                bU1 = array.get(vecB1_sel, 0)
                                bF1 = array.get(vecB1_sel, 1)
                                bD1 = array.get(vecB1_sel, 2)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(aU1 * zUp1_i + bU1, aF1 * zFl1_i + bF1, aD1 * zDn1_i + bD1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                aU1 := f_clamp(aU1 - lrCal * (pU1c - yU) * zUp1_i - regW_1 * (aU1 - 1.0), vecAMin, vecAMax)
                                aF1 := f_clamp(aF1 - lrCal * (pF1c - yF) * zFl1_i - regW_1 * (aF1 - 1.0), vecAMin, vecAMax)
                                aD1 := f_clamp(aD1 - lrCal * (pD1c - yD) * zDn1_i - regW_1 * (aD1 - 1.0), vecAMin, vecAMax)
                                bU1 := f_clamp(bU1 - lrCal * (pU1c - yU) - regW_1 * bU1, vecBMin, vecBMax)
                                bF1 := f_clamp(bF1 - lrCal * (pF1c - yF) - regW_1 * bF1, vecBMin, vecBMax)
                                bD1 := f_clamp(bD1 - lrCal * (pD1c - yD) - regW_1 * bD1, vecBMin, vecBMax)
                                array.set(vecA1_sel, 0, aU1)
                                array.set(vecA1_sel, 1, aF1)
                                array.set(vecA1_sel, 2, aD1)
                                array.set(vecB1_sel, 0, bU1)
                                array.set(vecB1_sel, 1, bF1)
                                array.set(vecB1_sel, 2, bD1)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    if not use3Way
                        nBinN_cur = array.get(st.cntN, bN_i)
                        if nBinN_cur >= calMinSamples
                            // Brier on raw prob
                            sqErrN = math.pow(outcomeVal - probN_i, 2)
                            curSumN = array.get(st.brierStatsN, 0)
                            curCntN = array.get(st.brierStatsN, 1)
                            array.set(st.brierStatsN, 0, curSumN + sqErrN)
                            array.set(st.brierStatsN, 1, curCntN + 1.0)
                            
                            // Platt SGD
                            if usePlatt
                                aN = array.get(st.plattN, 0)
                                bN = array.get(st.plattN, 1)
                                pAdj = f_sigmoid(aN * lgtN_i + bN)
                                err = pAdj - outcomeVal
                                da = err * lgtN_i
                                db = err
                                // A2 â€“ Momentum: EMA of gradients
                                float effDa = da
                                float effDb = db
                                if useSgdMomentum
                                    mA = sgdBeta * array.get(st.momPlattN, 0) + (1.0 - sgdBeta) * da
                                    mB = sgdBeta * array.get(st.momPlattN, 1) + (1.0 - sgdBeta) * db
                                    array.set(st.momPlattN, 0, mA)
                                    array.set(st.momPlattN, 1, mB)
                                    effDa := mA
                                    effDb := mB
                                // Update
                                aN := math.max(0.1, math.min(5.0, aN - lrPlattEff * effDa)) 
                                bN := math.max(-3.0, math.min(3.0, bN - lrPlattEff * effDb))
                                array.set(st.plattN, 0, aN)
                                array.set(st.plattN, 1, bN)
                                
                                // LogLoss
                                ll = f_logloss(pAdj, outcomeVal)
                                f_update_accum_stats(st.llStatsN, ll)
                        
                        // --- Phase 4: SGD Update & LogLoss (1) ---
                        sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                        curSum1 = array.get(st.brierStats1, 0)
                        curCnt1 = array.get(st.brierStats1, 1)
                        array.set(st.brierStats1, 0, curSum1 + sqErr1)
                        array.set(st.brierStats1, 1, curCnt1 + 1.0)

                        if usePlatt
                            pltA1 = array.get(st.platt1, 0)
                            pltB1 = array.get(st.platt1, 1)
                            pAdj1 = f_sigmoid(pltA1 * lgt1_i + pltB1)
                            err1 = pAdj1 - outcomeVal
                            da1 = err1 * lgt1_i
                            db1 = err1
                            // A2 â€“ Momentum: EMA of gradients (head 1)
                            float effDa1 = da1
                            float effDb1 = db1
                            if useSgdMomentum
                                mA1 = sgdBeta * array.get(st.momPlatt1, 0) + (1.0 - sgdBeta) * da1
                                mB1 = sgdBeta * array.get(st.momPlatt1, 1) + (1.0 - sgdBeta) * db1
                                array.set(st.momPlatt1, 0, mA1)
                                array.set(st.momPlatt1, 1, mB1)
                                effDa1 := mA1
                                effDb1 := mB1
                            pltA1 := math.max(0.1, math.min(5.0, pltA1 - lrPlattEff * effDa1)) 
                            pltB1 := math.max(-3.0, math.min(3.0, pltB1 - lrPlattEff * effDb1))
                            array.set(st.platt1, 0, pltA1)
                            array.set(st.platt1, 1, pltB1)
                            
                            ll1 = f_logloss(pAdj1, outcomeVal)
                            f_update_accum_stats(st.llStats1, ll1)

                else
                    // Skip tracking: resolved but not scorable
                    if skipReason == 1
                        st.skipBias0 += 1
                    else if skipReason == 2
                        st.skipAtrInvalid += 1
                    else if skipReason == 3
                        st.skipIgnore += 1
                    else if skipReason == 4
                        st.skipTieNeutral2Way += 1
                    if useFc_i
                        st.skipTotalElig += 1
                        if skipReason == 1
                            st.skipBias0Elig += 1
                        else if skipReason == 2
                            st.skipAtrInvalidElig += 1
                        else if skipReason == 3
                            st.skipIgnoreElig += 1
                        else if skipReason == 4
                            st.skipTieNeutral2WayElig += 1

                f_safe_remove_int(st.qAge,   i)
                f_safe_remove_float(st.qMaxH,  i)
                f_safe_remove_float(st.qMinL,  i)
                f_safe_remove_float(st.qAtr,   i)
                f_safe_remove_float(st.qEntry, i)
                f_safe_remove_int(st.qBinN,  i)
                f_safe_remove_int(st.qBin1,  i)
                f_safe_remove_int(st.qBias,  i)
                f_safe_remove_bool(st.qUseForecast, i)
                if not use3Way
                    f_safe_remove_float(st.qProbN, i)
                    f_safe_remove_float(st.qProb1, i)
                    f_safe_remove_float(st.qLogitN, i)
                    f_safe_remove_float(st.qLogit1, i)
                    f_safe_remove_float(st.qPredN, i)
                    f_safe_remove_float(st.qPred1, i)
                if use3Way
                    f_safe_remove_float(st.qPUpN, i)
                    f_safe_remove_float(st.qPFlN, i)
                    f_safe_remove_float(st.qPDnN, i)
                    f_safe_remove_float(st.qPUp1, i)
                    f_safe_remove_float(st.qPFl1, i)
                    f_safe_remove_float(st.qPDn1, i)
                    f_safe_remove_float(st.qZUpN, i)
                    f_safe_remove_float(st.qZFlN, i)
                    f_safe_remove_float(st.qZDnN, i)
                    f_safe_remove_float(st.qZUp1, i)
                    f_safe_remove_float(st.qZFl1, i)
                    f_safe_remove_float(st.qZDn1, i)

            i -= 1

        // 3) Push new pending item
        // --- Phase 3: Ensemble Score ---
        bias = emaFNow > emaSNow ? 1 : emaFNow < emaSNow ? -1 : 0
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        // Epsilon PRICE_EPS prevents division by zero on penny stocks or exotic instruments with close near 0
        atrNormEns = atrNow / math.max(cNow, PRICE_EPS)
        sD = f_trend_regime(emaFNow, emaSNow, atrNormEns)
        sEns = f_ensemble4(sA, sB, sC, sD, wAVal, wBVal, wCVal, wDVal)
        if not na(sEns) and not na(sD)
            f_update_quantiles(st, sEns)
            
            // --- Phase 2: 2D Binning ---
            bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, st.qCutsN)
            b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, st.qCuts1)

            dirFlag = f_bias_from_score(sA)
            biasSel = f_bias_from_score(sA)
            if biasSel == 0
                biasSel := bias == 0 ? 1 : bias
            cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
            upN_sel  = useBullBearCal ? (biasSel > 0 ? st.upN_bull  : st.upN_bear)  : st.upN
            dnN_sel  = useBullBearCal ? (biasSel > 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
            cnt1_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
            up1_sel  = useBullBearCal ? (biasSel > 0 ? st.up1_bull  : st.up1_bear)  : st.up1
            dn1_sel  = useBullBearCal ? (biasSel > 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1

            tempN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
            temp1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
            vecAN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
            vecBN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
            vecA1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
            vecB1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1

            if use3Way
                [pUrawN_t, pFrawN_t, pDrawN_t, _nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaNVal, shrinkKVal, kShrinkReg)
                [pUraw1_t, pFraw1_t, pDraw1_t, _n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1Val, shrinkKVal, kShrinkReg)
                pUrawN = pUrawN_t
                pFrawN = pFrawN_t
                pDrawN = pDrawN_t
                _nN = _nN_t
                pUraw1 = pUraw1_t
                pFraw1 = pFraw1_t
                pDraw1 = pDraw1_t
                _n1 = _n1_t

                zUN = f_safe_log(pUrawN)
                zFN = f_safe_log(pFrawN)
                zDN = f_safe_log(pDrawN)
                zU1 = f_safe_log(pUraw1)
                zF1 = f_safe_log(pFraw1)
                zD1 = f_safe_log(pDraw1)

                useCalN = f_can_cal3(_nN)
                useCal1 = f_can_cal3(_n1)
                float pUN = na
                float pFN = na
                float pDN = na
                float pU1 = na
                float pF1 = na
                float pD1 = na
                if useCalN
                    [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, tempN_sel, vecAN_sel, vecBN_sel)
                    pUN := tUN_t
                    pFN := tFN_t
                    pDN := tDN_t
                else
                    pUN := pUrawN
                    pFN := pFrawN
                    pDN := pDrawN
                if useCal1
                    [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, temp1_sel, vecA1_sel, vecB1_sel)
                    pU1 := tU1_t
                    pF1 := tF1_t
                    pD1 := tD1_t
                else
                    pU1 := pUraw1
                    pF1 := pFraw1
                    pD1 := pDraw1

                array.push(st.qBinN,  bN)
                array.push(st.qBin1,  b1)
                array.push(st.qEntry, cNow)
                array.push(st.qAtr,   atrNow)

                array.push(st.qMaxH,  cNow)
                array.push(st.qMinL,  cNow)

                array.push(st.qAge,   0)
                array.push(st.qBias,  dirFlag)
                array.push(st.qUseForecast, enableForecast and f_forecast_allowed())
                st.enqCount += 1
                if enableForecast and f_forecast_allowed()
                    st.enqCountElig += 1

                array.push(st.qPUpN, pUN)
                array.push(st.qPFlN, pFN)
                array.push(st.qPDnN, pDN)
                array.push(st.qPUp1, pU1)
                array.push(st.qPFl1, pF1)
                array.push(st.qPDn1, pD1)

                array.push(st.qZUpN, zUN)
                array.push(st.qZFlN, zFN)
                array.push(st.qZDnN, zDN)
                array.push(st.qZUp1, zU1)
                array.push(st.qZFl1, zF1)
                array.push(st.qZDn1, zD1)
            else
                // Capture current probabilities
                [pNowN_t, _nN_t] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
                [pNow1_t, _n1_t] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)
                pNowN = pNowN_t
                _nN = _nN_t
                pNow1 = pNow1_t
                _n1 = _n1_t

                // Logits (Phase 4)
                lgtN = f_logit(pNowN)
                lgt1 = f_logit(pNow1)

                array.push(st.qBinN,  bN)
                array.push(st.qBin1,  b1)
                array.push(st.qEntry, cNow)
                array.push(st.qAtr,   atrNow)

                array.push(st.qMaxH,  cNow)
                array.push(st.qMinL,  cNow)

                array.push(st.qAge,   0)
                array.push(st.qBias,  dirFlag)
                array.push(st.qUseForecast, enableForecast and f_forecast_allowed())
                st.enqCount += 1
                if enableForecast and f_forecast_allowed()
                    st.enqCountElig += 1

                array.push(st.qProbN, pNowN)
                array.push(st.qProb1, pNow1)
                array.push(st.qLogitN, lgtN)
                array.push(st.qLogit1, lgt1)

                array.push(st.qPredN, pNowN)
                array.push(st.qPred1, pNow1)
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// RFC v6.4 Phase 1 scaffold: derived trend core + regime state (non-invasive)
zlCoreFastRaw = f_zl_trend_core(close, zlTrendLenFast, zlTrendAggressiveness)
zlCoreSlowRaw = f_zl_trend_core(close, zlTrendLenSlow, zlTrendAggressiveness)
zlCoreNoise = math.abs(zlCoreFastRaw - zlCoreSlowRaw) / math.max(close, PRICE_EPS)
zlCoreStable = (not na(zlCoreFastRaw)) and (not na(zlCoreSlowRaw)) and (zlCoreNoise >= (zlTrendNoiseGuard * SIDEWAYS_EMA_THRESH))
useClassicCore = (not useZeroLagTrendCore) or (trendCoreMode == "ClassicEMA")
trendCoreFast = useClassicCore ? emaF : (trendCoreMode == "ZeroLagEMA" ? zlCoreFastRaw : (zlCoreStable ? zlCoreFastRaw : emaF))
trendCoreSlow = useClassicCore ? emaS : (trendCoreMode == "ZeroLagEMA" ? zlCoreSlowRaw : (zlCoreStable ? zlCoreSlowRaw : emaS))
// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ? ((not na(baseSecs) and baseSecs <= SEC_5M) ? rsiLenFastTF : (not na(baseSecs) and baseSecs <= SEC_1H) ? rsiLenMidTF : rsiLenSlowTF) : rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)


usiSrc1 = usiZeroLag ? f_zl_src(close, usiLen1) : close
usiSrc2 = usiZeroLag ? f_zl_src(close, usiLen2) : close
usiSrc3 = usiZeroLag ? f_zl_src(close, usiLen3) : close
usiSrc4 = usiZeroLag ? f_zl_src(close, usiLen4) : close
usiSrc5_base = usiZeroLag ? f_zl_src(close, usiLen5) : close
usiSrc5 = useUsiZeroLagRed ? f_zl_src_pct(usiSrc5_base, usiLen5, usiZlAggressiveness) : usiSrc5_base

usiLine1 = ta.rsi(usiSrc1, usiLen1)
usiLine2 = ta.rsi(usiSrc2, usiLen2)
usiLine3 = ta.rsi(usiSrc3, usiLen3)
usiLine4 = ta.rsi(usiSrc4, usiLen4)
usiLine5 = ta.rsi(usiSrc5, usiLen5)

usiBullStack = (usiLine5 > usiLine4 ? 1 : 0) +
     (usiLine4 > usiLine3 ? 1 : 0) +
     (usiLine3 > usiLine2 ? 1 : 0) +
     (usiLine2 > usiLine1 ? 1 : 0)
usiBearStack = (usiLine1 > usiLine2 ? 1 : 0) +
     (usiLine2 > usiLine3 ? 1 : 0) +
     (usiLine3 > usiLine4 ? 1 : 0) +
     (usiLine4 > usiLine5 ? 1 : 0)
usiStackMax = math.max(usiBullStack, usiBearStack)
usiStackDir = usiBullStack >= usiMinStack ? 1 : usiBearStack >= usiMinStack ? -1 : 0

float usiMaxEnv = na
float usiMinEnv = na

if usiFlipMode == "Tier A: Red vs Blue"
    usiMaxEnv := usiLine1
    usiMinEnv := usiLine1 
else if usiFlipMode == "Tier B: Red vs Avg"
    float _avg = math.avg(usiLine1, usiLine2, usiLine3, usiLine4)
    usiMaxEnv := _avg
    usiMinEnv := _avg
else // "Tier C: Envelope"
    usiMaxEnv := math.max(math.max(usiLine1, usiLine2), math.max(usiLine3, usiLine4))
    usiMinEnv := math.min(math.min(usiLine1, usiLine2), math.min(usiLine3, usiLine4))

usiWasBelowAll = usiLine5[1] <= usiMinEnv[1] + 0.1
usiWasAboveAll = usiLine5[1] >= usiMaxEnv[1] - 0.1

_usiXUp = (usiLine5 >= usiMaxEnv - 0.1) and (usiLine5[1] < usiMaxEnv[1] - 0.1)
_usiXDn = (usiLine5 <= usiMinEnv + 0.1) and (usiLine5[1] > usiMinEnv[1] + 0.1)

usiBuySignal  = usiWasBelowAll and _usiXUp
usiSellSignal = usiWasAboveAll and _usiXDn

usiBullState = usiLine5 > usiMaxEnv
usiBearState = usiLine5 < usiMinEnv

usiClusterHigh = usiMaxEnv
usiClusterLow  = usiMinEnv
usiClusterAvg  = math.avg(usiLine1, usiLine2, usiLine3, usiLine4)
usiSpread      = usiClusterHigh - usiClusterLow

usiSpreadP50   = ta.percentile_linear_interpolation(usiSpread, usiSpreadLookback, 50)
usiTightSpread = (usiSpreadP50 > 0) and (usiSpread < (usiSpreadP50 * usiTightFactor))

usiEmaGate     = ta.ema(close, usiEmaLen)

f_usi_30m_calc_raw() =>
    _c = close
    _e = ta.ema(close, usiEmaLen)

    _s1 = usiZeroLag ? f_zl_src(close, usiLen1) : close
    _s2 = usiZeroLag ? f_zl_src(close, usiLen2) : close
    _s3 = usiZeroLag ? f_zl_src(close, usiLen3) : close
    _s4 = usiZeroLag ? f_zl_src(close, usiLen4) : close
    _s5_base = usiZeroLag ? f_zl_src(close, usiLen5) : close
    _s5 = useUsiZeroLagRed ? f_zl_src_pct(_s5_base, usiLen5, usiZlAggressiveness) : _s5_base
    
    _r1 = ta.rsi(_s1, usiLen1)
    _r2 = ta.rsi(_s2, usiLen2)
    _r3 = ta.rsi(_s3, usiLen3)
    _r4 = ta.rsi(_s4, usiLen4)
    _r5 = ta.rsi(_s5, usiLen5)
    
    _cA = math.avg(_r1, _r2, _r3, _r4)
    [_c, _e, _r5, _cA]

[qCl30_raw, qEma30_raw, qL5_30_raw, qClusterA30_raw] = request.security(syminfo.tickerid, usiTfGate, f_usi_30m_calc_raw(), lookahead = barmerge.lookahead_off)

qCl30       = qCl30_raw[1]
qEma30      = qEma30_raw[1]
qL5_30      = qL5_30_raw[1]
qClusterA30 = qClusterA30_raw[1]

qRegimeBuy  = qCl30 >= qEma30 and qL5_30 >= qClusterA30
qRegimeSell = qCl30 <= qEma30 and qL5_30 <= qClusterA30

qFastSignalBuy  = _usiXUp
qFastSignalSell = _usiXDn

qSigWasBuy  = usiAggressiveSameBarVerify ? qFastSignalBuy : qFastSignalBuy[1]
qSigWasSell = usiAggressiveSameBarVerify ? qFastSignalSell : qFastSignalSell[1]

qGatesValidBuy  = (close > usiEmaGate) and qRegimeBuy
qGatesValidSell = (close < usiEmaGate) and qRegimeSell

vBuy1_Hold_base = usiLine5 > usiClusterAvg
vBuy1_Hold      = hardenHold ? (vBuy1_Hold_base and (usiLine5 > usiLine4)) : vBuy1_Hold_base
vBuy2_Cont  = usiLine5 > usiLine5[1]
vBuy3_Stack = (usiLine5 > usiLine4) and (usiLine4 > usiLine3)

qVerifyVotesMin = usiAggressiveOneOfThree ? 1 : 2
bool qVerifyBuy = false
if usiTightSpread
    if usiAggressiveTightSpreadVotes
        qVerifyBuy := qSigWasBuy and ((vBuy1_Hold?1:0) + (vBuy2_Cont?1:0) + (vBuy3_Stack?1:0) >= qVerifyVotesMin)
    else
        qVerifyBuy := qSigWasBuy and vBuy1_Hold and vBuy2_Cont
else
    qVerifyBuy := qSigWasBuy and ((vBuy1_Hold?1:0) + (vBuy2_Cont?1:0) + (vBuy3_Stack?1:0) >= qVerifyVotesMin)

vSell1_Hold_base = usiLine5 < usiClusterAvg
vSell1_Hold      = hardenHold ? (vSell1_Hold_base and (usiLine5 < usiLine4)) : vSell1_Hold_base
vSell2_Cont  = usiLine5 < usiLine5[1]
vSell3_Stack = (usiLine5 < usiLine4) and (usiLine4 < usiLine3)

bool qVerifySell = false
if usiTightSpread
    if usiAggressiveTightSpreadVotes
        qVerifySell := qSigWasSell and ((vSell1_Hold?1:0) + (vSell2_Cont?1:0) + (vSell3_Stack?1:0) >= qVerifyVotesMin)
    else
        qVerifySell := qSigWasSell and vSell1_Hold and vSell2_Cont
else
    qVerifySell := qSigWasSell and ((vSell1_Hold?1:0) + (vSell2_Cont?1:0) + (vSell3_Stack?1:0) >= qVerifyVotesMin)

qFinalEntryBuy  = useUsi and qVerifyBuy and qGatesValidBuy
qFinalEntrySell = useUsi and qVerifySell and qGatesValidSell

plotshape(qFinalEntryBuy, "QP Buy", shape.triangleup, location.belowbar, color.new(color.aqua, 0), size=size.small, text="QP")
plotshape(qFinalEntrySell, "QP Sell", shape.triangledown, location.abovebar, color.new(color.orange, 0), size=size.small, text="QP")

if qFinalEntryBuy
    alert("USI Quantum Pulse (QP) BUY: " + syminfo.ticker, alert.freq_once_per_bar_close)
if qFinalEntrySell
    alert("USI Quantum Pulse (QP) SELL: " + syminfo.ticker, alert.freq_once_per_bar_close)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

atrRank = f_pct_rank(atr / math.max(close, PRICE_EPS), volRankLen)

atrBaselineReg = atrRegimeBaselineType == "EMA" ? ta.ema(atr, atrRegimeBaselineLen) : ta.sma(atr, atrRegimeBaselineLen)
atrRatioReg = atrBaselineReg > 0 ? atr / atrBaselineReg : 1.0
atrWasRecentlyHigh = ta.highest(atrRatioReg[1], atrExhaustLookback) >= atrHighVolThr
atrDeclining = ta.falling(atr, atrExhaustLookback)
int atrRegime = atrRatioReg < atrCompressionThr ? 1 : atrRatioReg >= atrHighVolThr ? 3 : (atrWasRecentlyHigh and atrDeclining and atrRatioReg < atrHighVolThr) ? 4 : atrRatioReg >= atrExpansionThr ? 2 : 0
atrRegimeName = atrRegime == 1 ? "COMPRESSION" : atrRegime == 2 ? "EXPANSION" : atrRegime == 3 ? "HIGH VOL" : atrRegime == 4 ? "EXHAUSTION" : "NEUTRAL"
atrRegimeBg = atrRegime == 1 ? color.new(color.lime, 88) : atrRegime == 2 ? color.new(color.orange, 88) : atrRegime == 3 ? color.new(color.red, 88) : atrRegime == 4 ? color.new(color.purple, 88) : na
atrPercentile = enableAtrPercentile ? (f_pct_rank(atr, atrPercentileLookback) * 100.0) : na

prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? nz(volRankRaw, 0.5) : 0.5

macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScoreDir = macroGateMode == "Off" ? 0.5 : emaF > emaS ? (1.0 - macroPct) : emaF < emaS ? macroPct : 0.5
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSevereSafe = math.max(ddSevere, ddMild + PRICE_EPS)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevereSafe - ddMild, PRICE_EPS))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    trendOk = dir == 1 ? (emaF > emaS and close > emaS) : (emaF < emaS and close < emaS)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier = config == "Standard" ? 1.00 : config == "Pro" ? 1.05 : config == "V2 Essential" ? 0.95 : config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScoreDir, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

sessOpen       = timestamp(syminfo.timezone, year, month, dayofmonth, rthOpenHour, rthOpenMinute)
minsFromOpen   = (time - sessOpen) / 60000.0
openWindowEngineOk = revOpenWindowEngine == "All" or revOpenWindowEngine == engine
inRevOpenWindowLong = useRevOpenWindow and openWindowEngineOk and timeframe.isintraday and (minsFromOpen >= -revOpenWindowLongMins) and (minsFromOpen <= revOpenWindowLongMins)
inRevOpenWindowShort = useRevOpenWindow and openWindowEngineOk and timeframe.isintraday and (minsFromOpen >= -revOpenWindowShortMins) and (minsFromOpen <= revOpenWindowShortMins)
inRevOpenWindow = inRevOpenWindowLong or inRevOpenWindowShort
openWindowBypassEntries = revOpenWindowMode == "All Entries"

var float entryPrice = na
var float entryAtr   = na
var int   enBar   = 0
var int   enTime  = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice = zoneAnchor == "Entry" and not na(entryPrice) ? entryPrice : zoneAnchor == "VWAP" ? vwapVal : zoneAnchor == "MA200" ? sma200Val : zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

float pbDir = bullBias ? -1.0 : 1.0
aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice + pbDir * zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice + pbDir * zoneAggressiveMult2 * atr)

setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setLongPulse = setPulseOnly ? (setLong and not setLong[1]) : setLong
setShortPulse = setPulseOnly ? (setShort and not setShort[1]) : setShort

trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)

reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = (useStrictEmaExit ? crossClose_EmaS_down : trendFlipDown) or trendFlipDown
breakShort = (useStrictEmaExit ? crossClose_EmaS_up   : trendFlipUp)   or trendFlipUp

var int pos = 0
var float stopPx  = na

var int lastSignalBar = na
var int lastSignalTime = na
var string lastSig = "â€”"

bool presetIsManual = entryPreset == "Manual"
bool presetIsIntraday = entryPreset == "Intraday"
bool presetOverridesActive = (not presetIsManual) and (not lockPresetOverrides)
bool legacyEntryBehavior = entryBehaviorProfile == "Legacy (v6.3.9-like)"
bool scalpEarlyEntryBehavior = entryBehaviorProfile == "Scalp Early (v6.3.12-fast)"
int scoreThresholdLongEff = presetOverridesActive ? (presetIsIntraday ? 5 : 7) : scoreThresholdLong
int scoreThresholdShortEff = presetOverridesActive ? (presetIsIntraday ? 5 : 7) : scoreThresholdShort
if scalpEarlyEntryBehavior
    scoreThresholdLongEff := math.max(4, scoreThresholdLongEff - 1)
    scoreThresholdShortEff := math.max(4, scoreThresholdShortEff - 1)
int wUsiEff = presetOverridesActive ? (presetIsIntraday ? 5 : 3) : wUsi
int wLiquidityEff = presetOverridesActive ? (presetIsIntraday ? 3 : 2) : wLiquidity
int wMomentumEff = presetOverridesActive ? (presetIsIntraday ? 3 : 2) : wMomentum
int wEngulfingEff = presetOverridesActive ? (presetIsIntraday ? 2 : 1) : wEngulfing
int wTrendContextEff = presetOverridesActive ? (presetIsIntraday ? 1 : 2) : wTrendContext
int wChopPenaltyEff = presetOverridesActive ? (presetIsIntraday ? -2 : -4) : wChopPenalty
if legacyEntryBehavior
    wChopPenaltyEff := math.min(wChopPenaltyEff, -1)
bool scoreUseProbGateEff = legacyEntryBehavior ? false : (presetOverridesActive ? true : scoreUseProbGate)
float minDirProbLongEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : minDirProbLong
float minDirProbShortEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : minDirProbShort
float scoreMinProbLongEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinProbLong
float scoreMinProbShortEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinProbShort
if scalpEarlyEntryBehavior
    minDirProbLongEff := math.max(0.30, minDirProbLongEff - 0.05)
    minDirProbShortEff := math.max(0.30, minDirProbShortEff - 0.05)
    scoreMinProbLongEff := math.max(0.30, scoreMinProbLongEff - 0.05)
    scoreMinProbShortEff := math.max(0.30, scoreMinProbShortEff - 0.05)
bool scoreUseConfGateEff = legacyEntryBehavior ? false : scoreUseConfGate
float scoreMinConfLongEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinConfLong
float scoreMinConfShortEff = (presetOverridesActive and presetIsIntraday) ? 0.35 : scoreMinConfShort
if scalpEarlyEntryBehavior
    scoreUseConfGateEff := false
    scoreMinConfLongEff := math.max(0.30, scoreMinConfLongEff - 0.05)
    scoreMinConfShortEff := math.max(0.30, scoreMinConfShortEff - 0.05)
bool useScoreEntriesEff = presetOverridesActive ? true : useScoreEntries
tfSecDynRisk = timeframe.in_seconds(timeframe.period)
isFastDynRisk = (not na(tfSecDynRisk)) and tfSecDynRisk <= SEC_5M
isMidDynRisk = (not na(tfSecDynRisk)) and tfSecDynRisk <= SEC_1H
[dStopEff, _dTrailEff] = f_dyn_sl_preset_vals(decayStopATR, trailATR)
float dynamicDecayStopATREff = dStopEff
bool scoreRequireDirectionalContextEff = legacyEntryBehavior ? false : scoreRequireDirectionalContext
bool scoreChopHardVetoEff = not legacyEntryBehavior and not scalpEarlyEntryBehavior
string cooldownModeEff = (presetAutoCooldown and presetOverridesActive) ? "Bars" : cooldownMode
int cooldownMinutesPreset = presetIsIntraday ? 15 : 45
int cooldownMinutesEff = (presetAutoCooldown and presetOverridesActive) ? cooldownMinutesPreset : cooldownMinutes
string cooldownTriggersEff = (presetAutoCooldown and presetOverridesActive and cooldownTriggers != "EntriesOnly") ? "ExitsOnly" : cooldownTriggers
int cooldownBarsEff = cooldownBars
float chochMinProbEff = legacyEntryBehavior ? math.max(0.34, chochMinProb - 0.05) : scalpEarlyEntryBehavior ? math.max(0.30, chochMinProb - 0.08) : chochMinProb
float abstainOverrideConfEff = scalpEarlyEntryBehavior ? math.max(0.55, abstainOverrideConf - 0.05) : abstainOverrideConf
bool tpPreset30mIsManual = tpPreset30m == "Manual"
float dynamicTpKickInREff = tpPreset30mIsManual ? dynamicTpKickInR : tpPreset30m == "Conservative" ? 1.0 : tpPreset30m == "Balanced" ? 0.7 : tpPreset30m == "Runner" ? 0.4 : 0.2
float dynamicTpAddATRPerREff = tpPreset30mIsManual ? dynamicTpAddATRPerR : tpPreset30m == "Conservative" ? 0.30 : tpPreset30m == "Balanced" ? 0.50 : tpPreset30m == "Runner" ? 0.75 : 1.00
float dynamicTpMaxAddATREff = tpPreset30mIsManual ? dynamicTpMaxAddATR : tpPreset30m == "Conservative" ? 2.5 : tpPreset30m == "Balanced" ? 4.0 : tpPreset30m == "Runner" ? 6.0 : 8.0

effectiveCooldownBars = (confidence >= 0.80) ? math.max(2, math.round(cooldownBarsEff / 2)) : cooldownBarsEff
effectiveCooldownMin  = (confidence >= 0.80) ? math.max(2, math.round(cooldownMinutesEff / 2)) : cooldownMinutesEff

cooldownOk = (cooldownModeEff == "Bars") ? (na(lastSignalBar) ? true : (bar_index - lastSignalBar > effectiveCooldownBars)) : (na(lastSignalTime) ? true : (time - lastSignalTime > (effectiveCooldownMin * 60 * 1000)))

f_get_state_for_tf(tfSel) =>
    TfState st = na
    if tfSel == "F1"
        st := tf1State
    else if tfSel == "F2"
        st := tf2State
    else if tfSel == "F3"
        st := tf3State
    else if tfSel == "F4"
        st := tf4State
    else if tfSel == "F5"
        st := tf5State
    else if tfSel == "F6"
        st := tf6State
    else if tfSel == "F7"
        st := tf7State
    st

f_getBrier_raw(tfSel) =>
    float score = na
    st = f_get_state_for_tf(tfSel)
    if not na(st)
        if use3Way
            score := array.size(st.evBrierN) == 0 ? na : array.get(st.evSumBrierN, 0) / array.size(st.evBrierN)
        else
            s = array.get(st.brierStatsN, 0)
            c = array.get(st.brierStatsN, 1)
            score := c > 0 ? s / c : na
    score

f_get_total_samples(tfSel, useBull) =>
    float total = na
    st = f_get_state_for_tf(tfSel)
    if not na(st)
        useBullSel = useBull == true
        cnt = useBullBearCal ? (useBullSel ? st.cntN_bull_raw : st.cntN_bear_raw) : st.cntN_raw
        total := array.sum(cnt)
    total

f_eval_metrics_for_tf(tfSel) =>
    st = f_get_state_for_tf(tfSel)
    if na(st)
        [float(na), float(na), float(na)]
    else
        [_bAvg, _lAvg, ece, _mErr, _wS, _wL, drift, nSc] = f_eval_stats_one(st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN)
        [ece, drift * 100.0, nSc]

f_eval_success_for_tf(tfSel) =>
    st = f_get_state_for_tf(tfSel)
    if na(st)
        [float(na), 0]
    else
        n = array.size(st.evYS_N)
        wr = n == 0 ? na : array.get(st.evSumYS_N, 0) / n
        [wr, n]


var float[] relPUN  = array.new_float(7, na)
var float[] relPFN  = array.new_float(7, na)
var float[] relPDN  = array.new_float(7, na)
var float[] relNN   = array.new_float(7, na)
var float[] relTotN = array.new_float(7, na)
var float[] relPU1  = array.new_float(7, na)
var float[] relPF1  = array.new_float(7, na)
var float[] relPD1  = array.new_float(7, na)
var float[] relN1   = array.new_float(7, na)
var float[] relTot1 = array.new_float(7, na)

f_tf_index(tfSel) =>
    tfSel == "F1" ? 0 : tfSel == "F2" ? 1 : tfSel == "F3" ? 2 : tfSel == "F4" ? 3 : tfSel == "F5" ? 4 : tfSel == "F6" ? 5 : 6

f_idx_to_tfsel(idx) =>
    idx == 0 ? "F1" : idx == 1 ? "F2" : idx == 2 ? "F3" : idx == 3 ? "F4" : idx == 4 ? "F5" : idx == 5 ? "F6" : "F7"

f_find_tf_idx(tf, tfArr) =>
    int idx = -1
    for i = 0 to array.size(tfArr) - 1
        if array.get(tfArr, i) == tf
            idx := i
            break
    idx

f_get_rel_vals(tfSel) =>
    float pU = na
    float pF = na
    float pD = na
    float nBin = na
    float total = na
    idx = f_tf_index(tfSel)
    pU := array.get(relPUN, idx)
    pF := array.get(relPFN, idx)
    pD := array.get(relPDN, idx)
    nBin := array.get(relNN, idx)
    total := array.get(relTotN, idx)
    [pU, pF, pD, nBin, total]

f_edges3(pU, pF, pD) =>
    [pU - pF, pU - pD, pD - pF, pD - pU]

f_decision_quality(pU, pF, pD, nBin, total) =>
    if not use3Way
        [false, "3-way off", color.gray, na]
    else
        if na(pU) or na(pF) or na(pD) or na(nBin) or na(total)
            [false, "n/a", color.orange, na]
        else
            maxP = math.max(pU, math.max(pF, pD))
            tieEps = 1e-10
            isMaxU = math.abs(pU - maxP) <= tieEps
            isMaxF = math.abs(pF - maxP) <= tieEps
            isMaxD = math.abs(pD - maxP) <= tieEps
            dir = (isMaxU and not (isMaxF or isMaxD)) ? 1 : (isMaxD and not (isMaxU or isMaxF)) ? -1 : 0
            edgeFlat = dir == 1 ? (pU - pF) : dir == -1 ? (pD - pF) : 0.0
            edgeOpp  = dir == 1 ? (pU - pD) : dir == -1 ? (pD - pU) : 0.0
            edge = dir == 0 ? na : math.min(edgeFlat, edgeOpp)

            binOk   = (tradeMinBinSamples <= 0) or (nBin >= tradeMinBinSamples)
            totalOk = (tradeMinTotalSamples <= 0) or (total >= tradeMinTotalSamples)
            edgeOk  = (dir != 0) and edge >= abstainMinEdge

            ok = edgeOk and binOk and totalOk

            reason =
                 (tradeMinTotalSamples > 0 and total < tradeMinTotalSamples) ? "Low Total" :
                 (tradeMinBinSamples   > 0 and nBin  < tradeMinBinSamples)   ? "Weak Bin" :
                 (dir == 0)                                                  ? "Flat" :
                 (edge < abstainMinEdge)                                    ? "Low Edge" :
                 "OK"

            col = ok ? color.lime : color.orange
            [ok, reason, col, edge]

f_stable_val(isSame, valRaw, valPrev) => isSame ? valRaw : valPrev
f_stable_pulse(isSame, timeRaw)       => isSame ? barstate.isconfirmed : (nz(ta.change(timeRaw)) != 0)

[t1_r, c1_r, h1_r, l1_r, ef1_r, es1_r, r1_r, a1_r, vR1_r] = f_tf_pack(tfF1)
[t2_r, c2_r, h2_r, l2_r, ef2_r, es2_r, r2_r, a2_r, vR2_r] = f_tf_pack(tfF2)
[t3_r, c3_r, h3_r, l3_r, ef3_r, es3_r, r3_r, a3_r, vR3_r] = f_tf_pack(tfF3)
[t4_r, c4_r, h4_r, l4_r, ef4_r, es4_r, r4_r, a4_r, vR4_r] = f_tf_pack(tfF4)
[t5_r, c5_r, h5_r, l5_r, ef5_r, es5_r, r5_r, a5_r, vR5_r] = f_tf_pack(tfF5)
[t6_r, c6_r, h6_r, l6_r, ef6_r, es6_r, r6_r, a6_r, vR6_r] = f_tf_pack(tfF6)
[t7_r, c7_r, h7_r, l7_r, ef7_r, es7_r, r7_r, a7_r, vR7_r] = f_tf_pack(tfF7)

same1 = tfF1 == timeframe.period
same2 = tfF2 == timeframe.period
same3 = tfF3 == timeframe.period
same4 = tfF4 == timeframe.period
same5 = tfF5 == timeframe.period
same6 = tfF6 == timeframe.period
same7 = tfF7 == timeframe.period

pulse1 = f_stable_pulse(same1, t1_r)
pulse2 = f_stable_pulse(same2, t2_r)
pulse3 = f_stable_pulse(same3, t3_r)
pulse4 = f_stable_pulse(same4, t4_r)
pulse5 = f_stable_pulse(same5, t5_r)
pulse6 = f_stable_pulse(same6, t6_r)
pulse7 = f_stable_pulse(same7, t7_r)

t1 = f_stable_val(same1, t1_r, t1_r[1]), c1 = f_stable_val(same1, c1_r, c1_r[1]), h1 = f_stable_val(same1, h1_r, h1_r[1]), l1 = f_stable_val(same1, l1_r, l1_r[1]), ef1 = f_stable_val(same1, ef1_r, ef1_r[1]), es1 = f_stable_val(same1, es1_r, es1_r[1]), r1 = f_stable_val(same1, r1_r, r1_r[1]), a1 = f_stable_val(same1, a1_r, a1_r[1]), vR1 = f_stable_val(same1, vR1_r, vR1_r[1])
t2 = f_stable_val(same2, t2_r, t2_r[1]), c2 = f_stable_val(same2, c2_r, c2_r[1]), h2 = f_stable_val(same2, h2_r, h2_r[1]), l2 = f_stable_val(same2, l2_r, l2_r[1]), ef2 = f_stable_val(same2, ef2_r, ef2_r[1]), es2 = f_stable_val(same2, es2_r, es2_r[1]), r2 = f_stable_val(same2, r2_r, r2_r[1]), a2 = f_stable_val(same2, a2_r, a2_r[1]), vR2 = f_stable_val(same2, vR2_r, vR2_r[1])
t3 = f_stable_val(same3, t3_r, t3_r[1]), c3 = f_stable_val(same3, c3_r, c3_r[1]), h3 = f_stable_val(same3, h3_r, h3_r[1]), l3 = f_stable_val(same3, l3_r, l3_r[1]), ef3 = f_stable_val(same3, ef3_r, ef3_r[1]), es3 = f_stable_val(same3, es3_r, es3_r[1]), r3 = f_stable_val(same3, r3_r, r3_r[1]), a3 = f_stable_val(same3, a3_r, a3_r[1]), vR3 = f_stable_val(same3, vR3_r, vR3_r[1])
t4 = f_stable_val(same4, t4_r, t4_r[1]), c4 = f_stable_val(same4, c4_r, c4_r[1]), h4 = f_stable_val(same4, h4_r, h4_r[1]), l4 = f_stable_val(same4, l4_r, l4_r[1]), ef4 = f_stable_val(same4, ef4_r, ef4_r[1]), es4 = f_stable_val(same4, es4_r, es4_r[1]), r4 = f_stable_val(same4, r4_r, r4_r[1]), a4 = f_stable_val(same4, a4_r, a4_r[1]), vR4 = f_stable_val(same4, vR4_r, vR4_r[1])
t5 = f_stable_val(same5, t5_r, t5_r[1]), c5 = f_stable_val(same5, c5_r, c5_r[1]), h5 = f_stable_val(same5, h5_r, h5_r[1]), l5 = f_stable_val(same5, l5_r, l5_r[1]), ef5 = f_stable_val(same5, ef5_r, ef5_r[1]), es5 = f_stable_val(same5, es5_r, es5_r[1]), r5 = f_stable_val(same5, r5_r, r5_r[1]), a5 = f_stable_val(same5, a5_r, a5_r[1]), vR5 = f_stable_val(same5, vR5_r, vR5_r[1])
t6 = f_stable_val(same6, t6_r, t6_r[1]), c6 = f_stable_val(same6, c6_r, c6_r[1]), h6 = f_stable_val(same6, h6_r, h6_r[1]), l6 = f_stable_val(same6, l6_r, l6_r[1]), ef6 = f_stable_val(same6, ef6_r, ef6_r[1]), es6 = f_stable_val(same6, es6_r, es6_r[1]), r6 = f_stable_val(same6, r6_r, r6_r[1]), a6 = f_stable_val(same6, a6_r, a6_r[1]), vR6 = f_stable_val(same6, vR6_r, vR6_r[1])
t7 = f_stable_val(same7, t7_r, t7_r[1]), c7 = f_stable_val(same7, c7_r, c7_r[1]), h7 = f_stable_val(same7, h7_r, h7_r[1]), l7 = f_stable_val(same7, l7_r, l7_r[1]), ef7 = f_stable_val(same7, ef7_r, ef7_r[1]), es7 = f_stable_val(same7, es7_r, es7_r[1]), r7 = f_stable_val(same7, r7_r, r7_r[1]), a7 = f_stable_val(same7, a7_r, a7_r[1]), vR7 = f_stable_val(same7, vR7_r, vR7_r[1])

outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

tfForecastArr = array.from(tfF1, tfF2, tfF3, tfF4, tfF5, tfF6, tfF7)
cForecastArr = array.from(c1, c2, c3, c4, c5, c6, c7)
hForecastArr = array.from(h1, h2, h3, h4, h5, h6, h7)
lForecastArr = array.from(l1, l2, l3, l4, l5, l6, l7)
efForecastArr = array.from(ef1, ef2, ef3, ef4, ef5, ef6, ef7)
esForecastArr = array.from(es1, es2, es3, es4, es5, es6, es7)
rForecastArr = array.from(r1, r2, r3, r4, r5, r6, r7)
aForecastArr = array.from(a1, a2, a3, a4, a5, a6, a7)
vRForecastArr = array.from(vR1, vR2, vR3, vR4, vR5, vR6, vR7)
confForecastArr = array.from(barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed, barstate.isconfirmed)
outScoreArr = array.from(outScore1, outScore2, outScore3, outScore4, outScore5, outScore6, outScore7)

f_entry_forecast_gate(isLong) =>
    if openWindowBypassEntries and (isLong ? inRevOpenWindowLong : inRevOpenWindowShort)
        true
    else
        bool ok = true
        forecastAllowed = enableForecast and f_forecast_allowed()
        if useForecastGateEntry and use3Way and forecastAllowed
            [pU, pF, pD, nBin, total] = f_get_rel_vals(entryFcTF)
            binOk   = (tradeMinBinSamples <= 0) or (nBin >= tradeMinBinSamples)
            totalOk = (tradeMinTotalSamples <= 0) or (total >= tradeMinTotalSamples)

            canCal = forecastAllowed and (not na(total) and total > 0)
            relLbl = f_rel_label(isLong ? pU : pD, nBin, total, canCal)
            relOk  = (not requireRelOk) or (relLbl == "ok" or relLbl == "strong")

            [eUf, eUo, eDf, eDo] = f_edges3(pU, pF, pD)
            entryTf = f_tf_from_horizon(entryFcTF)
            [entryTgt, _, _, _, _, _] = f_get_params(entryTf)
            pathTargetOk = (not requirePathTargetEntry) or (entryTgt == "PathTPvsSL")
            
            if isLong
                edgeOk = (not na(eUf) and eUf >= minEdgePP) and (not na(eUo) and eUo >= minEdgePP)
                ok := binOk and totalOk and relOk and pathTargetOk and (not na(pU) and pU >= minDirProbLongEff) and edgeOk
            else
                edgeOk = (not na(eDf) and eDf >= minEdgePP) and (not na(eDo) and eDo >= minEdgePP)
                ok := binOk and totalOk and relOk and pathTargetOk and (not na(pD) and pD >= minDirProbShortEff) and edgeOk

            idxFc = f_tf_index(entryFcTF)
            cSel = array.get(cForecastArr, idxFc)
            efSel = array.get(efForecastArr, idxFc)
            esSel = array.get(esForecastArr, idxFc)
            aSel = array.get(aForecastArr, idxFc)
            confSel = array.get(confForecastArr, idxFc)
            trendSideLocal = (confSel == true) and (f_trend_regime(efSel, esSel, aSel / math.max(cSel, PRICE_EPS)) == 0.0)
            if useChopAbstain and trendSideLocal and (not na(pF) and pF >= flatAbstainThr)
                ok := false
        ok

[tS1, cS1, hS1, lS1, efS1, esS1, rS1, aS1, vRS1] = f_tf_pack(tfShort1), confS1 = barstate.isconfirmed
[tS2, cS2, hS2, lS2, efS2, esS2, rS2, aS2, vRS2] = f_tf_pack(tfShort2), confS2 = barstate.isconfirmed
[tS3, cS3, hS3, lS3, efS3, esS3, rS3, aS3, vRS3] = f_tf_pack(tfShort3), confS3 = barstate.isconfirmed
[tM1, cM1, hM1, lM1, efM1, esM1, rM1, aM1, vRM1] = f_tf_pack(tfMedium1), confM1 = barstate.isconfirmed
[tM2, cM2, hM2, lM2, efM2, esM2, rM2, aM2, vRM2] = f_tf_pack(tfMedium2), confM2 = barstate.isconfirmed
[tM3, cM3, hM3, lM3, efM3, esM3, rM3, aM3, vRM3] = f_tf_pack(tfMedium3), confM3 = barstate.isconfirmed
[tL1, cL1, hL1, lL1, efL1, esL1, rL1, aL1, vRL1] = f_tf_pack(tfLong1), confL1 = barstate.isconfirmed
[tL2, cL2, hL2, lL2, efL2, esL2, rL2, aL2, vRL2] = f_tf_pack(tfLong2), confL2 = barstate.isconfirmed
[tL3, cL3, hL3, lL3, efL3, esL3, rL3, aL3, vRL3] = f_tf_pack(tfLong3), confL3 = barstate.isconfirmed

tfMtfArr = array.from(tfShort1, tfShort2, tfShort3, tfMedium1, tfMedium2, tfMedium3, tfLong1, tfLong2, tfLong3)
cMtfArr = array.from(cS1, cS2, cS3, cM1, cM2, cM3, cL1, cL2, cL3)
efMtfArr = array.from(efS1, efS2, efS3, efM1, efM2, efM3, efL1, efL2, efL3)
esMtfArr = array.from(esS1, esS2, esS3, esM1, esM2, esM3, esL1, esL2, esL3)
rMtfArr = array.from(rS1, rS2, rS3, rM1, rM2, rM3, rL1, rL2, rL3)

isBull1 = f_is_bull_bias(outScore1, ef1, es1)
isBull2 = f_is_bull_bias(outScore2, ef2, es2)
isBull3 = f_is_bull_bias(outScore3, ef3, es3)
isBull4 = f_is_bull_bias(outScore4, ef4, es4)
isBull5 = f_is_bull_bias(outScore5, ef5, es5)
isBull6 = f_is_bull_bias(outScore6, ef6, es6)
isBull7 = f_is_bull_bias(outScore7, ef7, es7)

mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= SEC_30M) ? "Short" : (not na(mtfBaseSecs) and mtfBaseSecs <= SEC_4H) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

f_score_tf_cached(tf) =>
    idx = f_find_tf_idx(tf, tfForecastArr)
    if idx >= 0
        f_score_tf(array.get(cForecastArr, idx), array.get(efForecastArr, idx), array.get(esForecastArr, idx), array.get(rForecastArr, idx))
    else
        idxM = f_find_tf_idx(tf, tfMtfArr)
        idxM >= 0 ? f_score_tf(array.get(cMtfArr, idxM), array.get(efMtfArr, idxM), array.get(esMtfArr, idxM), array.get(rMtfArr, idxM)) : na

getVoteScore() =>
    float sum = 0.0
    float wgt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += 1.0 * nz(f_score_tf_cached(tf1), 0.0)
        wgt += 1.0
    if f_is_tf_higher_or_equal(tf2)
        sum += 1.5 * nz(f_score_tf_cached(tf2), 0.0)
        wgt += 1.5
    if f_is_tf_higher_or_equal(tf3)
        sum += 2.0 * nz(f_score_tf_cached(tf3), 0.0)
        wgt += 2.0

    wgt == 0 ? 0.0 : sum / wgt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > SCORE_NEUTRAL_BAND)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -SCORE_NEUTRAL_BAND)

f_is_chart_tf(tf) =>
    timeframe.period == tf

var bool invLatched = false
var string invLatchInfo = ""

var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All"
        f_reset_eval_all()
        invLatched := false
        invLatchInfo := ""
    
    if resetWhich == "All" or resetWhich == "F1" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF1))
        f_reset_tf(tf1State)
    if resetWhich == "All" or resetWhich == "F2" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF2))
        f_reset_tf(tf2State)
    if resetWhich == "All" or resetWhich == "F3" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF3))
        f_reset_tf(tf3State)
    if resetWhich == "All" or resetWhich == "F4" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF4))
        f_reset_tf(tf4State)
    if resetWhich == "All" or resetWhich == "F5" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF5))
        f_reset_tf(tf5State)
    if resetWhich == "All" or resetWhich == "F6" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF6))
        f_reset_tf(tf6State)
    if resetWhich == "All" or resetWhich == "F7" or (resetWhich == "ChartTF" and f_is_chart_tf(tfF7))
        f_reset_tf(tf7State)

doCal = enableForecast and barstate.isconfirmed and f_forecast_allowed() and (calibrateInBackground or showEvalSection)
if doCal
    for i = 0 to 6
        tfSel = f_idx_to_tfsel(i)
        tfH = array.get(tfForecastArr, i)
        [fc, kb, at, ph, tp, sl] = f_get_params(tfH)
        st = f_get_state_for_tf(tfSel)
        if not na(st)
            f_process_tf(i + 1, tfH, array.get(confForecastArr, i), array.get(outScoreArr, i), array.get(cForecastArr, i), array.get(hForecastArr, i), array.get(lForecastArr, i), array.get(aForecastArr, i), array.get(vRForecastArr, i), array.get(efForecastArr, i), array.get(esForecastArr, i),
                st,
                fc, kb, at, ph, tp, sl,
                alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

f_get_disp_vals(_tf, sA, c, atrVal, ef, es, vr, TfState st) =>
    bias = ef > es ? 1 : ef < es ? -1 : 0
    sB = f_pullback_score(c, ef, es, bias)
    sC = vr >= VOL_THRESH_HIGH ? -1.0 : (vr <= VOL_THRESH_LOW ? 1.0 : 0.0)
    atrNorm = atrVal / math.max(c, PRICE_EPS)
    sD = f_trend_regime(ef, es, atrNorm)
    sEns = f_ensemble4(sA, sB, sC, sD, wState, wPullback, wRegime, wTrend)
    if na(sEns) or na(sD)
        [pUpr_t, pFpr_t, pDpr_t] = f_prior3(_tf, sA)
        [pUpr_t, pFpr_t, pDpr_t, 0.0, pUpr_t, pFpr_t, pDpr_t, 0.0]
    else
        bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, st.qCutsN)
        b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, st.qCuts1)
        biasSel = useBullBearCal ? f_bias_from_score(sA) : 0
        if biasSel == 0
            biasSel := bias == 0 ? 1 : bias
        cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        upN_sel  = useBullBearCal ? (biasSel > 0 ? st.upN_bull  : st.upN_bear)  : st.upN
        dnN_sel  = useBullBearCal ? (biasSel > 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
        cnt1_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
        up1_sel  = useBullBearCal ? (biasSel > 0 ? st.up1_bull  : st.up1_bear)  : st.up1
        dn1_sel  = useBullBearCal ? (biasSel > 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1
        cntN_raw_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull_raw : st.cntN_bear_raw) : st.cntN_raw
        cnt1_raw_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull_raw : st.cnt1_bear_raw) : st.cnt1_raw
        tempN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.tempN_bull : st.tempN_bear) : st.tempN
        temp1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.temp1_bull : st.temp1_bear) : st.temp1
        vecAN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecAN_bull : st.vecAN_bear) : st.vecAN
        vecBN_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecBN_bull : st.vecBN_bear) : st.vecBN
        vecA1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecA1_bull : st.vecA1_bear) : st.vecA1
        vecB1_sel = (useBullBearCal and biasSel != 0) ? (biasSel > 0 ? st.vecB1_bull : st.vecB1_bear) : st.vecB1
        [pUN_t, pFN_t, pDN_t, nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaN, kShrink, kShrinkReg)
        [pU1_t, pF1_t, pD1_t, n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1, kShrink, kShrinkReg)
        pUN = pUN_t
        pFN = pFN_t
        pDN = pDN_t
        nN = array.get(cntN_raw_sel, bN)
        pU1 = pU1_t
        pF1 = pF1_t
        pD1 = pD1_t
        n1 = array.get(cnt1_raw_sel, b1)
        useCalN = f_can_cal3(nN_t)
        useCal1 = f_can_cal3(n1_t)
        if useCalN
            zUN = f_safe_log(pUN)
            zFN = f_safe_log(pFN)
            zDN = f_safe_log(pDN)
            [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, tempN_sel, vecAN_sel, vecBN_sel)
            pUN := tUN_t
            pFN := tFN_t
            pDN := tDN_t
        if useCal1
            zU1 = f_safe_log(pU1)
            zF1 = f_safe_log(pF1)
            zD1 = f_safe_log(pD1)
            [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, temp1_sel, vecA1_sel, vecB1_sel)
            pU1 := tU1_t
            pF1 := tF1_t
            pD1 := tD1_t
        if nN < calMinSamples
            [pUpr_t, pFpr_t, pDpr_t] = f_prior3(_tf, sA)
            [pUN_b, pFN_b, pDN_b] = f_blend_prior(pUN, pFN, pDN, pUpr_t, pFpr_t, pDpr_t, nN)
            pUN := pUN_b
            pFN := pFN_b
            pDN := pDN_b
        if n1 < calMinSamples
            [pUpr2_t, pFpr2_t, pDpr2_t] = f_prior3(_tf, sA)
            [pU1_b, pF1_b, pD1_b] = f_blend_prior(pU1, pF1, pD1, pUpr2_t, pFpr2_t, pDpr2_t, n1)
            pU1 := pU1_b
            pF1 := pF1_b
            pD1 := pD1_b
        [pUN, pFN, pDN, nN, pU1, pF1, pD1, n1]


for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    tfH = array.get(tfForecastArr, i)
    st = f_get_state_for_tf(tfSel)
    if not na(st)
        [pUN_t, pFN_t, pDN_t, nN_t, pU1_t, pF1_t, pD1_t, n1_t] = f_get_disp_vals(tfH, array.get(outScoreArr, i), array.get(cForecastArr, i), array.get(aForecastArr, i), array.get(efForecastArr, i), array.get(esForecastArr, i), array.get(vRForecastArr, i), st)
        array.set(relPUN, i, pUN_t)
        array.set(relPFN, i, pFN_t)
        array.set(relPDN, i, pDN_t)
        array.set(relNN,  i, nN_t)
        array.set(relPU1, i, pU1_t)
        array.set(relPF1, i, pF1_t)
        array.set(relPD1, i, pD1_t)
        array.set(relN1,  i, n1_t)


for i = 0 to 6
    tfSel = f_idx_to_tfsel(i)
    st = f_get_state_for_tf(tfSel)
    if not na(st)
        sA = array.get(outScoreArr, i)
        ef = array.get(efForecastArr, i)
        es = array.get(esForecastArr, i)
        bias = ef > es ? 1 : ef < es ? -1 : 0
        biasSel = useBullBearCal ? f_bias_from_score(sA) : 0
        if biasSel == 0
            biasSel := bias == 0 ? 1 : bias
        cntN_sel = useBullBearCal ? (biasSel > 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        cnt1_sel = useBullBearCal ? (biasSel > 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
        
        tN_tot = array.sum(cntN_sel)
        t1_tot = array.sum(cnt1_sel)

        array.set(relTotN, i, tN_tot)
        array.set(relTot1, i, t1_tot)


forecastAllowed = enableForecast and f_forecast_allowed()

needRelVal = forecastAllowed and useRelFilter
needEvdVal = forecastAllowed and evidenceGate

curBrierRaw = needRelVal ? f_getBrier_raw(relFilterTF) : na
relBull = relFilterTF == "F1" ? isBull1 : relFilterTF == "F2" ? isBull2 : relFilterTF == "F3" ? isBull3 : relFilterTF == "F4" ? isBull4 : relFilterTF == "F5" ? isBull5 : relFilterTF == "F6" ? isBull6 : isBull7

totSampSub = (needRelVal or needEvdVal) ? f_get_total_samples(relFilterTF, relBull) : na

totSampGlob = totSampSub
if useBullBearCal and needRelVal
    totSampGlob := f_get_total_samples(relFilterTF, true) + f_get_total_samples(relFilterTF, false)

f_fc_bool(x) => x == true
f_fc_num(x)  => not na(x)

useForecast = (forecastAllowed == true)

reliabilityOk =
     (not useForecast)  ? true :
     (not useRelFilter) ? true :
     (f_fc_num(curBrierRaw) and f_fc_num(totSampGlob) and (totSampGlob > 0) and (curBrierRaw <= maxBrier))

evidenceOk =
     (not useForecast)  ? true :
     (not evidenceGate) ? true :
     (f_fc_num(totSampSub) and (totSampSub >= evidenceMinTotal))

[pRelU_t, pRelF_t, pRelD_t, nRel_t, totRel_t] = f_get_rel_vals(relFilterTF)
pRelU = pRelU_t
pRelF = pRelF_t
pRelD = pRelD_t
nRel  = nRel_t
totRel = totRel_t

[decisionOk_t, _, _, decisionEdge_t] = f_decision_quality(pRelU, pRelF, pRelD, nRel, totRel)
decisionOk = decisionOk_t
decisionEdge = decisionEdge_t

[evalEce, evalDriftPP, evalN] = f_eval_metrics_for_tf(relFilterTF)
[evalSuccessRate, evalSuccessN] = f_eval_success_for_tf(relFilterTF)
evalSuccessTxt = (evalSuccessN > 0 and not na(evalSuccessRate)) ? str.tostring(evalSuccessRate * 100.0, "#.0") + "%" : "0%"
evalModeTxt = evalMode == "LiveOnly" ? "LiveOnly" : "History+Live"
evalSuccessHudTxt = "Success rate (" + evalModeTxt + "): " + evalSuccessTxt + " (N=" + str.tostring(evalSuccessN) + ")"
prevEvalEce := evalEce

eceOk =
     (not useForecast) ? true :
     (not useEceGate)  ? true :
     (f_fc_num(evalEce) and (evalEce <= eceMax))

driftOk =
     (not useForecast)  ? true :
     (not useDriftGate) ? true :
     (f_fc_num(evalDriftPP) and (math.abs(evalDriftPP) <= driftMaxPP))

evalOk = (not useForecast) ? true : (eceOk and driftOk)

evalSoftHit = useEvalPenalty and ((not na(evalEce) and evalEce >= eceWarn) or (not na(evalDriftPP) and math.abs(evalDriftPP) >= driftWarnPP))
confGate = evalSoftHit ? f_clamp01(confidence * (1.0 - evalPenalty)) : confidence

f_fail_open(bool _cond) => 
    (_cond == true) ? true : (_cond == false) ? false : true

ddOk        = (ddHardGateHit == false)

// VWT trend gates (default fail-open when disabled)
vwtLongEntryOk = (not useVwtTrendFilter) or (not na(emaF) and not na(emaS) and emaF >= emaS)
vwtShortEntryOk = (not useVwtTrendFilter) or (not na(emaF) and not na(emaS) and emaF <= emaS)
gateLongNow  = ddOk and f_fail_open(mtfOkLong) and f_fail_open(macroGateLong) and vwtLongEntryOk
gateShortNow = ddOk and f_fail_open(mtfOkShort) and f_fail_open(macroGateShort) and vwtShortEntryOk

decisionOkSafe     = (not use3Way) ? true : na(decisionEdge) ? true : f_fc_bool(decisionOk)
isHighConf         = f_fc_bool(confidence >= abstainOverrideConfEff)
decisionFinal      = decisionOkSafe or isHighConf

cooldownOkSafe     = f_fc_bool(cooldownOk)
blockNearCloseSafe = f_fc_bool(not blockNearClose)

signalOnCloseOnly = alertOnBarCloseOnly
signalGateConfirmed = barstate.isconfirmed or (not signalOnCloseOnly and barstate.isrealtime)

allowEntry = signalGateConfirmed and cooldownOkSafe and blockNearCloseSafe and f_fc_bool(reliabilityOk) and f_fc_bool(evidenceOk) and f_fc_bool(evalOk) and (not abstainGate or decisionFinal)


bool buySignal = false
bool shortSignal = false
bool exitSignal = false
bool coverSignal = false
bool didBuy = false
bool didShort = false
bool didExit = false
bool didCover = false


holdCooldownBars = cooldownBarsEff
holdCooldownMin  = cooldownMinutesEff

entryOnlyExitHoldActive =
     (cooldownTriggersEff == "EntriesOnly")
 and pos != 0
 and (
        cooldownModeEff == "Bars"
            ? (holdCooldownBars >= 1 and (not na(enBar)) and (bar_index - enBar <= holdCooldownBars))
            : (holdCooldownMin  >= 1 and (not na(enTime)) and (time - enTime <= (holdCooldownMin * 60 * 1000)))
    )
allowExitBase = signalGateConfirmed and (not entryOnlyExitHoldActive)
allowExitDuringHold = signalGateConfirmed and entryOnlyExitHoldActive
allowExitLong = allowExitBase or allowExitDuringHold
allowExitShort = allowExitBase or allowExitDuringHold
bool staleExit = false

buySignal   := false
exitSignal  := false
shortSignal := false
coverSignal := false

atrNormHere = atr / math.max(close, PRICE_EPS)
trendReg = f_trend_regime(trendCoreFast, trendCoreSlow, atrNormHere)

usiBull = useUsi and usiStackDir == 1
usiBear = useUsi and usiStackDir == -1

trendUp  = (trendReg == 1.0) or usiBull
trendDn  = (trendReg == -1.0) or usiBear
trendSide = trendReg == 0.0

sideEmaAbs = math.abs((trendCoreFast - trendCoreSlow) / math.max(nz(trendCoreSlow, 1.0), PRICE_EPS))
sideEnter = sideEmaAbs < (SIDEWAYS_EMA_THRESH * 0.70) and atrNormHere < (SIDEWAYS_ATR_THRESH * 0.80)
sideExit  = sideEmaAbs > (SIDEWAYS_EMA_THRESH * 1.15) or  atrNormHere > (SIDEWAYS_ATR_THRESH * 1.20)
var bool sidewaysVisual = false
if sideEnter
    sidewaysVisual := true
else if sideExit
    sidewaysVisual := false

trendStrength = f_trend_strength(trendCoreFast, trendCoreSlow)
trendUpSmooth  = (useSmoothTrend ? trendStrength > TREND_SMOOTH_THRESH : trendUp) or usiBull
trendDnSmooth  = (useSmoothTrend ? trendStrength < -TREND_SMOOTH_THRESH : trendDn) or usiBear

[diPlus, diMinus, adxRaw] = ta.dmi(adxLen, adxLen)
adxOk = (not useAdx) or (not na(adxRaw) and (adxRaw >= adxThresh or (engine == "Hybrid" and adxRaw >= 12)))

volSma = ta.sma(volume, volLen)
volTol = 0.50
volOk = (not useVolConfirm) or (not na(volume) and volume > (volSma * volMult * volTol))

rocScore = f_roc_score(close, rocLen)
rocLongOk  = wRoc == 0 or rocScore > 0.0
rocShortOk = wRoc == 0 or rocScore < 0.0

volScore = f_vol_score(volume, volEnsLen)
volEnsLongOk  = wVol == 0 or volScore > -0.3
volEnsShortOk = wVol == 0 or volScore > -0.3

pbLow  = ta.lowest(low, pbLookback)
pbHigh = ta.highest(high, pbLookback)

pbDepthLong = (emaF - pbLow) / math.max(atr, PRICE_EPS)
pbDepthShort = (pbHigh - emaF) / math.max(atr, PRICE_EPS)

touchTol = 0.12 * atr
touchEmaF_Long  = low <= (emaF + touchTol) and close >= emaF
touchEmaF_Short = high >= (emaF - touchTol) and close <= emaF

bullReversal = close > open and close > emaF and low <= (emaF + touchTol)
bearReversal = close < open and close < emaF and high >= (emaF - touchTol)

prevThreeBear = (open[3] > close[3]) and (open[2] > close[2]) and (open[1] > close[1])
prevThreeBull = (open[3] < close[3]) and (open[2] < close[2]) and (open[1] < close[1])
prevBody = math.abs(open[1] - close[1])
bullBody = close - open
bearBody = open - close

bullEngulf3 = prevThreeBear and (close > open) and (close >= open[1]) and (close[1] >= open) and ((not engulfingRequireBodyDominance) or (bullBody > prevBody))
bearEngulf3 = prevThreeBull and (open > close) and (open >= close[1]) and (open[1] >= close) and ((not engulfingRequireBodyDominance) or (bearBody > prevBody))


engulfLongOk = (not reqEngulfing) or bullEngulf3
engulfShortOk = (not reqEngulfing) or bearEngulf3

float regSlopeOsc = 0.0
bool regSlopeLongOk = true
bool regSlopeShortOk = true

if useRegSlope
    regSlopeOsc := f_calc_reg_slope_osc(close, rsMinRange, rsMaxRange, rsStep)
    
    regSlopeLongOk  := regSlopeOsc > 0
    regSlopeShortOk := regSlopeOsc < 0


chartRsi = ta.rsi(close, rsiStateLen)
preMomLongOk  = (not usePreMomentum) or (not na(chartRsi) and chartRsi >= preMomRsiHi)
preMomShortOk = (not usePreMomentum) or (not na(chartRsi) and chartRsi <= preMomRsiLo)

emaGap     = math.abs(emaF - emaS) / math.max(close, PRICE_EPS)
emaGapPrev = math.abs(emaF[1] - emaS[1]) / math.max(close[1], PRICE_EPS)
emaAccelTol = 0.05 * (emaGapPrev + 0.0001)
emaAccelLongOk  = (not useEmaAccel) or (emaGap >= (emaGapPrev - emaAccelTol))
emaAccelShortOk = (not useEmaAccel) or (emaGap >= (emaGapPrev - emaAccelTol))

isIntraday = timeframe.isintraday
vwapLongOk  = (not useVwap) or (not isIntraday) or (na(vwapVal) or close >= vwapVal)
vwapShortOk = (not useVwap) or (not isIntraday) or (na(vwapVal) or close <= vwapVal)

setOkLong  = (not requireSET) or setLong
setOkShort = (not requireSET) or setShort

fcGateLong  = f_entry_forecast_gate(true)
fcGateShort = f_entry_forecast_gate(false)

pbTol = 0.25
pullbackLongOk  = trendUpSmooth and bullBias and (pbDepthLong >= (pbMinATR - pbTol)) and (pbDepthLong <= (pbMaxATR + pbTol)) and (close > emaS)
pullbackShortOk = trendDnSmooth and bearBias and (pbDepthShort >= (pbMinATR - pbTol)) and (pbDepthShort <= (pbMaxATR + pbTol)) and (close < emaS)


var float lastSwingHigh = na
var float lastSwingLow  = na
var int lastSwingHighBar = na
var int lastSwingLowBar  = na
bool chochFastPresetEff = chochScalpPreset and not chochScalpSaferPreset
bool chochSaferPresetEff = chochScalpSaferPreset
int swingREff = (chochFastPresetEff or chochSaferPresetEff) ? math.max(1, swingR) : swingR
string breakoutSourceEff = (chochFastPresetEff or chochSaferPresetEff) ? "Wick" : breakoutSource
string chochSignalModeEff = chochFastPresetEff ? "Ping (Fast)" : chochSaferPresetEff ? "Ping+Verify" : chochSignalMode
ph = ta.pivothigh(high, swingL, swingREff)
pl = ta.pivotlow(low,  swingL, swingREff)
if not na(ph)
    lastSwingHigh := ph
    lastSwingHighBar := bar_index
if not na(pl)
    lastSwingLow := pl
    lastSwingLowBar := bar_index
if swingMaxAgeBars > 0
    if not na(lastSwingHighBar) and (bar_index - lastSwingHighBar > swingMaxAgeBars)
        lastSwingHigh := na
        lastSwingHighBar := na
    if not na(lastSwingLowBar) and (bar_index - lastSwingLowBar > swingMaxAgeBars)
        lastSwingLow := na
        lastSwingLowBar := na

bool breakHigh = false
bool breakLow  = false

bool _xoWick = ta.crossover(high, lastSwingHigh)
bool _xuWick = ta.crossunder(low, lastSwingLow)

if breakoutSourceEff == "Close"
    breakHigh := close > lastSwingHigh and close[1] <= lastSwingHigh
    breakLow  := close < lastSwingLow  and close[1] >= lastSwingLow
else // Wick
    if not na(lastSwingHigh)
        breakHigh := _xoWick
    if not na(lastSwingLow)
        breakLow  := _xuWick

breakoutLong  = not na(lastSwingHigh) and breakHigh
breakoutShort = not na(lastSwingLow)  and breakLow

bool sweepHigh = false
bool reclaimLow = false

bool cx_sweepHigh = ta.crossunder(low, lastSwingHigh)
bool cx_reclaimLow = ta.crossover(high, lastSwingLow)

if structureLogic == "SMC+Sweep" and not na(lastSwingHigh) and not na(lastSwingLow)
    // Sweep High (Bearish Reversal Pattern): Price crossed above High then fell back below
    if breakoutSourceEff == "Close"
        sweepHigh := close < lastSwingHigh and high > lastSwingHigh and close[1] > lastSwingHigh
        reclaimLow := close > lastSwingLow and low < lastSwingLow and close[1] < lastSwingLow
    else // Wick (Crossunder/Crossover Logic matches Reference Script)
        sweepHigh := cx_sweepHigh
        reclaimLow := cx_reclaimLow

// --- Market Structure State (BOS vs ChoCH) ---
var int structState = 0 // 0=Neutral, 1=Bullish, -1=Bearish
bool isChoCH_Long = false
bool isBOS_Long   = false
bool isChoCH_Short = false
bool isBOS_Short   = false
bool chochPingLong = false
bool chochPingShort = false
bool chochVerifyLong = false
bool chochVerifyShort = false

if structureLogic == "Standard"
    if breakoutLong
        chochPingLong := structState == -1
        if not chochPingLong
            isBOS_Long := true
        structState := 1

    if breakoutShort
        chochPingShort := structState == 1
        if not chochPingShort
            isBOS_Short := true
        structState := -1

else // SMC+Sweep (Standard Style)
    if breakoutLong
        chochPingLong := structState == -1
        if not chochPingLong
            isBOS_Long := true
        structState := 1

    if breakoutShort
        chochPingShort := structState == 1
        if not chochPingShort
            isBOS_Short := true
        structState := -1

    if reclaimLow
        chochPingLong := true

    if sweepHigh
        chochPingShort := true

chochVerifyLong := chochPingLong[1] and ((not na(lastSwingHigh) and close > lastSwingHigh) or (not na(lastSwingLow) and close > lastSwingLow))
chochVerifyShort := chochPingShort[1] and ((not na(lastSwingLow) and close < lastSwingLow) or (not na(lastSwingHigh) and close < lastSwingHigh))

isChoCH_Long := chochSignalModeEff == "Ping (Fast)" ? chochPingLong : chochSignalModeEff == "Verify (Safer)" ? chochVerifyLong : (chochPingLong or chochVerifyLong)
isChoCH_Short := chochSignalModeEff == "Ping (Fast)" ? chochPingShort : chochSignalModeEff == "Verify (Safer)" ? chochVerifyShort : (chochPingShort or chochVerifyShort)

// Risk model state
var float tpPx    = na
var float trailPx = na

// Calculate risk levels on entry; returns updated stop/tp/trail
f_set_risk_on_entry(isLong, entry, atrNow) =>
    // v6.3.0 Fix: Link Indicator Execution to Profile Inputs (Fast/Mid/Slow)
    [pFc, pK, pA, pH, pTp, pSl] = f_get_params(timeframe.period)
    float useStopMul = nz(pSl, stopATR) 
    float useTpMul   = nz(pTp, tpATR)

    float stopOut  = isLong ? (entry - useStopMul * atrNow) : (entry + useStopMul * atrNow)
    float tpOut    = isLong ? (entry + useTpMul   * atrNow) : (entry - useTpMul   * atrNow)
    float trailOut = na
    [stopOut, tpOut, trailOut]

// Update trailing stop; returns updated trail
f_update_trail(isLong, entry, atrNow, stopVal, trailVal) =>
    // activate trailing only after reaching +R
    denom = math.max(math.abs(entry - stopVal), PRICE_EPS)
    rNow = isLong ? ((close - entry) / denom) : ((entry - close) / denom)
    [_, dTrailEff] = f_dyn_sl_preset_vals(decayStopATR, trailATR)
    trailMulEff = dTrailEff
    float trailOut = trailVal
    if rNow >= trailAfterR
        float trailCandidate = isLong ? (close - trailMulEff * atrNow) : (close + trailMulEff * atrNow)
        trailOut := na(trailOut) ? trailCandidate : (isLong ? math.max(trailOut, trailCandidate) : math.min(trailOut, trailCandidate))
    trailOut

f_risk_exit_hit(isLong, stopVal, tpVal, trailVal) =>
    if not useAtrRisk or na(stopVal)
        [false, ""]
    else
        // User Request: Stop Loss on CLOSE only (ignore wicks)
        stopHit  = isLong ? (close <= stopVal) : (close >= stopVal)
        tpHit    = not na(tpVal) and (isLong ? (high >= tpVal)  : (low  <= tpVal))
        // Trailing Stop also on CLOSE
        trailHit = not na(trailVal) and (isLong ? (close <= trailVal) : (close >= trailVal))
        
        // Optimistic Exit Priority on Favorable Candles (TP wins if bar closed in profit)
        bool favorableClose = isLong ? (close > open) : (close < open)
        // If TP hit and bar looks strong, assume TP happened before any deep wick
        bool priorityTP = tpHit and favorableClose
        
        // standard: stop wins if both in same bar (unless optimistic priority)
        hit = priorityTP ? true : (stopHit or trailHit or tpHit)
        msg = priorityTP ? "TP" : stopHit ? "SL" : trailHit ? "Trail" : tpHit ? "TP" : ""
        [hit, msg]

// Fail-closed signal subconditions: any na => deny (== true coerces na to false)
fcGateLongSafe  = (fcGateLong == true)
fcGateShortSafe = (fcGateShort == true)
volOkSafe       = (volOk == true)
setOkLongSafe   = (setOkLong == true)
setOkShortSafe  = (setOkShort == true)
pullbackLongOkSafe  = (pullbackLongOk == true)
pullbackShortOkSafe = (pullbackShortOk == true)
touchEmaF_LongSafe  = (touchEmaF_Long == true)
touchEmaF_ShortSafe = (touchEmaF_Short == true)
crossClose_EmaF_upSafe   = (crossClose_EmaF_up == true)
crossClose_EmaF_downSafe = (crossClose_EmaF_down == true)
bullReversalSafe = (bullReversal == true)
bearReversalSafe = (bearReversal == true)
trendUpSafe      = (trendUp == true)
trendDnSafe      = (trendDn == true)
breakoutLongSafe  = (breakoutLong == true)
breakoutShortSafe = (breakoutShort == true)
trendFlipUpSafe   = (trendFlipUp == true)
trendFlipDownSafe = (trendFlipDown == true)
reclaimUpSafe     = (reclaimUp == true)
reclaimDownSafe   = (reclaimDown == true)

// Enhancement gates â€” all default to true when disabled
regSlopeLongOkSafe  = (regSlopeLongOk == true)
regSlopeShortOkSafe = (regSlopeShortOk == true)

// Combined signal enhancement filter (Soft-AND / Fail-Open)
// All these were previously "Safe" (na -> false). Now convert to Fail-Open (na -> true).
// Important: Liquidity, Momentum, USI should be primary drivers, so we keep `safe` checks only if they are critical.
// But per request: "Features should help when present, but fail-open when absent".
f_soft(bool x) => 
    // Fix for "na() expects float" error in strict contexts:
    // We check if the boolean is neither true nor false.
    (x == true) ? true : (x == false) ? false : true

enhLongOk  = f_soft(adxOk) and f_soft(rocLongOk) and f_soft(volEnsLongOk) and f_soft(preMomLongOk) and f_soft(emaAccelLongOk) and f_soft(vwapLongOk) and f_soft(regSlopeLongOk)
enhShortOk = f_soft(adxOk) and f_soft(rocShortOk) and f_soft(volEnsShortOk) and f_soft(preMomShortOk) and f_soft(emaAccelShortOk) and f_soft(vwapShortOk) and f_soft(regSlopeShortOk)

// Score Engine Helpers (Option C)
f_score_add(bool cond, int points) => cond ? points : 0
f_penalty(bool cond, int penalties) => cond ? penalties : 0

hybridLongTrigger  = touchEmaF_LongSafe  and (crossClose_EmaF_upSafe   or bullReversalSafe)
hybridShortTrigger = touchEmaF_ShortSafe and (crossClose_EmaF_downSafe or bearReversalSafe)

// Fetch probabilities for strict ChoCH filtering (Global Scope)
[pU, pF, pD, nBin_prob, total_prob] = f_get_rel_vals(entryFcTF)

// Deferred debug plots and probe label removed to cleanup user interface

// --- Global Recency Calculation (Safe Scope) ---
int barsSinceChoCH_L = ta.barssince(isChoCH_Long)
bool recentChoCH_L   = (not na(barsSinceChoCH_L)) and (barsSinceChoCH_L <= 12)

int barsSinceChoCH_S = ta.barssince(isChoCH_Short)
bool recentChoCH_S   = (not na(barsSinceChoCH_S)) and (barsSinceChoCH_S <= 12)

// Global Volume Ratio (Kept for Risk Decay)
float volRatioG = (not na(volume) and not na(volSma) and volSma > 0) ? volume / volSma : 0.0
bool hugeVolG   = volRatioG >= rescueVolMult

// Rescue Logic: Replaced Volume-only trigger with Price Impulse trigger (v6.2)
// User Intent: Prevent falling knife entries on huge bearish volume.
// Require "Considerable Price Increase" (Impulse Candle > 0.7 ATR). Lowered from 1.0 to catch valid signals.
float bodySize = math.abs(close - open)
bool isImpulse = bodySize > (atr * rescueImpulseATR)

bool allowRescueLong  = isImpulse and (close > open) and signalGateConfirmed and cooldownOkSafe
bool allowRescueShort = isImpulse and (close < open) and signalGateConfirmed and cooldownOkSafe

// Legacy support for debug label (OR logic)
allowRescue = (allowRescueLong or allowRescueShort)

// Debug label logic removed to cleanup user interface


// Signals (enhancement filters wired in)
bool rawBuySignal = false
bool rawShortSignal = false
bool isRevBuy   = false
bool isRevShort = false

// v6.2.7 Refactor: Named bypass variable for clarity
// v6.2.9: Added barstate.isconfirmed to prevent intra-bar evaluation (parity with allowEntry/allowRescue)
allowRevBypass = allowNeuralReversals and signalGateConfirmed and cooldownOkSafe and (isChoCH_Long or isChoCH_Short)

// v6.2.11: allowRevBypass enters this block even when pos != 0 so reversal
// signals are computed BEFORE the state machine. Phase 1 (COVER/EXIT) sets
// pos := 0, then Phase 2 can immediately use the pre-computed buySignal.

// SMC Liquidity Sweep Filter (v6.1.4) (Computed outside conditional scope to avoid barssince warning)
// Fix v6.2.27: Moved barssince calls out of the conditional block
bool isSweep_Bull = not na(lastSwingLow) and (low < lastSwingLow) and (close > lastSwingLow)
bool isSweep_Bear = not na(lastSwingHigh) and (high > lastSwingHigh) and (close < lastSwingHigh)
int barsSinceSweep_Bull = ta.barssince(isSweep_Bull)
int barsSinceSweep_Bear = ta.barssince(isSweep_Bear)

// [GLOBAL SCOPE HOIST] To support debug labels outside signal block
int scoreL = 0
int scoreS = 0
bool scoreBuy = false
bool scoreShort = false
bool baseEligible = false
bool chopRisk = false
bool isBreakout = false
bool revBuyGlobal = false
bool revShortGlobal = false
bool probOkGlobal = false
bool probOkGlobalS = false
bool hardLongProbOk = false
bool hardShortProbOk = false
bool scoreLongWin = false
bool scoreShortWin = false

if (pos == 0 and (allowEntry or allowRescue)) or allowRevBypass
    // Reversal Logic (Global â€” Applies to All Engines)
    // Refined to filter stale reversals (older than revRecencyBars) on low volume to prevent "fake" late entries
    bool revRecencyOkL = (not na(barsSinceChoCH_L)) and (barsSinceChoCH_L <= revRecencyBars or volRatioG >= rescueVolMult)
    bool revRecencyOkS = (not na(barsSinceChoCH_S)) and (barsSinceChoCH_S <= revRecencyBars or volRatioG >= rescueVolMult)

    bool sweepRecent_Bull = (not na(barsSinceSweep_Bull)) and (barsSinceSweep_Bull <= liqSweepLookback)
    bool sweepRecent_Bear = (not na(barsSinceSweep_Bear)) and (barsSinceSweep_Bear <= liqSweepLookback)
    
    // allowRescue (Volume > 1.5x) allows bypassing strict SMC Structure (Restored v6.2)
    // Updated to use allowable rescue Direction (Impulse)
    bool smcOkL = (not useLiqSweep) or sweepRecent_Bull or allowRescueLong
    bool smcOkS = (not useLiqSweep) or sweepRecent_Bear or allowRescueShort

    // Neural Reversal Gates (Global)
    bool impulseLong  = (isImpulse and (close > open)) or bullEngulf3
    bool impulseShort = (isImpulse and (close < open)) or bearEngulf3
    bool bypassRevLong  = inRevOpenWindowLong
    bool bypassRevShort = inRevOpenWindowShort
    hardLongProbOk := (not enforceGlobalProbFloor) or ((not na(pU)) and pU >= scoreMinProbLongEff)
    hardShortProbOk := (not enforceGlobalProbFloor) or ((not na(pD)) and pD >= scoreMinProbShortEff)
    float revBuyMinProbFloor = bypassRevLong ? 0.0 : 0.25
    float revShortMinProbFloor = bypassRevShort ? 0.0 : 0.25
    probOkGlobal    := (na(pU) or pU >= revBuyMinProbFloor) and (bypassRevLong  or ((pU >= revMinProb) or ((hugeVolG or bullEngulf3) and pU >= 0.25 and impulseLong)))
    probOkGlobalS   := (na(pD) or pD >= revShortMinProbFloor) and (bypassRevShort or ((pD >= revMinProb) or ((hugeVolG or bearEngulf3) and pD >= 0.25 and impulseShort)))
    revBuyGlobal    := allowNeuralReversals and ddOk and isChoCH_Long and revRecencyOkL and smcOkL and probOkGlobal and f_soft(volOk) and vwtLongEntryOk
    revShortGlobal  := allowNeuralReversals and ddOk and isChoCH_Short and revRecencyOkS and smcOkS and probOkGlobalS and f_soft(volOk) and vwtShortEntryOk

    // Export for debug
    isRevBuy   := revBuyGlobal
    isRevShort := revShortGlobal

    // Engine-specific signals only when standard entry is allowed (pos==0 + allowEntry or allowRescue).
    // When entered via allowRevBypass alone, only reversal injection below applies.
    bool standardEntryOk = (pos == 0) and (allowEntry or allowRescue)

    // Core Evidence (Soft Scoring â€” fail-open)
    bool liqOk_L = f_soft(volOk)
    bool liqOk_S = f_soft(volOk)
    bool momOk_L = f_soft(fcGateLong)
    bool momOk_S = f_soft(fcGateShort)
    bool engOk_L = f_soft(setOkLong)  and f_soft(pullbackLongOk)
    bool engOk_S = f_soft(setOkShort) and f_soft(pullbackShortOk)

    // --- OPTIMIZATION: DECOUPLED SCORING ---

    // 1. Calculate Regime Score (Prior)
    float regimeScoreL = 0.0
    float regimeScoreS = 0.0
    
    // Forecast als Soft-Faktor (Fail Open) - Clamped to act as a gentle bias
    if not na(pU)
        regimeScoreL += math.max(math.min((pU - 0.50) * 2.0, 0.4), -0.4) 
    
    // Fix: Use pD via explicit variable to avoid Flat-Bias (Anti-pU would treat Flat as Short)
    // Safe Fallback: If pD is na, use 0.0 (Neutral) to avoid polluting Score with NA or Flat-Bias.
    // (Old fallback carried risk of interpreting Warmup/Flat as Short)
    float rawShort = na(pD) ? 0.0 : (pD - 0.50)
    regimeScoreS += math.max(math.min(rawShort * 2.0, 0.4), -0.4)

    // 30m USI Gate als Soft-Faktor (Symmetric Dominance)
    if useUsi 
        if qRegimeBuy
            regimeScoreL += 1.0
            regimeScoreS -= 1.0 
        else if qRegimeSell
            regimeScoreL -= 1.0
            regimeScoreS += 1.0

    // --- SCORE ENGINE CALCULATION (Option C) ---
    // Calculates independent score-based entry signals.
    // Does not block on missing data (na -> 0).
    
    // 1. USI Evidence
    // Red (Line 5) Cross Logic
    // Buy: Red was below MinEnv, now crosses above MaxEnv (strongest) OR just crosses MaxEnv
    // Note: USI lines are already calculated globally as usiLine1..5
    // Re-accessing global scope variables:
    float _uMax = usiMaxEnv
    float _uMin = usiMinEnv
    // Cross Logic
    bool usiCrossUp   = _usiXUp
    bool usiCrossDown = _usiXDn
    // Bonus for "Was Below All" (Clean Sweep)
    bool usiSweepUp   = usiCrossUp and (usiLine5[1] < _uMin[1])
    bool usiSweepDown = usiCrossDown and (usiLine5[1] > _uMax[1])

    scoreL := 0
    scoreS := 0
    
    // USI Contribution
    if useUsi
        scoreL += f_score_add(usiCrossUp, wUsiEff) + f_score_add(usiSweepUp, (wUsiEff + 1) / 2)
        scoreS += f_score_add(usiCrossDown, wUsiEff) + f_score_add(usiSweepDown, (wUsiEff + 1) / 2)
        // Add residual state score if cross happened earlier (supports late entries)
        scoreL += f_score_add(usiBull and not usiCrossUp, (wUsiEff + 1) / 2)
        scoreS += f_score_add(usiBear and not usiCrossDown, (wUsiEff + 1) / 2)

    // 2. Liquidity Evidence (Sweep / Reclaim / ChoCH)
    // Long: reclaimUpSafe or isChoCH_Long
    scoreL += f_score_add(reclaimUpSafe, wLiquidityEff)
    scoreL += f_score_add(isChoCH_Long, wLiquidityEff)
    // Short: reclaimDownSafe or isChoCH_Short
    scoreS += f_score_add(reclaimDownSafe, wLiquidityEff)
    scoreS += f_score_add(isChoCH_Short, wLiquidityEff)

    // 3. Momentum Evidence
    // Long: rocLongOk, adxOk, hugeVolG
    scoreL += f_score_add(rocLongOk, wMomentumEff)
    scoreL += f_score_add(adxOk, (wMomentumEff + 1) / 2)
    scoreL += f_score_add(hugeVolG and (close > open), (wMomentumEff + 1) / 2)
    // Short
    scoreS += f_score_add(rocShortOk, wMomentumEff)
    scoreS += f_score_add(adxOk, (wMomentumEff + 1) / 2)
    scoreS += f_score_add(hugeVolG and (close < open), (wMomentumEff + 1) / 2)

    // 4. Trend Context
    scoreL += f_score_add(trendUpSafe, wTrendContextEff)
    scoreS += f_score_add(trendDnSafe, wTrendContextEff)

    // 5. Chop Penalty
    // Detect low-vol chop: ADX < 20 and ATR/Close < 0.5%
    // EXCEPTION: If we have impulse candle OR Engulfing (breakout energy), ignore the penalty!
    // ADDED: ChoCH and Reclaim are also valid breakouts structure-wise.
    isBreakout := isImpulse or hugeVolG or bullEngulf3 or bearEngulf3 or isChoCH_Long or isChoCH_Short or reclaimUpSafe or reclaimDownSafe
    bool isBreakoutL = isImpulse or hugeVolG or bullEngulf3 or isChoCH_Long or reclaimUpSafe
    bool isBreakoutS = isImpulse or hugeVolG or bearEngulf3 or isChoCH_Short or reclaimDownSafe
    bool isChopL = (not na(adxRaw) and adxRaw < 20) and (atr / math.max(close, PRICE_EPS) < 0.005) and not isBreakoutL
    bool isChopS = (not na(adxRaw) and adxRaw < 20) and (atr / math.max(close, PRICE_EPS) < 0.005) and not isBreakoutS
    chopRisk := isChopL or isChopS
    scoreL += f_penalty(isChopL, wChopPenaltyEff)
    scoreS += f_penalty(isChopS, wChopPenaltyEff)

    // 6. Engulfing Evidence (Pattern)
    scoreL += f_score_add(bullEngulf3, wEngulfingEff)
    scoreS += f_score_add(bearEngulf3, wEngulfingEff)

    // Final Decision
    // Base eligibility: Position 0, Allow Entry + Drawdown Check (ddOk)
    // ADDED: USI State Filter (Fail-safe)
    // If USI is enabled and trend override is active, Block Buys when Bear State, and Shorts when Bull State.
    bool usiBlockL = useUsi and useUsiTrendOverride and usiBearState
    bool usiBlockS = useUsi and useUsiTrendOverride and usiBullState
    
    baseEligible := (pos == 0) and ddOk and (allowEntry or allowRescue)
    bool scoreProbLongOk = (not scoreUseProbGateEff) or ((not na(pU)) and pU >= scoreMinProbLongEff)
    bool scoreProbShortOk = (not scoreUseProbGateEff) or ((not na(pD)) and pD >= scoreMinProbShortEff)
    bool scoreConfLongOk = (not scoreUseConfGateEff) or ((not na(confidence)) and confidence >= scoreMinConfLongEff)
    bool scoreConfShortOk = (not scoreUseConfGateEff) or ((not na(confidence)) and confidence >= scoreMinConfShortEff)

    scoreBuy   := baseEligible and scoreProbLongOk and scoreConfLongOk and (not usiBlockL) and (scoreL >= scoreThresholdLongEff) and vwtLongEntryOk
    scoreShort := baseEligible and enableShorts and scoreProbShortOk and scoreConfShortOk and (not usiBlockS) and (scoreS >= scoreThresholdShortEff) and vwtShortEntryOk

    // [MOVED] Debug Output relocated to end of script for accurate execution logging



    // 2. Veto Logic (Nur ECHTE Showstopper)
    bool isVetoL = false
    bool isVetoS = false
    
    // DD Risk Management (Immunity)
    if ddOk == false
        isVetoL := true 
        isVetoS := true
        
    // Forecast Veto (Only if Strong Headwind existing)
    // defined as: Low Prob AND Regime against us
    if (not na(pU) and pU < 0.30 and regimeScoreL < -0.5)
        isVetoL := true
    if (not na(pD) and pD < 0.30 and regimeScoreS < -0.5)
        isVetoS := true

    // 3. Adaptive Triggering (Engine: Hybrid)
    // If Engine is Hybrid, we use the Soft Context 
    
    bool chochVolOk = (not chochReqVol) or volOkSafe

    if engine == "Hybrid"
        // Hybrid: Trigger (EMA Touch) + Core Evidence + Enhancements (Soft)
        // Removed hard "Safe" walls.
        
        bool validTrendEntryL = standardEntryOk and gateLongNow and liqOk_L and momOk_L and engOk_L and enhLongOk and hybridLongTrigger
        
        // Context: Good Regime allows entry. Bad Regime requires Volume OR Engulfing.
        bool contextL = (regimeScoreL > 0) or (f_soft(volOk) and f_soft(engulfLongOk))

        
        // Final Signal
        gateBuy   = validTrendEntryL and contextL and not isVetoL
        
        // ChoCH Filter (Strict) - Kept strict for Reversals only as it is distinctive logic
        isChoCH_Entry = gateBuy and (structState == -1 or isChoCH_Long) 
        // Fail open: if prob model missing, allow (unless explicitly low)
        chochFilterOk = (not isChoCH_Entry) or ((na(pU) or pU >= chochMinProbEff) and chochVolOk)
        
        buySignal   := gateBuy and chochFilterOk
        
        
        bool validTrendEntryS = standardEntryOk and enableShorts and gateShortNow and liqOk_S and momOk_S and engOk_S and enhShortOk and hybridShortTrigger
        bool contextS = (regimeScoreS > 0) or (f_soft(volOk) and f_soft(engulfShortOk))
        
        gateShort = validTrendEntryS and contextS and not isVetoS
        
        isChoCH_ShortEntry = gateShort and (structState == 1 or isChoCH_Short)
        chochShortFilterOk = (not isChoCH_ShortEntry) or ((na(pD) or pD >= chochMinProbEff) and chochVolOk)
        
        shortSignal := gateShort and chochShortFilterOk

    else if engine == "Breakout"

        // Base
        baseBuy = standardEntryOk and gateLongNow and liqOk_L and momOk_L and trendUpSafe and enhLongOk and breakoutLongSafe and f_soft(engulfLongOk)
        
        isChoCH_Entry = baseBuy and (structState == -1 or isChoCH_Long)
        chochFilterOk = (not isChoCH_Entry) or ((na(pU) or pU >= chochMinProbEff) and chochVolOk)
        
        buySignal   := baseBuy and chochFilterOk
        
        baseShort = standardEntryOk and enableShorts and gateShortNow and liqOk_S and momOk_S and trendDnSafe and enhShortOk and breakoutShortSafe and f_soft(engulfShortOk)
        isChoCH_ShortEntry = baseShort and (structState == 1 or isChoCH_Short)
        chochShortFilterOk = (not isChoCH_ShortEntry) or ((na(pD) or pD >= chochMinProbEff) and chochVolOk)
        
        shortSignal := baseShort and chochShortFilterOk
        
    else if engine == "Trend+Pullback"
        buySignal   := standardEntryOk and gateLongNow and enhLongOk  and (trendFlipUpSafe or reclaimUpSafe) and f_soft(engulfLongOk)
        shortSignal := standardEntryOk and enableShorts and gateShortNow and enhShortOk and (trendFlipDownSafe or reclaimDownSafe) and f_soft(engulfShortOk)
    else // Loose
        buySignal   := standardEntryOk and gateLongNow and crossClose_EmaF_upSafe and enhLongOk and f_soft(engulfLongOk)
        shortSignal := standardEntryOk and enableShorts and gateShortNow and crossClose_EmaF_downSafe and enhShortOk and f_soft(engulfShortOk)


    // Option C: Score Engine Integration (hybrid)
    // Score can inject entries, but active chop state still hard-vetoes entries when penalty is enabled.
    if useScoreEntriesEff
        bool scoreCtxLongOk  = (not scoreRequireDirectionalContextEff) or trendUpSafe or usiBull
        bool scoreCtxShortOk = (not scoreRequireDirectionalContextEff) or trendDnSafe or usiBear
        bool scoreChopVeto = scoreChopHardVetoEff and chopRisk and (wChopPenaltyEff < 0)
        scoreLongWin := (scoreBuy and scoreCtxLongOk) and not scoreChopVeto
        scoreShortWin := (scoreShort and scoreCtxShortOk) and not scoreChopVeto
        // Score-based precedence: when score path fires, it overrides engine path.
        if scoreLongWin
            buySignal := true
            shortSignal := false
        else if scoreShortWin
            shortSignal := true
            buySignal := false

    // Unified Neural Reversal injection (all engines, including Loose)
    if allowNeuralReversals
        buySignal   := buySignal   or revBuyGlobal
        shortSignal := shortSignal or revShortGlobal

    // Score-vs-reversal conflict resolution keeps score precedence when
    // opposite-side reversal is injected on the same bar.
    if scoreLongWin and revShortGlobal
        shortSignal := false
    if scoreShortWin and revBuyGlobal
        buySignal := false

    // Global probability floors: block BUY/SHORT paths across all entry paths.
    buySignal := buySignal and hardLongProbOk
    shortSignal := shortSignal and hardShortProbOk

    // Conflict resolution: if both signals fire, cancel both (safety-first)
    if buySignal and shortSignal
        buySignal := false
        shortSignal := false

    // Capture raw preview signals AFTER conflict resolution so realtime
    // preview alerts cannot emit contradictory BUY+SHORT pulses on the same bar.
    rawBuySignal := buySignal
    rawShortSignal := shortSignal

preBuyNow = false
preShortNow = false
float preGapLong  = na   // distance to trigger (points)
float preGapShort = na
if pos == 0 and allowEntry
    float preDist = preWarnDistATR * atr
    distOk = (not na(preDist)) and (preDist > 0) and (not na(atr)) and (atr > 0)
    preSetOkLong = (not requireSET) or (preSetPulseOnly ? setLongPulse : setLong)
    preSetOkShort = (not requireSET) or (preSetPulseOnly ? setShortPulse : setShort)

    if engine == "Hybrid"
        // Hybrid: distance = how far close is below emaF
        preGapLong  := (not na(emaF)) ? math.max(0.0, emaF - close) : na
        preGapShort := (not na(emaF)) ? math.max(0.0, close - emaF) : na
        preBuyNow := gateLongNow and fcGateLongSafe and volOkSafe and preSetOkLong and pullbackLongOkSafe and touchEmaF_LongSafe and not (crossClose_EmaF_upSafe or bullReversalSafe) and not usiBear
        preShortNow := enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and preSetOkShort and pullbackShortOkSafe and touchEmaF_ShortSafe and not (crossClose_EmaF_downSafe or bearReversalSafe) and not usiBull
    else if engine == "Breakout"
        nearLong = distOk and (not na(lastSwingHigh)) and (close <= lastSwingHigh) and ((lastSwingHigh - close) <= preDist)
        nearShort = distOk and (not na(lastSwingLow)) and (close >= lastSwingLow) and ((close - lastSwingLow) <= preDist)
        preGapLong  := (not na(lastSwingHigh)) ? math.max(0.0, lastSwingHigh - close) : na
        preGapShort := (not na(lastSwingLow))  ? math.max(0.0, close - lastSwingLow)  : na
        preBuyNow := gateLongNow and fcGateLongSafe and volOkSafe and trendUpSafe and nearLong and not breakoutLongSafe and not usiBear
        preShortNow := enableShorts and gateShortNow and fcGateShortSafe and volOkSafe and trendDnSafe and nearShort and not breakoutShortSafe and not usiBull
    else if engine == "Trend+Pullback"
        nearFlipUp = distOk and (not na(emaF)) and (not na(emaS)) and (emaF < emaS) and ((emaS - emaF) <= preDist)
        nearFlipDown = distOk and (not na(emaF)) and (not na(emaS)) and (emaF > emaS) and ((emaF - emaS) <= preDist)
        nearReclaimUp = distOk and (not na(emaF)) and (bullBias == true) and (close < emaF) and ((emaF - close) <= preDist)
        nearReclaimDown = distOk and (not na(emaF)) and (bearBias == true) and (close > emaF) and ((close - emaF) <= preDist)
        preGapLong  := nearFlipUp ? (emaS - emaF) : nearReclaimUp ? (emaF - close) : na
        preGapShort := nearFlipDown ? (emaF - emaS) : nearReclaimDown ? (close - emaF) : na
        preBuyNow := gateLongNow and (nearFlipUp or nearReclaimUp) and not (trendFlipUpSafe or reclaimUpSafe) and not usiBear
        preShortNow := enableShorts and gateShortNow and (nearFlipDown or nearReclaimDown) and not (trendFlipDownSafe or reclaimDownSafe) and not usiBull
    else // Loose
        nearEmaFUp = distOk and (not na(emaF)) and (close < emaF) and ((emaF - close) <= preDist)
        nearEmaFDown = distOk and (not na(emaF)) and (close > emaF) and ((close - emaF) <= preDist)
        preGapLong  := nearEmaFUp  ? (emaF - close) : na
        preGapShort := nearEmaFDown ? (close - emaF) : na
        preBuyNow := gateLongNow and nearEmaFUp and not crossClose_EmaF_upSafe and not usiBear
        preShortNow := enableShorts and gateShortNow and nearEmaFDown and not crossClose_EmaF_downSafe and not usiBull

preBuyPrev = (preBuyNow[1] == true)
preShortPrev = (preShortNow[1] == true)
preBuyPulse = showPreEntryLabels and preBuyNow and not preBuyPrev
preShortPulse = showPreEntryLabels and preShortNow and not preShortPrev

// PRE-BUY / PRE-SHORT distance in ATR units (0.00 = at trigger)
float preGapATR_L = (not na(preGapLong)  and not na(atr) and atr > 0) ? (preGapLong  / atr) : na
float preGapATR_S = (not na(preGapShort) and not na(atr) and atr > 0) ? (preGapShort / atr) : na

var int barsSinceEntry = 0
if pos != pos[1] and pos != 0
    barsSinceEntry := 0
else if pos != 0
    barsSinceEntry += 1
else
    barsSinceEntry := 0

bool canStructExit = (barsSinceEntry >= exitGraceBars)
bool canChochExit = (barsSinceEntry >= math.min(chochGraceBars, exitGraceBars))

string tempExitReason = ""

if useAtrRisk and useRiskDecay and barsSinceEntry <= decayBars and not hugeVolG
    float w   = math.min(1.0, float(barsSinceEntry) / float(decayBars))
    [dFc, dK, dA, dH, dTp, dSl] = f_get_params(timeframe.period)
    float baseStop = nz(dSl, stopATR) 
    float baseTp   = nz(dTp, tpATR)
    
    float cStopM = math.max(0.1, baseStop + (dynamicDecayStopATREff - baseStop) * w)
    float cTpM   = math.max(0.1, baseTp   + (decayTpATR   - baseTp)   * w)
    
    if pos == 1 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
        targetStop = entryPrice - (cStopM * entryAtr)
        targetTp   = entryPrice + (cTpM   * entryAtr)

        stopPx := math.max(stopPx, targetStop)
        if not useInfiniteTP
            tpPx   := math.min(tpPx, targetTp)
            
    else if pos == -1 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
        targetStop = entryPrice + (cStopM * entryAtr)
        targetTp   = entryPrice - (cTpM   * entryAtr)
        
        stopPx := math.min(stopPx, targetStop)
        if not useInfiniteTP
            tpPx   := math.max(tpPx, targetTp)

if useAtrRisk and useDynamicTpExpansion and not useInfiniteTP and pos != 0 and not na(tpPx) and not na(entryPrice) and not na(entryAtr)
    [dtFc, dtK, dtA, dtH, dtTp, dtSl] = f_get_params(timeframe.period)
    float initRiskAbs = math.max(PRICE_EPS, nz(dtSl, stopATR) * entryAtr)
    float runRNow = pos == 1 ? ((close - entryPrice) / initRiskAbs) : ((entryPrice - close) / initRiskAbs)
    bool dynTpTrendOk = pos == 1 ? trendUpSafe : trendDnSafe
    bool dynTpConfOk = na(confidence) ? false : confidence >= dynamicTpMinConf
    bool dynTpGateOk = (not dynamicTpRequireTrend or dynTpTrendOk) and (not dynamicTpRequireConf or dynTpConfOk)

    if runRNow >= dynamicTpKickInREff and dynTpGateOk
        float extraAtr = math.min(dynamicTpMaxAddATREff, (runRNow - dynamicTpKickInREff) * dynamicTpAddATRPerREff)
        float targetTpMul = math.max(0.1, nz(dtTp, tpATR) + extraAtr)
        float dynamicTpPx = pos == 1 ? (entryPrice + targetTpMul * entryAtr) : (entryPrice - targetTpMul * entryAtr)
        tpPx := pos == 1 ? math.max(tpPx, dynamicTpPx) : math.min(tpPx, dynamicTpPx)

if useAtrRisk and useDynamicSlProfile and pos != 0 and not na(stopPx) and not na(entryPrice) and not na(entryAtr)
    [dsFc, dsK, dsA, dsH, dsTp, dsSl] = f_get_params(timeframe.period)
    float baseSlMul = nz(dsSl, stopATR)
    float initRiskAbs = math.max(PRICE_EPS, baseSlMul * entryAtr)
    float runRNow = pos == 1 ? ((close - entryPrice) / initRiskAbs) : ((entryPrice - close) / initRiskAbs)
    bool dynSlTrendOk = pos == 1 ? trendUpSafe : trendDnSafe
    bool dynSlConfOk = na(confidence) ? false : confidence >= dynamicSlMinConf
    bool dynSlGateOk = (not dynamicSlRequireTrend or dynSlTrendOk) and (not dynamicSlRequireConf or dynSlConfOk)

    if dynSlGateOk
        float widenAtr = 0.0
        if dynamicSlWidenUntilR > 0 and runRNow >= 0 and runRNow < dynamicSlWidenUntilR
            widenAtr := dynamicSlMaxWidenATR * (1.0 - (runRNow / dynamicSlWidenUntilR))
        float tightenAtr = runRNow >= dynamicSlTightenStartR ? math.min(dynamicSlMaxTightenATR, (runRNow - dynamicSlTightenStartR) * dynamicSlTightenATRPerR) : 0.0
        float netAdjAtr = widenAtr - tightenAtr
        float targetSlMul = math.max(0.1, baseSlMul + netAdjAtr)
        float dynamicStopPx = pos == 1 ? (entryPrice - targetSlMul * entryAtr) : (entryPrice + targetSlMul * entryAtr)

        bool allowWidenNow = na(trailPx)
        if pos == 1
            if dynamicStopPx > stopPx
                stopPx := dynamicStopPx
            else if dynamicStopPx < stopPx and allowWidenNow
                stopPx := dynamicStopPx
        else
            if dynamicStopPx < stopPx
                stopPx := dynamicStopPx
            else if dynamicStopPx > stopPx and allowWidenNow
                stopPx := dynamicStopPx

if pos == 1 and allowExitLong
    if useAtrRisk
        trailPx := f_update_trail(true, entryPrice, atr, stopPx, trailPx)
    [rHit, rMsg] = f_risk_exit_hit(true, stopPx, tpPx, trailPx)

    bool usiExitHit = _usiXDn

    bool engExitHit = bearEngulf3
    bool riskExitHit = rHit
    
    bool riskExceptionHit = riskExitHit and (rMsg == "SL" or rMsg == "TP")
    bool holdExceptionsOnly = entryOnlyExitHoldActive
    exitSignal := holdExceptionsOnly ? (riskExceptionHit or engExitHit) : (riskExitHit or usiExitHit or engExitHit or staleExit)
    
    if exitSignal

        string reason = riskExitHit ? rMsg : "USI-Flip"
        if usiExitHit
            reason := reason + " (Red:" + str.tostring(usiLine5, "#.##") + " < Env:" + str.tostring(usiMinEnv, "#.##") + ")"
        if engExitHit and not rHit
            reason := "Engulfing"
        tempExitReason := reason

if pos == -1 and allowExitShort
    if useAtrRisk
        trailPx := f_update_trail(false, entryPrice, atr, stopPx, trailPx)
    [rHit, rMsg] = f_risk_exit_hit(false, stopPx, tpPx, trailPx)
    
    bool usiExitHit = _usiXUp

    bool engExitHit = bullEngulf3
    bool riskExitHit = rHit

    bool riskExceptionHit = riskExitHit and (rMsg == "SL" or rMsg == "TP")
    bool holdExceptionsOnly = entryOnlyExitHoldActive
    coverSignal := holdExceptionsOnly ? (riskExceptionHit or engExitHit) : (riskExitHit or usiExitHit or engExitHit or staleExit)
    
    if coverSignal

        string reason = riskExitHit ? rMsg : "USI-Flip"
        if usiExitHit
            reason := reason + " (Red:" + str.tostring(usiLine5, "#.##") + " > Env:" + str.tostring(usiMaxEnv, "#.##") + ")"
        if engExitHit and not rHit
            reason := "Engulfing"
        tempExitReason := reason


didBuy   := false
didShort := false
didExit  := false
didCover := false

var string lastExitReason = ""

// -- PLOT TREND LINES (For visualization validity) --
plot(emaF, "EMA Fast", color=color.new(color.yellow, 0))
plot(emaS, "EMA Slow", color=color.new(color.purple, 0))
consolidationDotColor = (useUsi and usiStackDir == -1) ? color.new(color.red, 10) : color.new(color.orange, 0)
plot(sidewaysVisual ? emaF : na, "Consolidation dots", style=plot.style_circles, linewidth=4, color=consolidationDotColor)

var bool lastEntryWasRev = false
var int  lastBuyBarIdx  = na
var int  lastShortBarIdx = na
bool _wasRevEntry = lastEntryWasRev
if barstate.isconfirmed
    // --- Phase 1: Process exits ---
    if exitSignal and pos == 1
        didExit := true
        lastExitReason := tempExitReason
        pos := 0
        entryPrice := na
        stopPx := na
        tpPx := na
        enTime     := time
        trailPx := na
        if cooldownTriggersEff == "ExitsOnly" or cooldownTriggersEff == "AllSignals"
            lastSignalBar := bar_index
            lastSignalTime := time
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        didCover := true
        lastExitReason := tempExitReason
        pos := 0
        entryPrice := na
        stopPx := na
        tpPx := na
        trailPx := na
        if cooldownTriggersEff == "ExitsOnly" or cooldownTriggersEff == "AllSignals"
            lastSignalBar := bar_index
            lastSignalTime := time
        lastSig := "COVER"

    // --- Phase 2: Process entries (including same-bar reversal after exit) ---
    if buySignal and pos == 0 and (allowSameBarBuyAfterCover or not didCover) and not didExit
        didBuy := true
        pos := 1
        entryPrice := close
        entryAtr   := atr
        enTime     := time
        enBar   := bar_index
        barsSinceEntry := 0
        lastEntryWasRev := isRevBuy
        lastBuyBarIdx := bar_index
        if useAtrRisk
            [newStop, newTp, newTrail] = f_set_risk_on_entry(true, entryPrice, atr)
            stopPx  := newStop
            tpPx    := useInfiniteTP ? na : newTp
            trailPx := newTrail
        if cooldownTriggersEff == "AllSignals" or cooldownTriggersEff == "EntriesOnly"
            lastSignalBar  := bar_index
            lastSignalTime := time
        lastSig := "BUY"
    else if shortSignal and pos == 0 and (allowSameBarShortAfterExit or not didExit) and not didCover
        didShort := true
        pos := -1
        entryPrice := close
        entryAtr   := atr
        enTime     := time
        enBar   := bar_index
        barsSinceEntry := 0
        lastEntryWasRev := isRevShort
        lastShortBarIdx := bar_index
        if useAtrRisk
            [sStop, sTp, sTrail] = f_set_risk_on_entry(false, entryPrice, atr)
            stopPx  := sStop
            tpPx    := useInfiniteTP ? na : sTp
            trailPx := sTrail
        if cooldownTriggersEff == "AllSignals" or cooldownTriggersEff == "EntriesOnly"
            lastSignalBar  := bar_index
            lastSignalTime := time
        lastSig := "SHORT"

buyEvent   = didBuy
shortEvent = didShort
exitEvent  = didExit
coverEvent = didCover

varip bool rtBuyPreviewSent = false
varip bool rtShortPreviewSent = false
varip bool rtExitPreviewSent = false
varip bool rtCoverPreviewSent = false
varip bool rtPreBuyPreviewSent = false
varip bool rtPreShortPreviewSent = false

if barstate.isnew
    rtBuyPreviewSent := false
    rtShortPreviewSent := false
    rtExitPreviewSent := false
    rtCoverPreviewSent := false
    rtPreBuyPreviewSent := false
    rtPreShortPreviewSent := false

bool buyPreviewPosOk = (pos == 0) or (pos == -1 and coverSignal and allowSameBarBuyAfterCover)
bool shortPreviewPosOk = (pos == 0) or (pos == 1 and exitSignal and allowSameBarShortAfterExit)
buyPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and rawBuySignal and buyPreviewPosOk and not rtBuyPreviewSent
shortPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and rawShortSignal and shortPreviewPosOk and not rtShortPreviewSent
exitPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and exitSignal and pos == 1 and not rtExitPreviewSent
coverPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and coverSignal and pos == -1 and not rtCoverPreviewSent
preBuyPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and preBuyNow and not rtPreBuyPreviewSent
preShortPreviewPulse = (not signalOnCloseOnly) and barstate.isrealtime and preShortNow and not rtPreShortPreviewSent

if buyPreviewPulse
    rtBuyPreviewSent := true
if shortPreviewPulse
    rtShortPreviewSent := true
if exitPreviewPulse
    rtExitPreviewSent := true
if coverPreviewPulse
    rtCoverPreviewSent := true
if preBuyPreviewPulse
    rtPreBuyPreviewSent := true
if preShortPreviewPulse
    rtPreShortPreviewSent := true

buyEventLive = buyEvent or buyPreviewPulse
shortEventLive = shortEvent or shortPreviewPulse
exitEventLive = exitEvent or exitPreviewPulse
coverEventLive = coverEvent or coverPreviewPulse
preBuyEventLive = preBuyPulse or preBuyPreviewPulse
preShortEventLive = preShortPulse or preShortPreviewPulse
revBuyEventLive = (buyEvent and isRevBuy) or (buyPreviewPulse and isRevBuy)
revShortEventLive = (shortEvent and isRevShort) or (shortPreviewPulse and isRevShort)

strictAtrRankVis = f_pct_rank(atr / math.max(close, PRICE_EPS), strictAdaptiveLen)
strictMtfMarginEffVis = useAdaptiveStrictMargin ? f_clamp(strictMtfMargin + ((strictAtrRankVis - 0.5) * 2.0 * strictAdaptiveRange), 0.0, 0.20) : strictMtfMargin
strictSuppressByOpenWindow = openWindowBypassEntries and inRevOpenWindow
strictAlertsEnabledVis = not strictSuppressByOpenWindow
strictMtfLongOkVis = (not useMtfConfirm) or ((mtfScore > (SCORE_NEUTRAL_BAND + strictMtfMarginEffVis)) and (mtfScore[1] > (SCORE_NEUTRAL_BAND + strictMtfMarginEffVis)))
strictMtfShortOkVis = (not useMtfConfirm) or ((mtfScore < -(SCORE_NEUTRAL_BAND + strictMtfMarginEffVis)) and (mtfScore[1] < -(SCORE_NEUTRAL_BAND + strictMtfMarginEffVis)))
strictChochLongOkVis = (not isRevBuy[1]) or ((not na(barsSinceChoCH_L)) and (barsSinceChoCH_L <= strictChochConfirmBars) and not isChoCH_Short)
strictChochShortOkVis = (not isRevShort[1]) or ((not na(barsSinceChoCH_S)) and (barsSinceChoCH_S <= strictChochConfirmBars) and not isChoCH_Long)
strictAtrRank = strictAtrRankVis
strictMtfMarginEff = strictMtfMarginEffVis
strictMtfLongOk = strictMtfLongOkVis
strictMtfShortOk = strictMtfShortOkVis
strictChochLongOk = strictChochLongOkVis
strictChochShortOk = strictChochShortOkVis
strictBuyConfirmed = strictAlertsEnabledVis and barstate.isconfirmed and buyEvent[1] and strictMtfLongOkVis and strictChochLongOkVis
strictShortConfirmed = strictAlertsEnabledVis and barstate.isconfirmed and shortEvent[1] and strictMtfShortOkVis and strictChochShortOkVis

f_safe_label_text(txt) =>
    _len = str.length(txt)
    _max = 120
    _len > _max ? str.substring(txt, 0, _max) + "â€¦" : txt

var label[] _preLabels = array.new_label(0)
MAX_PRE_LABELS = 100

f_pre_label(x, y, txt, sty, txtCol, bgCol) =>
    lbl = label.new(x, y, f_safe_label_text(txt), style=sty, textcolor=txtCol, color=bgCol, size=size.small)
    array.push(_preLabels, lbl)
    if array.size(_preLabels) > MAX_PRE_LABELS
        label.delete(array.shift(_preLabels))

if preBuyEventLive
    string _gapTxt = not na(preGapATR_L) ? str.tostring(preGapATR_L, "#.##") + " ATR" : "â€”"
    string _pTxt   = not na(pU) ? str.tostring(pU * 100, "#.0") + "%" : "n/a"
    string _cTxt   = str.tostring(confidence * 100.0, "#.0") + "%"
    f_pre_label(bar_index, low, "PRE-BUY\nGap: " + _gapTxt + "\npU: " + _pTxt + "\nConf: " + _cTxt, label.style_label_up, color.black, color.new(color.yellow, 0))

if preShortEventLive
    string _gapTxt = not na(preGapATR_S) ? str.tostring(preGapATR_S, "#.##") + " ATR" : "â€”"
    string _pTxt   = not na(pD) ? str.tostring(pD * 100, "#.0") + "%" : "n/a"
    string _cTxt   = str.tostring(confidence * 100.0, "#.0") + "%"
    f_pre_label(bar_index, high, "PRE-SHORT\nGap: " + _gapTxt + "\npD: " + _pTxt + "\nConf: " + _cTxt, label.style_label_down, color.black, color.new(color.orange, 0))

labelRevBuy   = buyEvent and isRevBuy
labelRevShort = shortEvent and isRevShort
labelBuy      = buyEvent and not isRevBuy
labelShort    = shortEvent and not isRevShort
labelRevBuy   := labelRevBuy or (buyPreviewPulse and isRevBuy)
labelRevShort := labelRevShort or (shortPreviewPulse and isRevShort)
labelBuy      := labelBuy or (buyPreviewPulse and not isRevBuy)
labelShort    := labelShort or (shortPreviewPulse and not isRevShort)

labelChoCH_L = useStructureTags and isChoCH_Long  and not labelRevBuy    // v6.2.14: suppress on REV-BUY bar
labelChoCH_S = useStructureTags and isChoCH_Short and not labelRevShort  // v6.2.14: suppress on REV-SHORT bar
labelBOS_L = useStructureTags and isBOS_Long
labelBOS_S = useStructureTags and isBOS_Short

plotchar(showChochPing and chochPingLong, title="ChoCH Ping (Long)", char="?", location=location.belowbar, color=color.new(color.yellow, 0), size=size.tiny)
plotchar(showChochPing and chochPingShort, title="ChoCH Ping (Short)", char="?", location=location.abovebar, color=color.new(color.yellow, 0), size=size.tiny)

plotshape(labelChoCH_L, title="ChoCH (Long)", style=shape.labelup,   location=location.belowbar, size=size.small, text="ChoCH", textcolor=color.white, color=color.new(color.purple, 0))
plotshape(labelChoCH_S, title="ChoCH (Short)", style=shape.labeldown, location=location.abovebar, size=size.small, text="ChoCH", textcolor=color.white, color=color.new(color.maroon, 0))
plotshape(labelBOS_L, title="BOS (Long)", style=shape.labelup, location=location.belowbar, size=size.tiny, text="BOS", textcolor=color.white, color=color.new(color.green, 0))
plotshape(labelBOS_S, title="BOS (Short)", style=shape.labeldown, location=location.abovebar, size=size.tiny, text="BOS", textcolor=color.white, color=color.new(color.red, 0))

labelExit  = exitEventLive
labelCover = coverEventLive

entryPxPrev = entryPrice[1]


var label[] _entryLabels = array.new_label(0)
MAX_ENTRY_LABELS = 150

f_entry_label(x, y, txt, sty, txtCol, bgCol) =>
    lbl = label.new(x, y, f_safe_label_text(txt), style=sty, textcolor=txtCol, color=bgCol)
    array.push(_entryLabels, lbl)
    if array.size(_entryLabels) > MAX_ENTRY_LABELS
        label.delete(array.shift(_entryLabels))

string _probTxt = not na(pU) ? str.tostring(pU * 100, "#.0") + "%" : "n/a"
string _probTxtD = not na(pD) ? str.tostring(pD * 100, "#.0") + "%" : "n/a"
string _confTxt = str.tostring(confidence * 100.0, "#.0") + "%"
string _revBuyBase = "REV-BUY\npU: " + _probTxt + "\nConf: " + _confTxt
string _revShortBase = "REV-SHORT\npD: " + _probTxtD + "\nConf: " + _confTxt

string _stdBuyTxt = "BUY\npU: " + _probTxt + "\nConf: " + _confTxt
string _stdShortTxt = "SHORT\npD: " + _probTxtD + "\nConf: " + _confTxt

if showLongLabels and labelRevBuy
    f_entry_label(bar_index, low, _revBuyBase, label.style_label_up, color.black, color.new(color.aqua, 0))
if showShortLabels and labelRevShort
    f_entry_label(bar_index, high, _revShortBase, label.style_label_down, color.black, color.new(color.fuchsia, 0))
if showLongLabels and labelBuy
    f_entry_label(bar_index, low, _stdBuyTxt, label.style_label_up, color.white, color.new(color.green, 0))
if showShortLabels and labelShort
    f_entry_label(bar_index, high, _stdShortTxt, label.style_label_down, color.white, color.new(color.red, 0))

var label[] _exitLabels = array.new_label(0)
MAX_EXIT_LABELS = 250

f_exit_label(x, y, txt, sty, txtCol, bgCol) =>
    lbl = label.new(x, y, f_safe_label_text(txt), style=sty, textcolor=txtCol, color=bgCol)
    array.push(_exitLabels, lbl)
    if array.size(_exitLabels) > MAX_EXIT_LABELS
        label.delete(array.shift(_exitLabels))

if showLongLabels and labelExit
    string entryTag  = _wasRevEntry ? " â† REV-BUY" : " â† BUY"
    string exitSuffix = didShort ? " â†’ SHORT" : ""
    int _buyAgo = na(lastBuyBarIdx) ? 0 : (bar_index - lastBuyBarIdx)
    string buyAgoTxt = " (" + str.tostring(_buyAgo) + " bars ago)"
    bool isExitRev = didShort
    val = isExitRev ? low : (labelPriceMode == "Entry Price" ? (na(entryPxPrev) ? close : entryPxPrev) : labelPriceMode == "Close" ? close : high)
    exitSty = isExitRev ? label.style_label_up : label.style_label_down
    f_exit_label(bar_index, val, "EXIT" + entryTag + "\n" + buyAgoTxt + exitSuffix + "\n" + lastExitReason + "\nHeld " + str.tostring(barsSinceEntry) + " bars", exitSty, color.white, color.new(color.red, 0))

if showShortLabels and labelCover
    string entryTag  = _wasRevEntry ? " â† REV-SHORT" : " â† SHORT"
    string coverSuffix = didBuy ? " â†’ BUY" : ""
    int _shortAgo = na(lastShortBarIdx) ? 0 : (bar_index - lastShortBarIdx)
    string shortAgoTxt = " (" + str.tostring(_shortAgo) + " bars ago)"
    bool isReversal = didBuy
    val = isReversal ? high : (labelPriceMode == "Entry Price" ? (na(entryPxPrev) ? close : entryPxPrev) : labelPriceMode == "Close" ? close : low)
    labelSty = isReversal ? label.style_label_down : label.style_label_up
    f_exit_label(bar_index, val, "COVER" + entryTag + "\n" + shortAgoTxt + coverSuffix + "\n" + lastExitReason + "\nHeld " + str.tostring(barsSinceEntry) + " bars", labelSty, color.white, color.new(color.green, 0))

plot(useAtrRisk and pos == 1 ? stopPx : na,  title="Stop (Long)",  linewidth=1, color=color.new(color.red, 0))
plot(useAtrRisk and not useInfiniteTP and pos == 1 ? tpPx   : na,  title="TP (Long)",    linewidth=1, color=color.new(color.green, 0))
plot(useAtrRisk and pos == 1 ? trailPx: na,  title="Trail (Long)", linewidth=1, color=color.new(color.orange, 0))

plot(useAtrRisk and pos == -1 ? stopPx : na, title="Stop (Short)", linewidth=1, color=color.new(color.red, 0))
plot(useAtrRisk and not useInfiniteTP and pos == -1 ? tpPx   : na, title="TP (Short)",   linewidth=1, color=color.new(color.green, 0))
plot(useAtrRisk and pos == -1 ? trailPx: na, title="Trail (Short)",linewidth=1, color=color.new(color.orange, 0))

barcolor(na)
alertcondition(bullEngulf3, title="Bullish Engulfing (3 prior opposite)", message="SkippALGO Bullish Engulfing (3 prior bearish) | {{ticker}} @ {{close}} | {{time}}")
alertcondition(bearEngulf3, title="Bearish Engulfing (3 prior opposite)", message="SkippALGO Bearish Engulfing (3 prior bullish) | {{ticker}} @ {{close}} | {{time}}")

bgcolor(buyEvent   ? color.new(color.green, 70) : na, title="BUY bar")
bgcolor(shortEvent ? color.new(color.red, 70)   : na, title="SHORT bar")
bgcolor(useAtrRegimeOverlay ? atrRegimeBg : na, title="ATR regime background")

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 25))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))


// Indicator token budget safeguard
var label evalHudLbl = na
if barstate.islast
    if not na(evalHudLbl)
        label.delete(evalHudLbl)
    evalHudCol = evalSuccessN >= evalMinEvents ? color.new(color.green, 75) : color.new(color.orange, 75)
    chochPresetTxt = chochSaferPresetEff ? "Fast+Safer" : chochFastPresetEff ? "Fast" : "Manual"
    chochHudTxt = " | ChoCH=" + chochPresetTxt + " (" + chochSignalModeEff + "," + breakoutSourceEff + ",R=" + str.tostring(swingREff) + ")"
    evalHudLbl := label.new(bar_index, high + nz(atr) * 0.6, evalSuccessHudTxt + chochHudTxt, style=label.style_label_left, textcolor=color.white, color=evalHudCol, size=size.tiny)

buyEventStrict = barstate.isconfirmed and buyEvent[1] and strictMtfLongOkVis and strictChochLongOkVis
shortEventStrict = barstate.isconfirmed and shortEvent[1] and strictMtfShortOkVis and strictChochShortOkVis
revBuyEventStrict = barstate.isconfirmed and buyEvent[1] and isRevBuy[1] and strictMtfLongOkVis and strictChochLongOkVis
revShortEventStrict = barstate.isconfirmed and shortEvent[1] and isRevShort[1] and strictMtfShortOkVis and strictChochShortOkVis

strictWasEnabled = strictAlertsEnabledVis[1] == true
alertBuySameBar   = buyEventLive and not strictAlertsEnabledVis
alertShortSameBar = shortEventLive and not strictAlertsEnabledVis
alertRevBuySameBar   = revBuyEventLive and not strictAlertsEnabledVis
alertRevShortSameBar = revShortEventLive and not strictAlertsEnabledVis
alertBuyDelayed   = buyEventStrict and strictWasEnabled
alertShortDelayed = shortEventStrict and strictWasEnabled
alertRevBuyDelayed   = revBuyEventStrict and strictWasEnabled
alertRevShortDelayed = revShortEventStrict and strictWasEnabled

alertRevBuyCond   = alertRevBuySameBar or alertRevBuyDelayed
alertRevShortCond = alertRevShortSameBar or alertRevShortDelayed
alertBuyCond   = (alertBuySameBar or alertBuyDelayed) and not alertRevBuyCond
alertShortCond = (alertShortSameBar or alertShortDelayed) and not alertRevShortCond
alertExitCond  = exitEventLive
alertCoverCond = coverEventLive
alertPreBuyCond   = preBuyEventLive
alertPreShortCond = preShortEventLive
alertConsolidationCond = sidewaysVisual and not sidewaysVisual[1]
alertChochBullCond = labelChoCH_L
alertChochBearCond = labelChoCH_S

alertcondition(alertBuyCond,   title="BUY",   message="SkippALGO BUY | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertShortCond, title="SHORT", message="SkippALGO SHORT | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertRevBuyCond,   title="REV-BUY",   message="SkippALGO REV-BUY | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertRevShortCond, title="REV-SHORT", message="SkippALGO REV-SHORT | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertExitCond,  title="EXIT",  message="SkippALGO EXIT | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertCoverCond, title="COVER", message="SkippALGO COVER | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertChochBullCond, title="ChoCH Bullish", message="SkippALGO ChoCH Bullish | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertChochBearCond, title="ChoCH Bearish", message="SkippALGO ChoCH Bearish | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertPreBuyCond,   title="PRE-BUY",   message="SkippALGO PRE-BUY | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertPreShortCond, title="PRE-SHORT", message="SkippALGO PRE-SHORT | {{ticker}} @ {{close}} | {{time}}")
alertcondition(alertConsolidationCond, title="CONSOLIDATION", message="SkippALGO CONSOLIDATION | {{ticker}} @ {{close}} | {{time}}")

f_tp_json(action) =>
    str.format('{{"ticker":"{0}","action":"{1}","price":{2},"mode":"{3}","confirm_delay":{4}}}',
         syminfo.ticker,
         action,
         str.tostring(close, "#.##"),
         strictAlertsEnabledVis ? "strict" : "normal",
         (strictAlertsEnabledVis and (alertBuyCond or alertShortCond) ? 1 : 0))

alertFreqSafe = signalOnCloseOnly ? alert.freq_once_per_bar_close : alert.freq_once_per_bar

if signalGateConfirmed and barstate.isrealtime
    string[] _parts = array.new_string(0)
    if alertRevBuyCond
        array.push(_parts, "REV-BUY")
    else if alertBuyCond
        array.push(_parts, "BUY")
    if alertRevShortCond
        array.push(_parts, "REV-SHORT")
    else if alertShortCond
        array.push(_parts, "SHORT")
    if alertExitCond
        array.push(_parts, "EXIT")
    if alertCoverCond
        array.push(_parts, "COVER")
    if alertPreBuyCond
        array.push(_parts, "PRE-BUY")
    if alertPreShortCond
        array.push(_parts, "PRE-SHORT")
    if alertConsolidationCond
        array.push(_parts, "CONSOLIDATION")

    if array.size(_parts) > 0
        string labels = array.join(_parts, "+")
        string msg = ""
        if useJsonAlerts
            firstLabel = array.get(_parts, 0)
            action = (firstLabel == "BUY" or firstLabel == "REV-BUY") ? "buy" : ((firstLabel == "SHORT" or firstLabel == "REV-SHORT") ? "sell" : ((firstLabel == "EXIT" or firstLabel == "COVER") ? "exit" : "flat"))
            msg := f_tp_json(action)
        else
            modeTxtAlert = strictAlertsEnabledVis ? "strict" : "normal"
            delayTxt = strictAlertsEnabledVis and (alertBuyCond or alertShortCond) ? "1" : "0"
            msg := "SkippALGO " + labels + " | " + syminfo.ticker + " @ " + str.tostring(close, "#.##") + " | TF=" + timeframe.period + " | Conf=" + str.tostring(nz(confidence) * 100, "#.0") + "% | mode=" + modeTxtAlert + " | confirm_delay=" + delayTxt
        alert(msg, alertFreqSafe)
