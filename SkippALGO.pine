// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© preuss_steffen

//@version=6
// SkippALGO â€” Deep Upgrade (Phases 1-4)
// Implements advanced calibration and forecasting logic:
// Phase 1: Timeframe-specific Target Profiles (Fast/Mid/Slow)
// Phase 2: 2D Binning (Algorithm Score + Volatility Regime)
// Phase 3: Ensemble Scoring (Trend + Pullback + Volatility Bias)
// Phase 4: Online Calibration (Platt Scaling via SGD + Brier/LogLoss tracking)

indicator("SkippALGO â€” Deep Upgrade v6.1", overlay=true, max_labels_count=500, max_lines_count=500)

//====================
// Inputs â€” Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)

//====================
// Constants â€” Avoid Magic Numbers
//====================
// Volatility regime thresholds
VOL_THRESH_HIGH = 0.66    // High volatility threshold
VOL_THRESH_LOW  = 0.33    // Low volatility threshold

// Statistical constants
Z_95            = 1.96    // Z-score for 95% confidence interval
PROB_EPS        = 0.0001  // Epsilon for probability clamping to avoid log(0)

// Rolling buffer recalculation interval (prevent FP drift)
ROLL_RECALC_INTERVAL = 500

// Sideways/choppy market detection thresholds
SIDEWAYS_EMA_THRESH = 0.005   // Max EMA diff ratio for sideways
SIDEWAYS_ATR_THRESH = 0.015   // Max ATR norm for sideways

trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels  = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers   = input.bool(true, "Show SET markers")
showTable        = input.bool(true, "Show Outlook/Forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

//====================
// Inputs â€” UT Bot Verification Overlay
//====================
grpUt       = "UT Bot Verification"
utShow      = input.bool(false, "Show UT Bot Overlay", group=grpUt)
utKey       = input.float(1.0, "Key Value", group=grpUt) 
utAtrPeriod = input.int(10, "ATR Period", group=grpUt) 
utUseHA     = input.bool(false, "Use Heikin Ashi", group=grpUt) 

//====================
// Inputs â€” Forecast Calibration Enhancements
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")

// Forecast value display
fcDisplay = input.string("Up% (N)", "Forecast value display", options=["Up% (N)", "Edge pp (N)"])

// --- Phase 1: Separate Targets per Timeframe Group ---
grp_fast = "Target Profile 1: Fast (1m, 5m)"
fcTargetF = input.string("KBarATR", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_fast)
kBarsF    = input.int(3, "k bars", minval=1, maxval=20, group=grp_fast)
atrThrF   = input.float(0.25, "ATR Thr", step=0.05, group=grp_fast)
pathHF    = input.int(6, "Path H", minval=1, maxval=50, group=grp_fast)
tpATRF    = input.float(0.50, "Path TP", step=0.05, group=grp_fast)
slATRF    = input.float(0.30, "Path SL", step=0.05, group=grp_fast)

grp_mid = "Target Profile 2: Mid (15m, 30m, 1h)"
fcTargetM = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_mid)
kBarsM    = input.int(5, "k bars", minval=1, maxval=20, group=grp_mid)
atrThrM   = input.float(0.50, "ATR Thr", step=0.05, group=grp_mid)
pathHM    = input.int(8, "Path H", minval=1, maxval=50, group=grp_mid)
tpATRM    = input.float(0.80, "Path TP", step=0.05, group=grp_mid)
slATRM    = input.float(0.50, "Path SL", step=0.05, group=grp_mid)

grp_slow = "Target Profile 3: Slow (4h, 1D, ...)"
fcTargetS = input.string("PathTPvsSL", "Target", options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"], group=grp_slow)
kBarsS    = input.int(10, "k bars", minval=1, maxval=50, group=grp_slow)
atrThrS   = input.float(1.00, "ATR Thr", step=0.05, group=grp_slow)
pathHS    = input.int(12, "Path H", minval=1, maxval=100, group=grp_slow)
tpATRS    = input.float(1.20, "Path TP", step=0.05, group=grp_slow)
slATRS    = input.float(0.80, "Path SL", step=0.05, group=grp_slow)

// Global Policies
noHitPolicy   = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"])
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"])
atrTargetLen  = input.int(14, "ATR len (forecast targets)", minval=2)

//====================
// Inputs â€” Forecast 3-way (Up/Flat/Down)
//====================
grp_tri = "Forecast 3-way (Up/Flat/Down)"
use3Way = input.bool(true, "3-way probs: Up/Flat/Down", group=grp_tri)

deadbandFast = input.float(0.10, "Deadband Ã— ATR (Fast <=5m)", step=0.01, group=grp_tri)
deadbandMid  = input.float(0.10, "Deadband Ã— ATR (Mid <=1h)",  step=0.01, group=grp_tri)
deadbandSlow = input.float(0.10, "Deadband Ã— ATR (Slow >1h)",  step=0.01, group=grp_tri)

flatPriorFast = input.float(0.42, "Warmup prior: Flat (Fast)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorMid  = input.float(0.30, "Warmup prior: Flat (Mid)",  step=0.01, minval=0.0, maxval=0.90, group=grp_tri)
flatPriorSlow = input.float(0.22, "Warmup prior: Flat (Slow)", step=0.01, minval=0.0, maxval=0.90, group=grp_tri)

tiltMaxFast = input.float(0.10, "Warmup tilt max (Fast)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxMid  = input.float(0.12, "Warmup tilt max (Mid)",  step=0.01, minval=0.0, maxval=0.30, group=grp_tri)
tiltMaxSlow = input.float(0.15, "Warmup tilt max (Slow)", step=0.01, minval=0.0, maxval=0.30, group=grp_tri)

dirMinProb = input.float(0.45, "Direction shown if max prob â‰¥", step=0.01, minval=0.34, maxval=0.90, group=grp_tri)

fcTblModel = input.string("N", "Forecast columns", options=["N","1","Both"], group=grp_tri)

calibratorMode = input.string("Off", "3-way calibrator", options=["Off","Temp","Vector"], group=grp_tri)
lrCal = input.float(0.01, "Calibrator LR", step=0.001, minval=0.0001, group=grp_tri)
tempMin = input.float(0.5, "Temp min", step=0.1, minval=0.1, group=grp_tri)
tempMax = input.float(5.0, "Temp max", step=0.1, minval=0.5, group=grp_tri)
vecAMin = input.float(0.25, "Vec A min", step=0.05, minval=0.05, group=grp_tri)
vecAMax = input.float(3.0, "Vec A max", step=0.05, minval=0.5, group=grp_tri)
vecBMin = input.float(-2.0, "Vec B min", step=0.1, group=grp_tri)
vecBMax = input.float(2.0, "Vec B max", step=0.1, group=grp_tri)
cal3AutoFallback = input.bool(true, "3-way auto fallback (weak bins)", group=grp_tri)
cal3MinSamples  = input.int(120, "3-way min samples for calibrator", minval=10, maxval=5000, group=grp_tri)
useBullBearCal = input.bool(true, "Separate bull/bear calibrators", group=grp_tri)
countDecay = input.float(1.0, "Count decay (1.0=none)", minval=0.80, maxval=1.0, step=0.01, group=grp_tri)
kShrinkReg = input.int(5, "Regime shrinkage k", minval=0, maxval=1000, group=grp_tri)

// --- Phase 2: Calibration Dimensions ---
predBinsN     = input.int(3, "Pred bins (N) state", minval=2, maxval=9)
dim2Bins      = 3 // Fixed: Low, Med, High Volatility Regime

predBins1     = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3)

// Quantile binning (score dimension)
useQuantileBins = input.bool(true, "Use quantile bins (score)")
quantileWindow = input.int(500, "Quantile window (samples)", minval=100, maxval=5000)
quantileUpdate = input.int(50, "Quantile update interval (bars)", minval=10, maxval=1000)
quantileMinSamples = input.int(200, "Quantile min samples", minval=50, maxval=5000)

alphaN  = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1)
alpha1  = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1)
kShrink = input.int(5, "Base Rate Shrinkage k", minval=0, maxval=1000)

calMinSamples = input.int(40, "Min samples per bin (activate)", minval=5, maxval=1000)

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01)
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01)

// --- Phase 3: Ensemble Weights ---
grp_ens = "Phase 3: Ensemble Weights"
wState    = input.float(1.0, "Weight: State (Outlook)", step=0.1, group=grp_ens)
wPullback = input.float(0.5, "Weight: Pullback Depth", step=0.1, group=grp_ens)
wRegime   = input.float(0.3, "Weight: Vol Regime", step=0.1, group=grp_ens)
wTrend    = input.float(0.4, "Weight: Trend Regime", step=0.1, group=grp_ens, tooltip="Bull/Bear/Sideways detection")

// --- Phase 4: Platt Scaling (Online Calibration) ---
usePlatt = input.bool(true, "Phase 4: Use Platt Scaling (SGD)", group="Calibration Tuning")
lrPlatt  = input.float(0.005, "Learning Rate", step=0.001, group="Calibration Tuning")

// Per-horizon reset control
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7"])
resetNow   = input.bool(false, "Reset selected calibration NOW")

//====================
// Inputs â€” Forecast Filtering (Accuracy-based)
//====================
useRelFilter = input.bool(false, "Filter entries by Forecast Accuracy")
maxBrier     = input.float(0.25, "Max Brier Score (lower=better)", minval=0.01, step=0.01)
relFilterTF  = input.string("F6", "Filter Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], tooltip="Check accuracy of this forecast timeframe")
relFilterModel = input.string("N", "Filter Model", options=["N", "1"], tooltip="N=Multi-factor, 1=Single-factor")

// Evidence / coverage gating
evidenceGate = input.bool(false, "Evidence gate (block weak bins)")
evidenceMinTotal = input.int(120, "Evidence min total samples", minval=1, maxval=10000)
abstainGate = input.bool(true, "Abstain on weak decisions")
abstainMinEdge = input.float(0.08, "Abstain min edge (pp)", minval=0.0, maxval=0.50, step=0.01)

//====================
// Inputs â€” Evaluation (live scoring)
//====================
showEvalSection = input.bool(true, "Show Evaluation rows (Brier/LogLoss/ConfErr/Drift)")
evalWhichHead   = input.string("N", "Evaluate head", options=["N","1"])  // N=stable bins, 1=reactive bins

evalInBackground = input.bool(true, "Eval in background (when Eval section hidden)")

evalMode        = input.string("History+Live", "Evaluation mode", options=["History+Live","LiveOnly"])

evalRollScore   = input.int(200, "Eval rolling window: score (events)", minval=20, maxval=2000)
evalRollShort   = input.int(50,  "Eval drift short window (events)", minval=10, maxval=500)
evalRollLong    = input.int(300, "Eval drift long window (events)", minval=30, maxval=3000)

evalBuckets     = input.int(5, "Eval buckets (ECE)", minval=3, maxval=5)
evalMinEvents   = input.int(30, "Eval min events to display", minval=5, maxval=500)

evalBucketCount = use3Way ? evalBuckets * 3 : evalBuckets

driftWarnPP     = input.float(8.0, "Drift warn threshold (pp)", minval=1.0, maxval=50.0, step=0.5)

//====================
// Inputs â€” Calibration Diagnostics (Debug Panel)
//====================
grp_diag = "ðŸ”§ Calibration Diagnostics"
showDiagPanel   = input.bool(false, "Show Calibration Debug Panel", group=grp_diag, tooltip="Displays Platt params, convergence, bin samples")
diagHorizon     = input.string("F1", "Diagnostic Horizon", options=["F1","F2","F3","F4","F5","F6","F7"], group=grp_diag)
diagModel       = input.string("N", "Diagnostic Model", options=["N","1"], group=grp_diag, tooltip="N=Multi-factor, 1=Single-factor")

//====================
// Calibration storage â€” per horizon TF (Global State)
//====================

// UDT to hold all state arrays for a single timeframe horizon
type TfState
    float[] cntN
    float[] upN
    float[] dnN
    float[] cnt1
    float[] up1
    float[] dn1
    float[] cntN_bull
    float[] upN_bull
    float[] dnN_bull
    float[] cntN_bear
    float[] upN_bear
    float[] dnN_bear
    float[] cnt1_bull
    float[] up1_bull
    float[] dn1_bull
    float[] cnt1_bear
    float[] up1_bear
    float[] dn1_bear
    // Queues
    int[]   qBinN
    int[]   qBin1
    float[] qEntry
    float[] qAtr
    float[] qMaxH
    float[] qMinL
    int[]   qAge
    int[]   qBias
    float[] qProbN
    float[] qProb1
    float[] qLogitN
    float[] qLogit1
    float[] qPredN
    float[] qPred1
    float[] qPUpN
    float[] qPFlN
    float[] qPDnN
    float[] qPUp1
    float[] qPFl1
    float[] qPDn1
    float[] qZUpN
    float[] qZFlN
    float[] qZDnN
    float[] qZUp1
    float[] qZFl1
    float[] qZDn1
    // Stats
    float[] brierStatsN
    float[] brierStats1
    float[] llStatsN
    float[] llStats1
    float[] plattN
    float[] platt1
    float[] tempN
    float[] temp1
    float[] vecAN
    float[] vecBN
    float[] vecA1
    float[] vecB1
    // Evaluation N
    float[] evBrierN
    float[] evSumBrierN
    float[] evLogN
    float[] evSumLogN
    float[] evYS_N
    float[] evSumYS_N
    float[] evYL_N
    float[] evSumYL_N
    int[]   evCalCntN
    float[] evCalSumPN
    float[] evCalSumYN
    int[]   evCalBBufN
    float[] evCalPBufN
    float[] evCalYBufN
    // Evaluation 1
    float[] evBrier1
    float[] evSumBrier1
    float[] evLog1
    float[] evSumLog1
    float[] evYS_1
    float[] evSumYS_1
    float[] evYL_1
    float[] evSumYL_1
    int[]   evCalCnt1
    float[] evCalSumP1
    float[] evCalSumY1
    int[]   evCalBBuf1
    float[] evCalPBuf1
    float[] evCalYBuf1

// Helper to initialize TfState
f_init_tf_state(int nBinsN, int nBins1, int dim2, int evBuckets) =>
    TfState.new(
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0), array.new_float(nBinsN * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
        array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0), array.new_float(nBins1 * dim2, 0.0),
            array.new_int(), array.new_int(),
      array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_int(),
            array.new_int(),
            array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
    array.new_float(), array.new_float(), array.new_float(),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
      array.new_float(2, 0.0), array.new_float(2, 0.0),
    array.from(1.0, 0.0), array.from(1.0, 0.0),
    array.from(1.0), array.from(1.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
    array.from(1.0, 1.0, 1.0), array.from(0.0, 0.0, 0.0),
      // Eval N
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float(),
      // Eval 1
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
      array.new_float(), array.new_float(1, 0.0), array.new_float(), array.new_float(1, 0.0),
            array.new_int(evBuckets, 0), array.new_float(evBuckets, 0.0), array.new_float(evBuckets, 0.0),
      array.new_int(), array.new_float(), array.new_float()
    )

var TfState tf1State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf2State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf3State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf4State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf5State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf6State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)
var TfState tf7State = f_init_tf_state(predBinsN, predBins1, dim2Bins, evalBucketCount)

//====================
// Evaluation storage â€” per horizon (Head N and Head 1)
//====================
// F1 â€” Head N
// (Globals removed, now in TfState)

//====================
// Table colors (navy + soft-blue frame)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

//====================
// Quantile bin buffers (score dimension)
//====================
var float[] qScoreBuf = array.new_float()
var float[] qCutsN = array.new_float(int(math.max(predBinsN - 1, 0)), na)
var float[] qCuts1 = array.new_float(int(math.max(predBins1 - 1, 0)), na)

//====================
// Helpers
//====================
// --- Sum int array (total resolved samples across all bins)
f_sum_int_array(a) =>
    float s = 0.0
    for i = 0 to array.size(a) - 1
        s += array.get(a, i)
    s

// --- Update quantile cutpoints (score dimension)
f_fill_cuts(sorted, cuts, bins) =>
    cutCount = bins - 1
    if cutCount > 0
        n = array.size(sorted)
        for i = 0 to cutCount - 1
            frac = (i + 1.0) / bins
            idx = int(math.floor(frac * (n - 1)))
            array.set(cuts, i, array.get(sorted, idx))

// Forecast binning / calibration
f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = int(math.floor(u * bins))
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b

f_update_quantiles(score) =>
    if useQuantileBins and (showTable or showEvalSection)
        array.push(qScoreBuf, score)
        if array.size(qScoreBuf) > quantileWindow
            array.shift(qScoreBuf)
        if bar_index % quantileUpdate == 0 and array.size(qScoreBuf) >= quantileMinSamples
            tmp = array.copy(qScoreBuf)
            array.sort(tmp, order.ascending)
            f_fill_cuts(tmp, qCutsN, predBinsN)
            f_fill_cuts(tmp, qCuts1, predBins1)

f_bin_quantile(score, cuts, bins) =>
    if (not useQuantileBins) or array.size(cuts) == 0 or na(array.get(cuts, 0))
        f_bin(score, bins)
    else
        b = 0
        for i = 0 to array.size(cuts) - 1
            if score <= array.get(cuts, i)
                b := i
                break
            else
                b := i + 1
        math.max(0, math.min(bins - 1, b))

f_regime_bin(trendScore) =>
    trendScore > 0.5 ? 2 : trendScore < -0.5 ? 0 : 1

// --- Human name for "chance" depending on forecast target
f_chance_word() =>
    anyWin = fcTargetF == "PathTPvsSL" or fcTargetM == "PathTPvsSL" or fcTargetS == "PathTPvsSL"
    anyWin ? "Win" : "Up"

// --- 95% CI half-width (approx) for Bernoulli p with n samples
f_ci95_halfwidth(p, n) =>
    n <= 0 ? na : Z_95 * math.sqrt(p * (1.0 - p) / n)

// --- Reliability label based on CI half-width
f_rel_label(p, nBin, total, canCal) =>
    string lbl = "off"
    if not canCal
        lbl := "off"
    else if total <= 0
        lbl := "n/a"
    else if nBin < calMinSamples
        lbl := "warmup"
    else
        hw = f_ci95_halfwidth(p, nBin)
        lbl := na(hw) ? "warmup" : hw <= 0.05 ? "strong" : hw <= 0.10 ? "ok" : "weak"
    lbl

// --- Color for reliability label (subtle; does NOT conflict with up/down coloring)
f_rel_color(p, nBin, total, canCal) =>
    if not canCal
        color.new(color.white, 70)
    else if total <= 0
        color.new(color.white, 60)
    else if nBin < calMinSamples
        color.new(color.white, 60)
    else
        hw = f_ci95_halfwidth(p, nBin)
        na(hw) ? color.new(color.white, 60) : hw <= 0.05 ? color.lime : hw <= 0.10 ? color.yellow : tblTextDim

//====================
// Forecast display helpers (human formatting)
//====================

// Map a TF into your "Fast/Mid/Slow" profiles.
f_profile(tf) =>
    s = timeframe.in_seconds(tf)
    not na(s) and s <= timeframe.in_seconds("900") ? "Fast" : not na(s) and s <= timeframe.in_seconds("14400") ? "Mid" : "Slow"

// Pick which target is active for that TF profile.
f_target_for_tf(tf) =>
    prof = f_profile(tf)
    prof == "Fast" ? fcTargetF : prof == "Mid" ? fcTargetM : fcTargetS

// Short, human label for the target (what "Win" means on that row)
f_target_label(tf) =>
    t = f_target_for_tf(tf)
    t == "NextBar" ? "Next-up" : t == "KBarReturn" ? "Up-close" : t == "KBarATR" ? "ATR-hit" : t == "PathTPvsSL" ? "TP-first" : "Win"

// Uncertainty band in percentage points using a binomial approx (â‰ˆ95% band).
f_unc_pp(p, n) =>
    n <= 0 ? na : Z_95 * math.sqrt(math.max(p * (1.0 - p), 0.0) / n) * 100.0

// Sample-strength label derived from CURRENT BIN sample size (nBin).
f_strength_label_fc(nBin) =>
    nBin < calMinSamples ? "weak" : nBin < calMinSamples * 4 ? "ok" : "strong"

// Format probability range text like "34â€“46%" (bounded to 0..100)
f_prob_range_text(p, nBin) =>
    if nBin < calMinSamples or nBin <= 0
        "build n" + str.tostring(nBin)
    else
        band = f_unc_pp(p, nBin) / 100.0
        lo = math.max(0.0, p - band)
        hi = math.min(1.0, p + band)
        str.tostring(lo * 100.0, "#.0") + "â€“" + str.tostring(hi * 100.0, "#.0") + "%"

//====================
// Helpers â€” Evaluation (proper scoring + rolling stats)
//====================
f_epsClamp(p) =>
    eps = 1e-6
    math.max(eps, math.min(1.0 - eps, p))

f_brier(p, y) =>
    // y in {0.0, 1.0}
    d = p - y
    d * d

f_logloss(p, y) =>
    // y in {0.0, 1.0}
    pc = f_epsClamp(p)
    -(y * math.log(pc) + (1.0 - y) * math.log(1.0 - pc))

// @function Adds value to rolling buffer and maintains running sum
// @param buf Rolling buffer array
// @param sumArr Single-element array holding running sum
// @param v Value to add
// @param maxLen Maximum buffer length
// @note Periodic recalculation every ROLL_RECALC_INTERVAL bars prevents FP drift
f_roll_add(buf, sumArr, v, maxLen) =>
    array.push(buf, v)
    array.set(sumArr, 0, array.get(sumArr, 0) + v)
    if array.size(buf) > maxLen
        old = array.shift(buf)
        array.set(sumArr, 0, array.get(sumArr, 0) - old)
    // Periodic recalculation to prevent floating-point drift
    if bar_index % ROLL_RECALC_INTERVAL == 0 and array.size(buf) > 0
        array.set(sumArr, 0, array.sum(buf))

f_bucket(p, B) =>
    // p in [0,1], B buckets
    b = int(math.floor(p * B))
    b < 0 ? 0 : b > (B - 1) ? (B - 1) : b

f_cal_roll_update(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, p, y, maxLen) =>
    B = array.size(calCnt)
    bi = f_bucket(p, B)

    // push
    array.push(bBuf, bi)
    array.push(pBuf, p)
    array.push(yBuf, y)

    // increment bucket accumulators
    array.set(calCnt,  bi, array.get(calCnt,  bi) + 1)
    array.set(calSumP, bi, array.get(calSumP, bi) + p)
    array.set(calSumY, bi, array.get(calSumY, bi) + y)

    // enforce rolling length
    if array.size(bBuf) > maxLen
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_cal_roll_update3(calCnt, calSumP, calSumY, bBuf, pBuf, yBuf, pU, pF, pD, outcome, maxLen) =>
    B = evalBuckets
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0

    biU = f_bucket(pU, B)
    biF = f_bucket(pF, B)
    biD = f_bucket(pD, B)

    idxU = 0 * B + biU
    idxF = 1 * B + biF
    idxD = 2 * B + biD

    array.push(bBuf, idxU), array.push(pBuf, pU), array.push(yBuf, yU)
    array.push(bBuf, idxF), array.push(pBuf, pF), array.push(yBuf, yF)
    array.push(bBuf, idxD), array.push(pBuf, pD), array.push(yBuf, yD)

    array.set(calCnt,  idxU, array.get(calCnt,  idxU) + 1)
    array.set(calSumP, idxU, array.get(calSumP, idxU) + pU)
    array.set(calSumY, idxU, array.get(calSumY, idxU) + yU)

    array.set(calCnt,  idxF, array.get(calCnt,  idxF) + 1)
    array.set(calSumP, idxF, array.get(calSumP, idxF) + pF)
    array.set(calSumY, idxF, array.get(calSumY, idxF) + yF)

    array.set(calCnt,  idxD, array.get(calCnt,  idxD) + 1)
    array.set(calSumP, idxD, array.get(calSumP, idxD) + pD)
    array.set(calSumY, idxD, array.get(calSumY, idxD) + yD)

    maxLen3 = maxLen * 3
    while array.size(bBuf) > maxLen3
        bOld = array.shift(bBuf)
        pOld = array.shift(pBuf)
        yOld = array.shift(yBuf)

        array.set(calCnt,  bOld, math.max(0, array.get(calCnt,  bOld) - 1))
        array.set(calSumP, bOld, array.get(calSumP, bOld) - pOld)
        array.set(calSumY, bOld, array.get(calSumY, bOld) - yOld)

f_eval_stats_one(brierBuf, sumBrier, logBuf, sumLog, ySBuf, sumYS, yLBuf, sumYL, calCnt, calSumP, calSumY) =>
    nScore = array.size(brierBuf)
    brierAvg = nScore == 0 ? na : array.get(sumBrier, 0) / nScore
    logAvg   = nScore == 0 ? na : array.get(sumLog,   0) / nScore

    nS = array.size(ySBuf)
    nL = array.size(yLBuf)
    wS = nS == 0 ? na : array.get(sumYS, 0) / nS
    wL = nL == 0 ? na : array.get(sumYL, 0) / nL
    drift = (na(wS) or na(wL)) ? na : (wS - wL)

    // ECE from rolling buckets (binary or multiclass)
    ece = float(na)
    maxErr = float(na)
    B = evalBuckets
    sizeCnt = array.size(calCnt)
    if sizeCnt == B
        tot = 0
        for i = 0 to sizeCnt - 1
            tot += array.get(calCnt, i)
        if tot > 0
            e = 0.0
            m = 0.0
            for i = 0 to sizeCnt - 1
                c = array.get(calCnt, i)
                if c > 0
                    ap = array.get(calSumP, i) / c
                    ay = array.get(calSumY, i) / c
                    err = math.abs(ap - ay)
                    e += err * (c / tot)
                    m := math.max(m, err)
            ece := e
            maxErr := m
    else if sizeCnt == B * 3
        eTot = 0.0
        mTot = 0.0
        for cls = 0 to 2
            totC = 0
            for i = 0 to B - 1
                totC += array.get(calCnt, cls * B + i)
            if totC > 0
                eC = 0.0
                mC = 0.0
                for i = 0 to B - 1
                    idx = cls * B + i
                    c = array.get(calCnt, idx)
                    if c > 0
                        ap = array.get(calSumP, idx) / c
                        ay = array.get(calSumY, idx) / c
                        err = math.abs(ap - ay)
                        eC += err * (c / totC)
                        mC := math.max(mC, err)
                eTot += eC
                mTot := math.max(mTot, mC)
        ece := eTot / 3.0
        maxErr := mTot

    [brierAvg, logAvg, ece, maxErr, wS, wL, drift, nScore]

f_strengthLabel(n) =>
    n < 30 ? "weak" : n < 100 ? "ok" : "strong"

f_pp(x) =>
    // x in [0,1] -> "12.3%"
    str.tostring(x * 100.0, "#.0") + "%"

f_ppSigned(x) =>
    // x in [-1,1] -> "+4.0pp"
    pp = x * 100.0
    (pp >= 0 ? "+" : "") + str.tostring(pp, "#.0") + "pp"

f_colLowerBetter(x, good, ok) =>
    na(x) ? color.new(color.white, 60) : x <= good ? color.lime : x <= ok ? color.yellow : color.red

// --- â€œChanceâ€ cell text (arrow + percent), but human warmup/off states
f_chance_text(tf, pUp, nBin, total, canCal) =>
    if not canCal or total <= 0
        "â€”"
    else if nBin < calMinSamples
        f_target_label(tf) + " â€¦"
    else
        sym = pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"
        sym + " " + f_target_label(tf) + " " + str.tostring(pUp * 100.0, "#.0") + "%"

// --- â€œDataâ€ cell text: bin/total + label + optional Â±CI
f_data_text(pUp, nBin, total, canCal) =>
    if not canCal
        "off"
    else if total <= 0
        "n0"
    else
        lbl = f_strength_label_fc(nBin)
        rng = f_prob_range_text(pUp, nBin)
        str.tostring(nBin) + "/" + str.tostring(total) + "\n" + lbl + " (" + rng + ")"

f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

// @function Clamp value to arbitrary [lo, hi] range
// @param val Value to clamp
// @param lo Minimum bound
// @param hi Maximum bound
// @returns Clamped value
f_clamp(val, lo, hi) =>
    math.max(lo, math.min(hi, val))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" : tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  : tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "â€”" : v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") : v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") : v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") : str.tostring(v, "#")

f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    trend = emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

// --- Phase 1 Helpers: Target Params ---
f_get_params(tf) =>
    sec = timeframe.in_seconds(tf)
    isFast = sec <= 300 // <= 5m
    isMid  = sec <= 3600 // <= 1h
    // Returns: [fcTarget, kBars, atrThr, pathH, tpATR, slATR]
    [isFast ? fcTargetF : isMid ? fcTargetM : fcTargetS, 
     isFast ? kBarsF    : isMid ? kBarsM    : kBarsS, 
     isFast ? atrThrF   : isMid ? atrThrM   : atrThrS, 
     isFast ? pathHF    : isMid ? pathHM    : pathHS, 
     isFast ? tpATRF    : isMid ? tpATRM    : tpATRS, 
     isFast ? slATRF    : isMid ? slATRM    : slATRS]

// --- Phase 4 Helpers: Platt Scaling ---
f_logit(p) =>
    pc = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, p))
    // Clamp output to prevent extreme values
    math.max(-10.0, math.min(10.0, math.log(pc / (1.0 - pc))))

f_sigmoid(x) =>
    // Prevent overflow for extreme x values
    x < -500 ? 0.0 : x > 500 ? 1.0 : 1.0 / (1.0 + math.exp(-x))

f_platt_prob(pRaw, a, b) =>
    usePlatt ? f_sigmoid(a * f_logit(pRaw) + b) : pRaw

// --- Phase 3 Helpers: Ensemble ---
f_pullback_score(c, ef, es, bias) =>
    // Bias 1 (Bull): shallow PB to EMAF is good (+1), deep to EMAS is neutral (0), below is bad (-1)
    // Bias -1 (Bear): mirror logic
    bias == 1 ? (c > ef ? 0.5 : c > es ? 1.0 : -1.0) : bias == -1 ? (c < ef ? 0.5 : c < es ? 1.0 : -1.0) : 0.0

f_ensemble(sA, sB, sC, wA, wB, wC) =>
    num = wA * sA + wB * sB + wC * sC
    den = wA + wB + wC
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

// @function Computes trend regime score (bull/bear/sideways)
// @param emaF Fast EMA value
// @param emaS Slow EMA value
// @param atrNorm ATR normalized by close (for sideways detection)
// @returns Score in [-1, 1]: +1=bull, -1=bear, 0=sideways/choppy
f_trend_regime(emaF, emaS, atrNorm) =>
    emaDiff = (emaF - emaS) / nz(emaS, 1)
    isSideways = math.abs(emaDiff) < SIDEWAYS_EMA_THRESH and atrNorm < SIDEWAYS_ATR_THRESH
    isBull = emaF > emaS and not isSideways
    isBear = emaF < emaS and not isSideways
    isBull ? 1.0 : isBear ? -1.0 : 0.0

// Extended ensemble with trend regime (4 factors)
f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD) =>
    num = wA * sA + wB * sB + wC * sC + wD * sD
    den = wA + wB + wC + wD
    val = den == 0 ? 0.0 : num / den
    math.max(-1.0, math.min(1.0, val))

f_tf_pack(tf) =>
    request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen),
         f_pct_rank(close == 0 ? 0.0 : ta.atr(atrLen) / close, volRankLen)], // Added Phase 2 Vol Rank
        barmerge.gaps_off,
        barmerge.lookahead_off
    )

f_score_tf(tf) =>
    [c_t, ef_t, es_t, r_t] = request.security(
            syminfo.tickerid,
            tf,
            [close,
             ta.ema(close, emaFastLen),
             ta.ema(close, emaSlowLen),
             ta.rsi(close, rsiStateLen)],
            barmerge.gaps_off,
            barmerge.lookahead_off
        )
    c = c_t
    ef = ef_t
    es = es_t
    r = r_t
    f_state_score(c, ef, es, r)

// Phase 2: 2D Binning (Score + Regime)
// @function Computes 2D bin index from score and trend regime
// @param score Ensemble score in [-1, 1]
// @param trendScore Trend regime score in [-1, 1]
// @param binsA Number of bins for score dimension
// @param binsB Number of bins for regime dimension (typically 3)
// @param cutsArr Quantile cutpoints for score dimension
// @returns Flattened bin index
f_bin2D(score, trendScore, binsA, binsB, cutsArr) =>
    bA = f_bin_quantile(score, cutsArr, binsA)
    bB = f_regime_bin(trendScore)
    int(bA * binsB + bB)

f_db_mult(tf) =>
    sec = timeframe.in_seconds(tf)
    sec <= 300 ? deadbandFast : sec <= 3600 ? deadbandMid : deadbandSlow

f_outcome3(delta, db) =>
    delta > db ? 1 : delta < -db ? -1 : 0

f_bias_from_score(score) =>
    score >= 0 ? 1 : -1

f_decay_counts(cntArr, upArr, dnArr, decay) =>
    if decay < 0.9999
        for i = 0 to array.size(cntArr) - 1
            array.set(cntArr, i, array.get(cntArr, i) * decay)
            array.set(upArr,  i, array.get(upArr,  i) * decay)
            array.set(dnArr,  i, array.get(dnArr,  i) * decay)

f_cal_update3(cntArr, upArr, dnArr, bin, outcome) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    d0 = array.get(dnArr,  bin)
    array.set(cntArr, bin, n0 + 1.0)
    array.set(upArr,  bin, u0 + (outcome == 1 ? 1.0 : 0.0))
    array.set(dnArr,  bin, d0 + (outcome == -1 ? 1.0 : 0.0))

f_prob3(u, f, d, n, alpha) =>
    denom = n + 3.0 * alpha
    if denom == 0.0
        [0.3333, 0.3334, 0.3333]
    else
        [(u + alpha) / denom, (f + alpha) / denom, (d + alpha) / denom]

f_cal_cur3(cntArr, upArr, dnArr, bin, alpha, shrinkK, shrinkReg) =>
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    d = array.get(dnArr,  bin)
    f = math.max(0, n - u - d)

    [pUb_t, pFb_t, pDb_t] = f_prob3(u, f, d, n, alpha)
    pUb = pUb_t
    pFb = pFb_t
    pDb = pDb_t

    volBin = bin % dim2Bins
    binsScore = int(array.size(cntArr) / dim2Bins)
    nReg = 0.0
    uReg = 0.0
    dReg = 0.0
    for i = 0 to binsScore - 1
        idx = i * dim2Bins + volBin
        nReg += array.get(cntArr, idx)
        uReg += array.get(upArr,  idx)
        dReg += array.get(dnArr,  idx)
    fReg = math.max(0, nReg - uReg - dReg)
    [pUr_t, pFr_t, pDr_t] = f_prob3(uReg, fReg, dReg, nReg, alpha)
    pUr = pUr_t
    pFr = pFr_t
    pDr = pDr_t

    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    dBase = array.sum(dnArr)
    fBase = math.max(0, nBase - uBase - dBase)
    [pU0_t, pF0_t, pD0_t] = f_prob3(uBase, fBase, dBase, nBase, alpha)
    pU0 = pU0_t
    pF0 = pF0_t
    pD0 = pD0_t

    wReg = (shrinkReg <= 0) ? 1.0 : (n / (n + shrinkReg + 0.0))
    pUreg = wReg * pUb + (1.0 - wReg) * pUr
    pFreg = wReg * pFb + (1.0 - wReg) * pFr
    pDreg = wReg * pDb + (1.0 - wReg) * pDr

    w = (shrinkK <= 0) ? 1.0 : (nReg / (nReg + shrinkK + 0.0))
    pU = w * pUreg + (1.0 - w) * pU0
    pF = w * pFreg + (1.0 - w) * pF0
    pD = w * pDreg + (1.0 - w) * pD0

    s = pU + pF + pD
    if s == 0.0
        [0.3333, 0.3334, 0.3333, n]
    else
        [pU / s, pF / s, pD / s, n]

f_safe_log(p) =>
    math.log(math.max(PROB_EPS, p))

f_softmax3(zU, zF, zD) =>
    zMax = math.max(zU, math.max(zF, zD))
    eU = math.exp(zU - zMax)
    eF = math.exp(zF - zMax)
    eD = math.exp(zD - zMax)
    s = eU + eF + eD
    if s == 0.0
        [0.3333, 0.3334, 0.3333]
    else
        [eU / s, eF / s, eD / s]

f_can_cal3(nBin) =>
    calibratorMode != "Off" and (not cal3AutoFallback or nBin >= cal3MinSamples)

f_cal_apply(zU, zF, zD, tempArr, aArr, bArr) =>
    zUo = zU
    zFo = zF
    zDo = zD
    if calibratorMode == "Temp"
        t = array.get(tempArr, 0)
        t := t <= 0.0 ? 1.0 : t
        zUo := zU / t
        zFo := zF / t
        zDo := zD / t
    else if calibratorMode == "Vector"
        aU = array.get(aArr, 0)
        aF = array.get(aArr, 1)
        aD = array.get(aArr, 2)
        bU = array.get(bArr, 0)
        bF = array.get(bArr, 1)
        bD = array.get(bArr, 2)
        zUo := aU * zU + bU
        zFo := aF * zF + bF
        zDo := aD * zD + bD
    f_softmax3(zUo, zFo, zDo)

f_brier3(pU, pF, pD, outcome) =>
    yU = outcome == 1 ? 1.0 : 0.0
    yF = outcome == 0 ? 1.0 : 0.0
    yD = outcome == -1 ? 1.0 : 0.0
    ((pU - yU) * (pU - yU) + (pF - yF) * (pF - yF) + (pD - yD) * (pD - yD)) / 3.0

f_logloss3(pU, pF, pD, outcome) =>
    pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD
    -math.log(f_epsClamp(pTrue))

f_prior3(tf, outScore) =>
    sec = timeframe.in_seconds(tf)
    baseFlat = sec <= 300 ? flatPriorFast : sec <= 3600 ? flatPriorMid : flatPriorSlow
    tiltMax  = sec <= 300 ? tiltMaxFast  : sec <= 3600 ? tiltMaxMid  : tiltMaxSlow

    baseSide = (1.0 - baseFlat) * 0.5
    tilt = f_clamp(outScore, -1.0, 1.0) * tiltMax

    pU = f_clamp(baseSide + tilt, 0.0, 1.0)
    pD = f_clamp(baseSide - tilt, 0.0, 1.0)
    pF = f_clamp(baseFlat, 0.0, 1.0)

    s = pU + pF + pD
    if s == 0.0
        [0.3333, 0.3334, 0.3333]
    else
        [pU / s, pF / s, pD / s]

f_samp_label(enabled, total) =>
    not enabled ? "off" : total < calMinSamples ? "â€¦" : total < calMinSamples * 3 ? "ok" : "strong"

// @function Computes Bayesian probability with Platt scaling
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter
// @param aPlatt Platt scaling slope
// @param bPlatt Platt scaling intercept
// @returns Calibrated probability after Platt transformation
f_prob_platt(up, n, alpha, aPlatt, bPlatt) =>
    denom = n + 2.0 * alpha
    pRaw = denom == 0.0 ? 0.5 : (up + alpha) / denom
    f_platt_prob(pRaw, aPlatt, bPlatt)

// @function Computes Laplace-smoothed probability with division safety
// @param up Number of positive outcomes
// @param n Total number of samples
// @param alpha Laplace smoothing parameter (default typically 1.0)
// @returns Probability in (0, 1), defaults to 0.5 if denominator is zero
f_prob(up, n, alpha) =>
    denom = n + 2.0 * alpha
    denom == 0.0 ? 0.5 : (up + alpha) / denom

f_cal_update(cntArr, upArr, bin, isUp) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    array.set(cntArr, bin, n0 + 1.0)
    array.set(upArr,  bin, u0 + (isUp ? 1.0 : 0.0))

f_cal_cur(cntArr, upArr, bin, alpha, shrinkK) =>
    // Bin raw
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    pBin = n == 0 ? 0.5 : f_prob(u, n, alpha)

    // Base rate (pooling)
    nBase = array.sum(cntArr)
    uBase = array.sum(upArr)
    pBase = nBase == 0 ? 0.5 : f_prob(uBase, nBase, alpha)

    // Shrinkage
    w = (shrinkK <= 0) ? 1.0 : (n / (n + shrinkK + 0.0))
    pFinal = w * pBin + (1.0 - w) * pBase
    [pFinal, n]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "â€”" : n < calMinSamples ? "â€¦" : pUp > predUpThr ? "â–²" : pUp < predDnThr ? "â–¼" : "âˆ’"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) : n < calMinSamples ? color.new(color.white, 60) : pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_pupText(pUp, n, canCal) =>
    not canCal ? "OFF" : n == 0 ? "â€”" : n < calMinSamples ? "Warm " + str.tostring(n) + "/" + str.tostring(calMinSamples) : fcDisplay == "Edge pp (N)" ? ((pUp - 0.5) * 100.0 > 0 ? "+" + str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")" : str.tostring((pUp - 0.5) * 100.0, "#.0") + "pp (" + str.tostring(n) + ")") : "Up " + str.tostring(pUp * 100.0, "#.0") + "% (" + str.tostring(n) + ")"

f_eval_update_one(p, y,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: run if Eval section visible OR background eval enabled,
    // AND we're in history+live mode or on a realtime bar.
    canEval = (showEvalSection or evalInBackground) and ((evalMode == "History+Live") or barstate.isrealtime)
    if canEval
        pc = f_epsClamp(p)

        // rolling scores
        f_roll_add(brierBuf, sumBrier, f_brier(pc, y), evalRollScore)
        f_roll_add(logBuf,   sumLog,   f_logloss(pc, y), evalRollScore)

        // rolling win rates
        f_roll_add(ySBuf, sumYS, y, evalRollShort)
        f_roll_add(yLBuf, sumYL, y, evalRollLong)

        // rolling calibration buckets (ECE)
        f_cal_roll_update(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pc, y, evalRollScore)

f_eval_update_one3(pU, pF, pD, outcome,
    brierBuf, sumBrier,
    logBuf,   sumLog,
    ySBuf,    sumYS,
    yLBuf,    sumYL,
    calCnt, calSumP, calSumY,
    calBBuf, calPBuf, calYBuf) =>

    // Eval gating: run if Eval section visible OR background eval enabled
    canEval = (showEvalSection or evalInBackground) and ((evalMode == "History+Live") or barstate.isrealtime)
    if canEval
        b3 = f_brier3(pU, pF, pD, outcome)
        ll = f_logloss3(pU, pF, pD, outcome)
        yUp = outcome == 1 ? 1.0 : 0.0
        pTrue = outcome == 1 ? pU : outcome == 0 ? pF : pD

        f_roll_add(brierBuf, sumBrier, b3, evalRollScore)
        f_roll_add(logBuf,   sumLog,   ll, evalRollScore)

        f_roll_add(ySBuf, sumYS, yUp, evalRollShort)
        f_roll_add(yLBuf, sumYL, yUp, evalRollLong)

        f_cal_roll_update3(calCnt, calSumP, calSumY, calBBuf, calPBuf, calYBuf, pU, pF, pD, outcome, evalRollScore)

f_eval_on_resolve(TfState st, pN, p1, isUpBool) =>
    y = isUpBool ? 1.0 : 0.0

    f_eval_update_one(pN, y, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
    f_eval_update_one(p1, y, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)

f_reset_tf(TfState st) =>
    array.fill(st.cntN, 0.0), array.fill(st.upN, 0.0), array.fill(st.dnN, 0.0)
    array.fill(st.cnt1, 0.0), array.fill(st.up1, 0.0), array.fill(st.dn1, 0.0)
    array.fill(st.cntN_bull, 0.0), array.fill(st.upN_bull, 0.0), array.fill(st.dnN_bull, 0.0)
    array.fill(st.cntN_bear, 0.0), array.fill(st.upN_bear, 0.0), array.fill(st.dnN_bear, 0.0)
    array.fill(st.cnt1_bull, 0.0), array.fill(st.up1_bull, 0.0), array.fill(st.dn1_bull, 0.0)
    array.fill(st.cnt1_bear, 0.0), array.fill(st.up1_bear, 0.0), array.fill(st.dn1_bear, 0.0)

    array.clear(st.qBinN)
    array.clear(st.qBin1)
    array.clear(st.qEntry)
    array.clear(st.qAtr)
    array.clear(st.qMaxH)
    array.clear(st.qMinL)
    array.clear(st.qAge)
    array.clear(st.qBias)
    
    // Brier tracking clear
    array.clear(st.qProbN)
    array.clear(st.qProb1)
    array.clear(st.qLogitN)
    array.clear(st.qLogit1)
    array.clear(st.qPredN)
    array.clear(st.qPred1)
    array.clear(st.qPUpN)
    array.clear(st.qPFlN)
    array.clear(st.qPDnN)
    array.clear(st.qPUp1)
    array.clear(st.qPFl1)
    array.clear(st.qPDn1)
    array.clear(st.qZUpN)
    array.clear(st.qZFlN)
    array.clear(st.qZDnN)
    array.clear(st.qZUp1)
    array.clear(st.qZFl1)
    array.clear(st.qZDn1)
    
    // Stats clear
    array.set(st.brierStatsN, 0, 0.0)
    array.set(st.brierStatsN, 1, 0.0)
    array.set(st.brierStats1, 0, 0.0)
    array.set(st.brierStats1, 1, 0.0)
    array.set(st.llStatsN, 0, 0.0)
    array.set(st.llStatsN, 1, 0.0)
    array.set(st.llStats1, 0, 0.0)
    array.set(st.llStats1, 1, 0.0)
    // Platt Reset (Identity)
    array.set(st.plattN, 0, 1.0)
    array.set(st.plattN, 1, 0.0)
    array.set(st.platt1, 0, 1.0)
    array.set(st.platt1, 1, 0.0)
    array.set(st.tempN, 0, 1.0)
    array.set(st.temp1, 0, 1.0)
    array.set(st.vecAN, 0, 1.0)
    array.set(st.vecAN, 1, 1.0)
    array.set(st.vecAN, 2, 1.0)
    array.set(st.vecBN, 0, 0.0)
    array.set(st.vecBN, 1, 0.0)
    array.set(st.vecBN, 2, 0.0)
    array.set(st.vecA1, 0, 1.0)
    array.set(st.vecA1, 1, 1.0)
    array.set(st.vecA1, 2, 1.0)
    array.set(st.vecB1, 0, 0.0)
    array.set(st.vecB1, 1, 0.0)
    array.set(st.vecB1, 2, 0.0)

f_reset_one_state_eval(TfState st) =>
    array.clear(st.evBrierN), array.clear(st.evSumBrierN), array.clear(st.evLogN), array.clear(st.evSumLogN), array.clear(st.evYS_N), array.clear(st.evSumYS_N), array.clear(st.evYL_N), array.clear(st.evSumYL_N)
    array.fill(st.evCalCntN, 0), array.fill(st.evCalSumPN, 0.0), array.fill(st.evCalSumYN, 0.0)
    array.clear(st.evCalBBufN), array.clear(st.evCalPBufN), array.clear(st.evCalYBufN)

    array.clear(st.evBrier1), array.clear(st.evSumBrier1), array.clear(st.evLog1), array.clear(st.evSumLog1), array.clear(st.evYS_1), array.clear(st.evSumYS_1), array.clear(st.evYL_1), array.clear(st.evSumYL_1)
    array.fill(st.evCalCnt1, 0), array.fill(st.evCalSumP1, 0.0), array.fill(st.evCalSumY1, 0.0)
    array.clear(st.evCalBBuf1), array.clear(st.evCalPBuf1), array.clear(st.evCalYBuf1)

f_reset_eval_all() =>
    f_reset_one_state_eval(tf1State)
    f_reset_one_state_eval(tf2State)
    f_reset_one_state_eval(tf3State)
    f_reset_one_state_eval(tf4State)
    f_reset_one_state_eval(tf5State)
    f_reset_one_state_eval(tf6State)
    f_reset_one_state_eval(tf7State)

// Process one TF calibration step (updates on new TF bar)
// @param _hid Horizon ID (1-7) - reserved for debugging/logging
// @param newTfBar True when a new timeframe bar starts
// @param sA Algorithm score for ensemble calculation
// @param cNow Current close price
// @param hNow Current high price
// @param lNow Current low price
// @param atrNow Current ATR value
// @param volRankNow Current volatility rank [0,1]
// @param emaFNow Fast EMA value
// @param emaSNow Slow EMA value
// @param st TfState UDT containing all state arrays
// @param fcTgt Forecast target type
// @param kB K-bar horizon
// @param aThr ATR threshold
// @param pH Path horizon
// @param tpA Take-profit ATR multiplier
// @param slA Stop-loss ATR multiplier
// @param alphaNVal Alpha for N-bin smoothing
// @param alpha1Val Alpha for 1-bin smoothing
// @param shrinkKVal Shrinkage factor
// @param wAVal Weight for trend score
// @param wBVal Weight for pullback score
// @param wCVal Weight for volatility bias
// @param wDVal Weight for trend regime
f_process_tf(_hid, _tf, newTfBar, sA, 
             cNow, hNow, lNow, atrNow, volRankNow, emaFNow, emaSNow,
             TfState st,
             fcTgt, kB, aThr, pH, tpA, slA,
             alphaNVal, alpha1Val, shrinkKVal, wAVal, wBVal, wCVal, wDVal) =>

    if newTfBar
        // 1) Age/extremes update for pending items
        sz = array.size(st.qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(st.qAge, i) + 1
                array.set(st.qAge, i, age)
                mh = math.max(array.get(st.qMaxH, i), hNow)
                ml = math.min(array.get(st.qMinL, i), lNow)
                array.set(st.qMaxH, i, mh)
                array.set(st.qMinL, i, ml)

        // 2) Resolve items (descending while loop => safe with removals)
        i = array.size(st.qAge) - 1
        while i >= 0
            age_i   = array.get(st.qAge,   i)
            entry_i = array.get(st.qEntry, i)
            atr_i   = array.get(st.qAtr,   i)
            mh_i    = array.get(st.qMaxH,  i)
            ml_i    = array.get(st.qMinL,  i)
            bN_i    = array.get(st.qBinN,  i)
            b1_i    = array.get(st.qBin1,  i)
            bias_i  = array.get(st.qBias,  i)

            // Stored at entry
            float probN_i = na
            float prob1_i = na
            float lgtN_i = na
            float lgt1_i = na
            float pPredN_i = na
            float pPred1_i = na
            if not use3Way
                probN_i := array.get(st.qProbN,  i)
                prob1_i := array.get(st.qProb1,  i)
                lgtN_i  := array.get(st.qLogitN, i)
                lgt1_i  := array.get(st.qLogit1, i)
                pPredN_i := array.get(st.qPredN, i)
                pPred1_i := array.get(st.qPred1, i)

            // 3-way stored probs/logits
            float pUpN_i = na
            float pFlN_i = na
            float pDnN_i = na
            float pUp1_i = na
            float pFl1_i = na
            float pDn1_i = na
            float zUpN_i = na
            float zFlN_i = na
            float zDnN_i = na
            float zUp1_i = na
            float zFl1_i = na
            float zDn1_i = na
            if use3Way
                pUpN_i := array.get(st.qPUpN, i)
                pFlN_i := array.get(st.qPFlN, i)
                pDnN_i := array.get(st.qPDnN, i)
                pUp1_i := array.get(st.qPUp1, i)
                pFl1_i := array.get(st.qPFl1, i)
                pDn1_i := array.get(st.qPDn1, i)
                zUpN_i := array.get(st.qZUpN, i)
                zFlN_i := array.get(st.qZFlN, i)
                zDnN_i := array.get(st.qZDnN, i)
                zUp1_i := array.get(st.qZUp1, i)
                zFl1_i := array.get(st.qZFl1, i)
                zDn1_i := array.get(st.qZDn1, i)

            resolved = false
            doUpdate = false
            isUp     = false
            int outcome = 0

            // --- Phase 1: Local Target Logic ---
            if fcTgt == "NextBar"
                if age_i >= 1
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarReturn"
                if age_i >= kB
                    resolved := true
                    doUpdate := true
                    if use3Way
                        db = (na(atr_i) or atr_i == 0.0) ? 0.0 : f_db_mult(_tf) * atr_i
                        delta = cNow - entry_i
                        outcome := f_outcome3(delta, db)
                        isUp := outcome == 1
                    else
                        isUp := cNow > entry_i
                        outcome := isUp ? 1 : -1

            else if fcTgt == "KBarATR"
                if age_i >= kB
                    resolved := true
                    // Skip calibration update if ATR is invalid (prevents misleading ratios)
                    if na(atr_i) or atr_i == 0.0
                        doUpdate := false
                    else
                        doUpdate := true
                        if use3Way
                            db = f_db_mult(_tf) * atr_i
                            delta = cNow - entry_i
                            outcome := f_outcome3(delta, db)
                            isUp := outcome == 1
                        else
                            retATR = (cNow - entry_i) / atr_i
                            isUp := retATR >= aThr
                            outcome := isUp ? 1 : -1

            else // PathTPvsSL
                tpPx = entry_i + tpA * atr_i
                slPx = entry_i - slA * atr_i
                winHit  = mh_i >= tpPx
                lossHit = ml_i <= slPx

                if winHit or lossHit
                    resolved := true
                    doUpdate := true
                    if winHit and lossHit
                        if pathTiePolicy == "Win"
                            isUp := true
                            outcome := 1
                        else if pathTiePolicy == "Neutral"
                            if use3Way
                                outcome := 0
                            else
                                doUpdate := false
                        else
                            isUp := false
                            outcome := -1
                    else
                        isUp := winHit and not lossHit
                        outcome := isUp ? 1 : -1

                else if age_i >= pH
                    resolved := true
                    if noHitPolicy == "Loss"
                        doUpdate := true
                        isUp := false
                        outcome := -1
                    else if use3Way and (noHitPolicy == "Neutral" or noHitPolicy == "Ignore")
                        doUpdate := true
                        outcome := 0
                    else
                        doUpdate := false

            if resolved
                if doUpdate
                    if not use3Way
                        outcome := isUp ? 1 : -1
                    if use3Way
                        f_decay_counts(st.cntN, st.upN, st.dnN, countDecay)
                        f_decay_counts(st.cnt1, st.up1, st.dn1, countDecay)
                    f_cal_update3(st.cntN, st.upN, st.dnN, bN_i, outcome)
                    f_cal_update3(st.cnt1, st.up1, st.dn1, b1_i, outcome)

                    if use3Way and useBullBearCal
                        useBull = bias_i >= 0
                        cntN_sel = useBull ? st.cntN_bull : st.cntN_bear
                        upN_sel  = useBull ? st.upN_bull  : st.upN_bear
                        dnN_sel  = useBull ? st.dnN_bull  : st.dnN_bear
                        cnt1_sel = useBull ? st.cnt1_bull : st.cnt1_bear
                        up1_sel  = useBull ? st.up1_bull  : st.up1_bear
                        dn1_sel  = useBull ? st.dn1_bull  : st.dn1_bear
                        f_decay_counts(cntN_sel, upN_sel, dnN_sel, countDecay)
                        f_decay_counts(cnt1_sel, up1_sel, dn1_sel, countDecay)
                        f_cal_update3(cntN_sel, upN_sel, dnN_sel, bN_i, outcome)
                        f_cal_update3(cnt1_sel, up1_sel, dn1_sel, b1_i, outcome)
                    
                    outcomeVal = isUp ? 1.0 : 0.0

                    // evaluation scoring (NEW)
                    if use3Way
                        f_eval_update_one3(pUpN_i, pFlN_i, pDnN_i, outcome, st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN, st.evCalBBufN, st.evCalPBufN, st.evCalYBufN)
                        f_eval_update_one3(pUp1_i, pFl1_i, pDn1_i, outcome, st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1, st.evCalBBuf1, st.evCalPBuf1, st.evCalYBuf1)
                    else
                        f_eval_on_resolve(st, pPredN_i, pPred1_i, isUp)

                    if use3Way and calibratorMode != "Off"
                        nBinN_cur = array.get(st.cntN, bN_i)
                        nBin1_cur = array.get(st.cnt1, b1_i)
                        canCalN = not cal3AutoFallback or nBinN_cur >= cal3MinSamples
                        canCal1 = not cal3AutoFallback or nBin1_cur >= cal3MinSamples
                        yU = outcome == 1 ? 1.0 : 0.0
                        yF = outcome == 0 ? 1.0 : 0.0
                        yD = outcome == -1 ? 1.0 : 0.0

                        if calibratorMode == "Temp"
                            if canCalN
                                tN = array.get(st.tempN, 0)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(zUpN_i / tN, zFlN_i / tN, zDnN_i / tN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                gradN = ((pUNc - yU) * zUpN_i + (pFNc - yF) * zFlN_i + (pDNc - yD) * zDnN_i) / (tN * tN)
                                tN := f_clamp(tN - lrCal * gradN, tempMin, tempMax)
                                array.set(st.tempN, 0, tN)

                            if canCal1
                                t1 = array.get(st.temp1, 0)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(zUp1_i / t1, zFl1_i / t1, zDn1_i / t1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                grad1 = ((pU1c - yU) * zUp1_i + (pF1c - yF) * zFl1_i + (pD1c - yD) * zDn1_i) / (t1 * t1)
                                t1 := f_clamp(t1 - lrCal * grad1, tempMin, tempMax)
                                array.set(st.temp1, 0, t1)
                        else if calibratorMode == "Vector"
                            if canCalN
                                aUN = array.get(st.vecAN, 0)
                                aFN = array.get(st.vecAN, 1)
                                aDN = array.get(st.vecAN, 2)
                                bUN = array.get(st.vecBN, 0)
                                bFN = array.get(st.vecBN, 1)
                                bDN = array.get(st.vecBN, 2)
                                [pUNc_t, pFNc_t, pDNc_t] = f_softmax3(aUN * zUpN_i + bUN, aFN * zFlN_i + bFN, aDN * zDnN_i + bDN)
                                pUNc = pUNc_t
                                pFNc = pFNc_t
                                pDNc = pDNc_t
                                aUN := f_clamp(aUN - lrCal * (pUNc - yU) * zUpN_i, vecAMin, vecAMax)
                                aFN := f_clamp(aFN - lrCal * (pFNc - yF) * zFlN_i, vecAMin, vecAMax)
                                aDN := f_clamp(aDN - lrCal * (pDNc - yD) * zDnN_i, vecAMin, vecAMax)
                                bUN := f_clamp(bUN - lrCal * (pUNc - yU), vecBMin, vecBMax)
                                bFN := f_clamp(bFN - lrCal * (pFNc - yF), vecBMin, vecBMax)
                                bDN := f_clamp(bDN - lrCal * (pDNc - yD), vecBMin, vecBMax)
                                array.set(st.vecAN, 0, aUN)
                                array.set(st.vecAN, 1, aFN)
                                array.set(st.vecAN, 2, aDN)
                                array.set(st.vecBN, 0, bUN)
                                array.set(st.vecBN, 1, bFN)
                                array.set(st.vecBN, 2, bDN)

                            if canCal1
                                aU1 = array.get(st.vecA1, 0)
                                aF1 = array.get(st.vecA1, 1)
                                aD1 = array.get(st.vecA1, 2)
                                bU1 = array.get(st.vecB1, 0)
                                bF1 = array.get(st.vecB1, 1)
                                bD1 = array.get(st.vecB1, 2)
                                [pU1c_t, pF1c_t, pD1c_t] = f_softmax3(aU1 * zUp1_i + bU1, aF1 * zFl1_i + bF1, aD1 * zDn1_i + bD1)
                                pU1c = pU1c_t
                                pF1c = pF1c_t
                                pD1c = pD1c_t
                                aU1 := f_clamp(aU1 - lrCal * (pU1c - yU) * zUp1_i, vecAMin, vecAMax)
                                aF1 := f_clamp(aF1 - lrCal * (pF1c - yF) * zFl1_i, vecAMin, vecAMax)
                                aD1 := f_clamp(aD1 - lrCal * (pD1c - yD) * zDn1_i, vecAMin, vecAMax)
                                bU1 := f_clamp(bU1 - lrCal * (pU1c - yU), vecBMin, vecBMax)
                                bF1 := f_clamp(bF1 - lrCal * (pF1c - yF), vecBMin, vecBMax)
                                bD1 := f_clamp(bD1 - lrCal * (pD1c - yD), vecBMin, vecBMax)
                                array.set(st.vecA1, 0, aU1)
                                array.set(st.vecA1, 1, aF1)
                                array.set(st.vecA1, 2, aD1)
                                array.set(st.vecB1, 0, bU1)
                                array.set(st.vecB1, 1, bF1)
                                array.set(st.vecB1, 2, bD1)

                    // --- Phase 4: SGD Update & LogLoss (N) ---
                    // N (Gated Logic)
                    if not use3Way
                        nBinN_cur = array.get(st.cntN, bN_i)
                        if nBinN_cur >= calMinSamples
                            // Brier on raw prob
                            sqErrN = math.pow(outcomeVal - probN_i, 2)
                            curSumN = array.get(st.brierStatsN, 0)
                            curCntN = array.get(st.brierStatsN, 1)
                            array.set(st.brierStatsN, 0, curSumN + sqErrN)
                            array.set(st.brierStatsN, 1, curCntN + 1.0)
                            
                            // Platt SGD
                            if usePlatt
                                aN = array.get(st.plattN, 0)
                                bN = array.get(st.plattN, 1)
                                pAdj = f_sigmoid(aN * lgtN_i + bN)
                                err = pAdj - outcomeVal
                                da = err * lgtN_i
                                db = err
                                // Update
                                aN := math.max(0.1, math.min(5.0, aN - lrPlatt * da)) 
                                bN := math.max(-3.0, math.min(3.0, bN - lrPlatt * db))
                                array.set(st.plattN, 0, aN)
                                array.set(st.plattN, 1, bN)
                                
                                // LogLoss
                                pLL = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj))
                                ll = -(outcomeVal * math.log(pLL) + (1.0 - outcomeVal) * math.log(1.0 - pLL))
                                curSumLL = array.get(st.llStatsN, 0)
                                curCntLL = array.get(st.llStatsN, 1)
                                array.set(st.llStatsN, 0, curSumLL + ll)
                                array.set(st.llStatsN, 1, curCntLL + 1.0)
                        
                        // --- Phase 4: SGD Update & LogLoss (1) ---
                        sqErr1 = math.pow(outcomeVal - prob1_i, 2)
                        curSum1 = array.get(st.brierStats1, 0)
                        curCnt1 = array.get(st.brierStats1, 1)
                        array.set(st.brierStats1, 0, curSum1 + sqErr1)
                        array.set(st.brierStats1, 1, curCnt1 + 1.0)

                        if usePlatt
                            pltA1 = array.get(st.platt1, 0)
                            pltB1 = array.get(st.platt1, 1)
                            pAdj1 = f_sigmoid(pltA1 * lgt1_i + pltB1)
                            err1 = pAdj1 - outcomeVal
                            da1 = err1 * lgt1_i
                            db1 = err1
                            pltA1 := math.max(0.1, math.min(5.0, pltA1 - lrPlatt * da1)) 
                            pltB1 := math.max(-3.0, math.min(3.0, pltB1 - lrPlatt * db1))
                            array.set(st.platt1, 0, pltA1)
                            array.set(st.platt1, 1, pltB1)
                            
                            pLL1 = math.max(PROB_EPS, math.min(1.0 - PROB_EPS, pAdj1))
                            ll1 = -(outcomeVal * math.log(pLL1) + (1.0 - outcomeVal) * math.log(1.0 - pLL1))
                            curSumLL1 = array.get(st.llStats1, 0)
                            curCntLL1 = array.get(st.llStats1, 1)
                            array.set(st.llStats1, 0, curSumLL1 + ll1)
                            array.set(st.llStats1, 1, curCntLL1 + 1.0)

                array.remove(st.qAge,   i)
                array.remove(st.qMaxH,  i)
                array.remove(st.qMinL,  i)
                array.remove(st.qAtr,   i)
                array.remove(st.qEntry, i)
                array.remove(st.qBinN,  i)
                array.remove(st.qBin1,  i)
                array.remove(st.qBias,  i)
                if not use3Way
                    array.remove(st.qProbN, i)
                    array.remove(st.qProb1, i)
                    array.remove(st.qLogitN, i)
                    array.remove(st.qLogit1, i)
                    array.remove(st.qPredN, i)
                    array.remove(st.qPred1, i)
                if use3Way
                    array.remove(st.qPUpN, i)
                    array.remove(st.qPFlN, i)
                    array.remove(st.qPDnN, i)
                    array.remove(st.qPUp1, i)
                    array.remove(st.qPFl1, i)
                    array.remove(st.qPDn1, i)
                    array.remove(st.qZUpN, i)
                    array.remove(st.qZFlN, i)
                    array.remove(st.qZDnN, i)
                    array.remove(st.qZUp1, i)
                    array.remove(st.qZFl1, i)
                    array.remove(st.qZDn1, i)

            i -= 1

        // 3) Push new pending item
        // --- Phase 3: Ensemble Score ---
        bias = emaFNow > emaSNow ? 1 : -1
        sB = f_pullback_score(cNow, emaFNow, emaSNow, bias)
        sC = volRankNow >= VOL_THRESH_HIGH ? -1.0 : (volRankNow <= VOL_THRESH_LOW ? 1.0 : 0.0)
        // Epsilon 0.0001 prevents division by zero on penny stocks or exotic instruments with close near 0
        atrNormEns = atrNow / math.max(cNow, 0.0001)
        sD = f_trend_regime(emaFNow, emaSNow, atrNormEns)
        sEns = f_ensemble4(sA, sB, sC, sD, wAVal, wBVal, wCVal, wDVal)
        f_update_quantiles(sEns)
        
        // --- Phase 2: 2D Binning ---
        bN = f_bin2D(sEns, sD, predBinsN, dim2Bins, qCutsN)
        b1 = f_bin2D(sEns, sD, predBins1, dim2Bins, qCuts1)

        biasFlag = useBullBearCal ? f_bias_from_score(sA) : 0
        cntN_sel = useBullBearCal ? (biasFlag >= 0 ? st.cntN_bull : st.cntN_bear) : st.cntN
        upN_sel  = useBullBearCal ? (biasFlag >= 0 ? st.upN_bull  : st.upN_bear)  : st.upN
        dnN_sel  = useBullBearCal ? (biasFlag >= 0 ? st.dnN_bull  : st.dnN_bear)  : st.dnN
        cnt1_sel = useBullBearCal ? (biasFlag >= 0 ? st.cnt1_bull : st.cnt1_bear) : st.cnt1
        up1_sel  = useBullBearCal ? (biasFlag >= 0 ? st.up1_bull  : st.up1_bear)  : st.up1
        dn1_sel  = useBullBearCal ? (biasFlag >= 0 ? st.dn1_bull  : st.dn1_bear)  : st.dn1

        if use3Way
            [pUrawN_t, pFrawN_t, pDrawN_t, _nN_t] = f_cal_cur3(cntN_sel, upN_sel, dnN_sel, bN, alphaNVal, shrinkKVal, kShrinkReg)
            [pUraw1_t, pFraw1_t, pDraw1_t, _n1_t] = f_cal_cur3(cnt1_sel, up1_sel, dn1_sel, b1, alpha1Val, shrinkKVal, kShrinkReg)
            pUrawN = pUrawN_t
            pFrawN = pFrawN_t
            pDrawN = pDrawN_t
            _nN = _nN_t
            pUraw1 = pUraw1_t
            pFraw1 = pFraw1_t
            pDraw1 = pDraw1_t
            _n1 = _n1_t

            zUN = f_safe_log(pUrawN)
            zFN = f_safe_log(pFrawN)
            zDN = f_safe_log(pDrawN)
            zU1 = f_safe_log(pUraw1)
            zF1 = f_safe_log(pFraw1)
            zD1 = f_safe_log(pDraw1)

            useCalN = f_can_cal3(_nN)
            useCal1 = f_can_cal3(_n1)
            float pUN = na
            float pFN = na
            float pDN = na
            float pU1 = na
            float pF1 = na
            float pD1 = na
            if useCalN
                [tUN_t, tFN_t, tDN_t] = f_cal_apply(zUN, zFN, zDN, st.tempN, st.vecAN, st.vecBN)
                pUN := tUN_t
                pFN := tFN_t
                pDN := tDN_t
            else
                pUN := pUrawN
                pFN := pFrawN
                pDN := pDrawN
            if useCal1
                [tU1_t, tF1_t, tD1_t] = f_cal_apply(zU1, zF1, zD1, st.temp1, st.vecA1, st.vecB1)
                pU1 := tU1_t
                pF1 := tF1_t
                pD1 := tD1_t
            else
                pU1 := pUraw1
                pF1 := pFraw1
                pD1 := pDraw1

            array.push(st.qBinN,  bN)
            array.push(st.qBin1,  b1)
            array.push(st.qEntry, cNow)
            array.push(st.qAtr,   atrNow)

            array.push(st.qMaxH,  cNow)
            array.push(st.qMinL,  cNow)

            array.push(st.qAge,   0)
            array.push(st.qBias,  biasFlag)

            array.push(st.qPUpN, pUN)
            array.push(st.qPFlN, pFN)
            array.push(st.qPDnN, pDN)
            array.push(st.qPUp1, pU1)
            array.push(st.qPFl1, pF1)
            array.push(st.qPDn1, pD1)

            array.push(st.qZUpN, zUN)
            array.push(st.qZFlN, zFN)
            array.push(st.qZDnN, zDN)
            array.push(st.qZUp1, zU1)
            array.push(st.qZFl1, zF1)
            array.push(st.qZDn1, zD1)
        else
            // Capture current probabilities
            [pNowN_t, _nN_t] = f_cal_cur(st.cntN, st.upN, bN, alphaNVal, shrinkKVal)
            [pNow1_t, _n1_t] = f_cal_cur(st.cnt1, st.up1, b1, alpha1Val, shrinkKVal)
            pNowN = pNowN_t
            _nN = _nN_t
            pNow1 = pNow1_t
            _n1 = _n1_t

            // Logits (Phase 4)
            lgtN = f_logit(pNowN)
            lgt1 = f_logit(pNow1)

            array.push(st.qBinN,  bN)
            array.push(st.qBin1,  b1)
            array.push(st.qEntry, cNow)
            array.push(st.qAtr,   atrNow)

            array.push(st.qMaxH,  cNow)
            array.push(st.qMinL,  cNow)

            array.push(st.qAge,   0)
            array.push(st.qBias,  biasFlag)

            array.push(st.qProbN, pNowN)
            array.push(st.qProb1, pNow1)
            array.push(st.qLogitN, lgtN)
            array.push(st.qLogit1, lgt1)

            array.push(st.qPredN, pNowN)
            array.push(st.qPred1, pNow1)
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ? ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("300")) ? rsiLenFastTF : (not na(baseSecs) and baseSecs <= timeframe.in_seconds("3600")) ? rsiLenMidTF : rsiLenSlowTF) : rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime (protect against close=0 on exotic instruments)
atrRank = close == 0 ? 0.5 : f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? nz(volRankRaw, 0.5) : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // global per-bar
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor = crsi < crsiLongPanic ? crsiLongPanicMult : crsi > crsiLongOver  ? crsiLongOverMult  : (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor = crsi < crsiShortExhaust ? crsiShortExhaustMult : crsi > crsiShortOver    ? crsiShortOverMult    : (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)

    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier = config == "Standard" ? 1.00 : config == "Pro" ? 1.05 : config == "V2 Essential" ? 0.95 : config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30")) ? "Short" : (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown
gateLongNow  = (confidence >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidence >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice = zoneAnchor == "Entry" and not na(entryPrice) ? entryPrice : zoneAnchor == "VWAP" ? vwapVal : zoneAnchor == "MA200" ? sma200Val : zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = ta.crossover(emaF, emaS)
trendFlipDown = ta.crossunder(emaF, emaS)
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "â€”"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)

f_getBrier(tfSel, modSel) =>
    float score = 0.5 // default safe
    
    // Select array pair stats
    float[] stats = na
    if tfSel == "F1"
        stats := (modSel == "N") ? tf1State.brierStatsN : tf1State.brierStats1
    else if tfSel == "F2"
        stats := (modSel == "N") ? tf2State.brierStatsN : tf2State.brierStats1
    else if tfSel == "F3"
        stats := (modSel == "N") ? tf3State.brierStatsN : tf3State.brierStats1
    else if tfSel == "F4"
        stats := (modSel == "N") ? tf4State.brierStatsN : tf4State.brierStats1
    else if tfSel == "F5"
        stats := (modSel == "N") ? tf5State.brierStatsN : tf5State.brierStats1
    else if tfSel == "F6"
        stats := (modSel == "N") ? tf6State.brierStatsN : tf6State.brierStats1
    else if tfSel == "F7"
        stats := (modSel == "N") ? tf7State.brierStatsN : tf7State.brierStats1
    
    if not na(stats)
        s = array.get(stats, 0)
        c = array.get(stats, 1)
        if c > 0
            score := s / c
    score

f_get_total_samples(tfSel, modSel) =>
    float total = 0.0
    float[] cnt = na
    if tfSel == "F1"
        cnt := (modSel == "N") ? tf1State.cntN : tf1State.cnt1
    else if tfSel == "F2"
        cnt := (modSel == "N") ? tf2State.cntN : tf2State.cnt1
    else if tfSel == "F3"
        cnt := (modSel == "N") ? tf3State.cntN : tf3State.cnt1
    else if tfSel == "F4"
        cnt := (modSel == "N") ? tf4State.cntN : tf4State.cnt1
    else if tfSel == "F5"
        cnt := (modSel == "N") ? tf5State.cntN : tf5State.cnt1
    else if tfSel == "F6"
        cnt := (modSel == "N") ? tf6State.cntN : tf6State.cnt1
    else if tfSel == "F7"
        cnt := (modSel == "N") ? tf7State.cntN : tf7State.cnt1

    if not na(cnt)
        total := array.sum(cnt)
    total

var float totN1 = na
var float totN2 = na
var float totN3 = na
var float totN4 = na
var float totN5 = na
var float totN6 = na
var float totN7 = na
var float tot11 = na
var float tot12 = na
var float tot13 = na
var float tot14 = na
var float tot15 = na
var float tot16 = na
var float tot17 = na

var float pUN1 = na
var float pFN1 = na
var float pDN1 = na
var float pUN2 = na
var float pFN2 = na
var float pDN2 = na
var float pUN3 = na
var float pFN3 = na
var float pDN3 = na
var float pUN4 = na
var float pFN4 = na
var float pDN4 = na
var float pUN5 = na
var float pFN5 = na
var float pDN5 = na
var float pUN6 = na
var float pFN6 = na
var float pDN6 = na
var float pUN7 = na
var float pFN7 = na
var float pDN7 = na

var float nN1 = na
var float nN2 = na
var float nN3 = na
var float nN4 = na
var float nN5 = na
var float nN6 = na
var float nN7 = na

var float pU11 = na
var float pF11 = na
var float pD11 = na
var float pU12 = na
var float pF12 = na
var float pD12 = na
var float pU13 = na
var float pF13 = na
var float pD13 = na
var float pU14 = na
var float pF14 = na
var float pD14 = na
var float pU15 = na
var float pF15 = na
var float pD15 = na
var float pU16 = na
var float pF16 = na
var float pD16 = na
var float pU17 = na
var float pF17 = na
var float pD17 = na

var float n11p = na
var float n12p = na
var float n13p = na
var float n14p = na
var float n15p = na
var float n16p = na
var float n17p = na

f_get_rel_vals(tfSel, modSel) =>
    float pU = na
    float pF = na
    float pD = na
    float nBin = na
    float total = na
    if modSel == "N"
        if tfSel == "F1"
            pU := pUN1, pF := pFN1, pD := pDN1, nBin := nN1, total := totN1
        else if tfSel == "F2"
            pU := pUN2, pF := pFN2, pD := pDN2, nBin := nN2, total := totN2
        else if tfSel == "F3"
            pU := pUN3, pF := pFN3, pD := pDN3, nBin := nN3, total := totN3
        else if tfSel == "F4"
            pU := pUN4, pF := pFN4, pD := pDN4, nBin := nN4, total := totN4
        else if tfSel == "F5"
            pU := pUN5, pF := pFN5, pD := pDN5, nBin := nN5, total := totN5
        else if tfSel == "F6"
            pU := pUN6, pF := pFN6, pD := pDN6, nBin := nN6, total := totN6
        else if tfSel == "F7"
            pU := pUN7, pF := pFN7, pD := pDN7, nBin := nN7, total := totN7
    else
        if tfSel == "F1"
            pU := pU11, pF := pF11, pD := pD11, nBin := n11p, total := tot11
        else if tfSel == "F2"
            pU := pU12, pF := pF12, pD := pD12, nBin := n12p, total := tot12
        else if tfSel == "F3"
            pU := pU13, pF := pF13, pD := pD13, nBin := n13p, total := tot13
        else if tfSel == "F4"
            pU := pU14, pF := pF14, pD := pD14, nBin := n14p, total := tot14
        else if tfSel == "F5"
            pU := pU15, pF := pF15, pD := pD15, nBin := n15p, total := tot15
        else if tfSel == "F6"
            pU := pU16, pF := pF16, pD := pD16, nBin := n16p, total := tot16
        else if tfSel == "F7"
            pU := pU17, pF := pF17, pD := pD17, nBin := n17p, total := tot17
    [pU, pF, pD, nBin, total]

f_decision_quality(pU, pF, pD, nBin, total) =>
    maxP = math.max(pU, math.max(pF, pD))
    minP = math.min(pU, math.min(pF, pD))
    midP = (pU + pF + pD) - maxP - minP
    edge = maxP - midP
    totalOk = (not evidenceGate) or (total >= evidenceMinTotal)
    ok = (not use3Way) ? true : (edge >= abstainMinEdge and nBin >= calMinSamples and totalOk)
    reason = (evidenceGate and total < evidenceMinTotal) ? "low total" : nBin < calMinSamples ? "weak bin" : edge < abstainMinEdge ? "low edge" : "ok"
    label = ok ? "OK" : "ABSTAIN (" + reason + ")"
    col = ok ? color.lime : color.orange
    [ok, label, col, edge]

curBrier = f_getBrier(relFilterTF, relFilterModel)
reliabilityOk = (not useRelFilter) or (curBrier <= maxBrier)
evidenceOk = (not evidenceGate) or (f_get_total_samples(relFilterTF, relFilterModel) >= evidenceMinTotal)

[pRelU_t, pRelF_t, pRelD_t, nRel_t, totRel_t] = f_get_rel_vals(relFilterTF, relFilterModel)
pRelU = pRelU_t
pRelF = pRelF_t
pRelD = pRelD_t
nRel = nRel_t
totRel = totRel_t
[decisionOk_t, decisionLabel_t, decisionColor_t, decisionEdge_t] = f_decision_quality(pRelU, pRelF, pRelD, nRel, totRel)
decisionOk = decisionOk_t
decisionLabel = decisionLabel_t
decisionColor = decisionColor_t
decisionEdge = decisionEdge_t
decisionEdgeTxt = (not use3Way or na(decisionEdge)) ? "â€”" : str.tostring(decisionEdge * 100.0, "#.1") + "pp"

allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose and reliabilityOk and evidenceOk and (not abstainGate or decisionOk)
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 25))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Outlook/Forecast packs (one security call per horizon TF)
//====================
[t1_t, c1_t, h1_t, l1_t, ef1_t, es1_t, r1_t, a1_t, vR1_t] = f_tf_pack(tfF1)
[t2_t, c2_t, h2_t, l2_t, ef2_t, es2_t, r2_t, a2_t, vR2_t] = f_tf_pack(tfF2)
[t3_t, c3_t, h3_t, l3_t, ef3_t, es3_t, r3_t, a3_t, vR3_t] = f_tf_pack(tfF3)
[t4_t, c4_t, h4_t, l4_t, ef4_t, es4_t, r4_t, a4_t, vR4_t] = f_tf_pack(tfF4)
[t5_t, c5_t, h5_t, l5_t, ef5_t, es5_t, r5_t, a5_t, vR5_t] = f_tf_pack(tfF5)
[t6_t, c6_t, h6_t, l6_t, ef6_t, es6_t, r6_t, a6_t, vR6_t] = f_tf_pack(tfF6)
[t7_t, c7_t, h7_t, l7_t, ef7_t, es7_t, r7_t, a7_t, vR7_t] = f_tf_pack(tfF7)
t1 = t1_t, c1 = c1_t, h1 = h1_t, l1 = l1_t, ef1 = ef1_t, es1 = es1_t, r1 = r1_t, a1 = a1_t, vR1 = vR1_t
t2 = t2_t, c2 = c2_t, h2 = h2_t, l2 = l2_t, ef2 = ef2_t, es2 = es2_t, r2 = r2_t, a2 = a2_t, vR2 = vR2_t
t3 = t3_t, c3 = c3_t, h3 = h3_t, l3 = l3_t, ef3 = ef3_t, es3 = es3_t, r3 = r3_t, a3 = a3_t, vR3 = vR3_t
t4 = t4_t, c4 = c4_t, h4 = h4_t, l4 = l4_t, ef4 = ef4_t, es4 = es4_t, r4 = r4_t, a4 = a4_t, vR4 = vR4_t
t5 = t5_t, c5 = c5_t, h5 = h5_t, l5 = l5_t, ef5 = ef5_t, es5 = es5_t, r5 = r5_t, a5 = a5_t, vR5 = vR5_t
t6 = t6_t, c6 = c6_t, h6 = h6_t, l6 = l6_t, ef6 = ef6_t, es6 = es6_t, r6 = r6_t, a6 = a6_t, vR6 = vR6_t
t7 = t7_t, c7 = c7_t, h7 = h7_t, l7 = l7_t, ef7 = ef7_t, es7 = es7_t, r7 = r7_t, a7 = a7_t, vR7 = vR7_t

chgT1 = ta.change(t1)
chgT2 = ta.change(t2)
chgT3 = ta.change(t3)
chgT4 = ta.change(t4)
chgT5 = ta.change(t5)
chgT6 = ta.change(t6)
chgT7 = ta.change(t7)

newF1 = not na(t1) and (chgT1 != 0)
newF2 = not na(t2) and (chgT2 != 0)
newF3 = not na(t3) and (chgT3 != 0)
newF4 = not na(t4) and (chgT4 != 0)
newF5 = not na(t5) and (chgT5 != 0)
newF6 = not na(t6) and (chgT6 != 0)
newF7 = not na(t7) and (chgT7 != 0)

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

[t1c_t, m1c_t, l1c_t] = f_state_tml(c1, ef1, es1, r1)
[t2c_t, m2c_t, l2c_t] = f_state_tml(c2, ef2, es2, r2)
[t3c_t, m3c_t, l3c_t] = f_state_tml(c3, ef3, es3, r3)
[t4c_t, m4c_t, l4c_t] = f_state_tml(c4, ef4, es4, r4)
[t5c_t, m5c_t, l5c_t] = f_state_tml(c5, ef5, es5, r5)
[t6c_t, m6c_t, l6c_t] = f_state_tml(c6, ef6, es6, r6)
[t7c_t, m7c_t, l7c_t] = f_state_tml(c7, ef7, es7, r7)
t1c = t1c_t, m1c = m1c_t, l1c = l1c_t
t2c = t2c_t, m2c = m2c_t, l2c = l2c_t
t3c = t3c_t, m3c = m3c_t, l3c = l3c_t
t4c = t4c_t, m4c = m4c_t, l4c = l4c_t
t5c = t5c_t, m5c = m5c_t, l5c = l5c_t
t6c = t6c_t, m6c = m6c_t, l6c = l6c_t
t7c = t7c_t, m7c = m7c_t, l7c = l7c_t

outSym(score) => score > 0.05 ? "â–²" : score < -0.05 ? "â–¼" : "âˆ’"
outCol(score) => score > 0.05 ? color.lime : score < -0.05 ? color.red : tblText

isBull1 = f_bias_from_score(outScore1) == 1
isBull2 = f_bias_from_score(outScore2) == 1
isBull3 = f_bias_from_score(outScore3) == 1
isBull4 = f_bias_from_score(outScore4) == 1
isBull5 = f_bias_from_score(outScore5) == 1
isBull6 = f_bias_from_score(outScore6) == 1
isBull7 = f_bias_from_score(outScore7) == 1

cntN1Arr = useBullBearCal ? (isBull1 ? tf1State.cntN_bull : tf1State.cntN_bear) : tf1State.cntN
upN1Arr  = useBullBearCal ? (isBull1 ? tf1State.upN_bull  : tf1State.upN_bear)  : tf1State.upN
dnN1Arr  = useBullBearCal ? (isBull1 ? tf1State.dnN_bull  : tf1State.dnN_bear)  : tf1State.dnN
cnt11Arr = useBullBearCal ? (isBull1 ? tf1State.cnt1_bull : tf1State.cnt1_bear) : tf1State.cnt1
up11Arr  = useBullBearCal ? (isBull1 ? tf1State.up1_bull  : tf1State.up1_bear)  : tf1State.up1
dn11Arr  = useBullBearCal ? (isBull1 ? tf1State.dn1_bull  : tf1State.dn1_bear)  : tf1State.dn1

cntN2Arr = useBullBearCal ? (isBull2 ? tf2State.cntN_bull : tf2State.cntN_bear) : tf2State.cntN
upN2Arr  = useBullBearCal ? (isBull2 ? tf2State.upN_bull  : tf2State.upN_bear)  : tf2State.upN
dnN2Arr  = useBullBearCal ? (isBull2 ? tf2State.dnN_bull  : tf2State.dnN_bear)  : tf2State.dnN
cnt12Arr = useBullBearCal ? (isBull2 ? tf2State.cnt1_bull : tf2State.cnt1_bear) : tf2State.cnt1
up12Arr  = useBullBearCal ? (isBull2 ? tf2State.up1_bull  : tf2State.up1_bear)  : tf2State.up1
dn12Arr  = useBullBearCal ? (isBull2 ? tf2State.dn1_bull  : tf2State.dn1_bear)  : tf2State.dn1

cntN3Arr = useBullBearCal ? (isBull3 ? tf3State.cntN_bull : tf3State.cntN_bear) : tf3State.cntN
upN3Arr  = useBullBearCal ? (isBull3 ? tf3State.upN_bull  : tf3State.upN_bear)  : tf3State.upN
dnN3Arr  = useBullBearCal ? (isBull3 ? tf3State.dnN_bull  : tf3State.dnN_bear)  : tf3State.dnN
cnt13Arr = useBullBearCal ? (isBull3 ? tf3State.cnt1_bull : tf3State.cnt1_bear) : tf3State.cnt1
up13Arr  = useBullBearCal ? (isBull3 ? tf3State.up1_bull  : tf3State.up1_bear)  : tf3State.up1
dn13Arr  = useBullBearCal ? (isBull3 ? tf3State.dn1_bull  : tf3State.dn1_bear)  : tf3State.dn1

cntN4Arr = useBullBearCal ? (isBull4 ? tf4State.cntN_bull : tf4State.cntN_bear) : tf4State.cntN
upN4Arr  = useBullBearCal ? (isBull4 ? tf4State.upN_bull  : tf4State.upN_bear)  : tf4State.upN
dnN4Arr  = useBullBearCal ? (isBull4 ? tf4State.dnN_bull  : tf4State.dnN_bear)  : tf4State.dnN
cnt14Arr = useBullBearCal ? (isBull4 ? tf4State.cnt1_bull : tf4State.cnt1_bear) : tf4State.cnt1
up14Arr  = useBullBearCal ? (isBull4 ? tf4State.up1_bull  : tf4State.up1_bear)  : tf4State.up1
dn14Arr  = useBullBearCal ? (isBull4 ? tf4State.dn1_bull  : tf4State.dn1_bear)  : tf4State.dn1

cntN5Arr = useBullBearCal ? (isBull5 ? tf5State.cntN_bull : tf5State.cntN_bear) : tf5State.cntN
upN5Arr  = useBullBearCal ? (isBull5 ? tf5State.upN_bull  : tf5State.upN_bear)  : tf5State.upN
dnN5Arr  = useBullBearCal ? (isBull5 ? tf5State.dnN_bull  : tf5State.dnN_bear)  : tf5State.dnN
cnt15Arr = useBullBearCal ? (isBull5 ? tf5State.cnt1_bull : tf5State.cnt1_bear) : tf5State.cnt1
up15Arr  = useBullBearCal ? (isBull5 ? tf5State.up1_bull  : tf5State.up1_bear)  : tf5State.up1
dn15Arr  = useBullBearCal ? (isBull5 ? tf5State.dn1_bull  : tf5State.dn1_bear)  : tf5State.dn1

cntN6Arr = useBullBearCal ? (isBull6 ? tf6State.cntN_bull : tf6State.cntN_bear) : tf6State.cntN
upN6Arr  = useBullBearCal ? (isBull6 ? tf6State.upN_bull  : tf6State.upN_bear)  : tf6State.upN
dnN6Arr  = useBullBearCal ? (isBull6 ? tf6State.dnN_bull  : tf6State.dnN_bear)  : tf6State.dnN
cnt16Arr = useBullBearCal ? (isBull6 ? tf6State.cnt1_bull : tf6State.cnt1_bear) : tf6State.cnt1
up16Arr  = useBullBearCal ? (isBull6 ? tf6State.up1_bull  : tf6State.up1_bear)  : tf6State.up1
dn16Arr  = useBullBearCal ? (isBull6 ? tf6State.dn1_bull  : tf6State.dn1_bear)  : tf6State.dn1

cntN7Arr = useBullBearCal ? (isBull7 ? tf7State.cntN_bull : tf7State.cntN_bear) : tf7State.cntN
upN7Arr  = useBullBearCal ? (isBull7 ? tf7State.upN_bull  : tf7State.upN_bear)  : tf7State.upN
dnN7Arr  = useBullBearCal ? (isBull7 ? tf7State.dnN_bull  : tf7State.dnN_bear)  : tf7State.dnN
cnt17Arr = useBullBearCal ? (isBull7 ? tf7State.cnt1_bull : tf7State.cnt1_bear) : tf7State.cnt1
up17Arr  = useBullBearCal ? (isBull7 ? tf7State.up1_bull  : tf7State.up1_bear)  : tf7State.up1
dn17Arr  = useBullBearCal ? (isBull7 ? tf7State.dn1_bull  : tf7State.dn1_bear)  : tf7State.dn1

//====================
// Calibration storage â€” per horizon TF (Removed - moved to top)
//====================
// (Moved to top level state)

//====================
// Reset handling (rising edge) â€” per horizon F1..F7
//====================
var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All"
        f_reset_eval_all()
    
    if resetWhich == "All" or resetWhich == "F1"
        f_reset_tf(tf1State)
    if resetWhich == "All" or resetWhich == "F2"
        f_reset_tf(tf2State)
    if resetWhich == "All" or resetWhich == "F3"
        f_reset_tf(tf3State)
    if resetWhich == "All" or resetWhich == "F4"
        f_reset_tf(tf4State)
    if resetWhich == "All" or resetWhich == "F5"
        f_reset_tf(tf5State)
    if resetWhich == "All" or resetWhich == "F6"
        f_reset_tf(tf6State)
    if resetWhich == "All" or resetWhich == "F7"
        f_reset_tf(tf7State)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed and (showTable or showEvalSection)
if doCal
    // F1
    [fc1_t, kb1_t, at1_t, ph1_t, tp1_t, sl1_t] = f_get_params(tfF1)
    fc1 = fc1_t, kb1 = kb1_t, at1 = at1_t, ph1 = ph1_t, tp1 = tp1_t, sl1 = sl1_t
    f_process_tf(1, tfF1, newF1, outScore1, c1, h1, l1, a1, vR1, ef1, es1, 
         tf1State,
         fc1, kb1, at1, ph1, tp1, sl1,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

    // F2
    [fc2_t, kb2_t, at2_t, ph2_t, tp2_t, sl2_t] = f_get_params(tfF2)
    fc2 = fc2_t, kb2 = kb2_t, at2 = at2_t, ph2 = ph2_t, tp2 = tp2_t, sl2 = sl2_t
    f_process_tf(2, tfF2, newF2, outScore2, c2, h2, l2, a2, vR2, ef2, es2, 
         tf2State,
         fc2, kb2, at2, ph2, tp2, sl2,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

    // F3
    [fc3_t, kb3_t, at3_t, ph3_t, tp3_t, sl3_t] = f_get_params(tfF3)
    fc3 = fc3_t, kb3 = kb3_t, at3 = at3_t, ph3 = ph3_t, tp3 = tp3_t, sl3 = sl3_t
    f_process_tf(3, tfF3, newF3, outScore3, c3, h3, l3, a3, vR3, ef3, es3, 
         tf3State,
         fc3, kb3, at3, ph3, tp3, sl3,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

    // F4
    [fc4_t, kb4_t, at4_t, ph4_t, tp4_t, sl4_t] = f_get_params(tfF4)
    fc4 = fc4_t, kb4 = kb4_t, at4 = at4_t, ph4 = ph4_t, tp4 = tp4_t, sl4 = sl4_t
    f_process_tf(4, tfF4, newF4, outScore4, c4, h4, l4, a4, vR4, ef4, es4, 
         tf4State,
         fc4, kb4, at4, ph4, tp4, sl4,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

    // F5
    [fc5_t, kb5_t, at5_t, ph5_t, tp5_t, sl5_t] = f_get_params(tfF5)
    fc5 = fc5_t, kb5 = kb5_t, at5 = at5_t, ph5 = ph5_t, tp5 = tp5_t, sl5 = sl5_t
    f_process_tf(5, tfF5, newF5, outScore5, c5, h5, l5, a5, vR5, ef5, es5, 
         tf5State,
         fc5, kb5, at5, ph5, tp5, sl5,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

    // F6
    [fc6_t, kb6_t, at6_t, ph6_t, tp6_t, sl6_t] = f_get_params(tfF6)
    fc6 = fc6_t, kb6 = kb6_t, at6 = at6_t, ph6 = ph6_t, tp6 = tp6_t, sl6 = sl6_t
    f_process_tf(6, tfF6, newF6, outScore6, c6, h6, l6, a6, vR6, ef6, es6, 
         tf6State,
         fc6, kb6, at6, ph6, tp6, sl6,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

    // F7
    [fc7_t, kb7_t, at7_t, ph7_t, tp7_t, sl7_t] = f_get_params(tfF7)
    fc7 = fc7_t, kb7 = kb7_t, at7 = at7_t, ph7 = ph7_t, tp7 = tp7_t, sl7 = sl7_t
    f_process_tf(7, tfF7, newF7, outScore7, c7, h7, l7, a7, vR7, ef7, es7, 
         tf7State,
         fc7, kb7, at7, ph7, tp7, sl7,
         alphaN, alpha1, kShrink, wState, wPullback, wRegime, wTrend)

//====================
// Display values â€” N (Calibrated) per horizon
//====================
f_get_disp_prob(sA, c, h, l, a, vR, ef, es, wA, wB, wC, wD, cnt, up, dn, bins, alpha, shrink, tempArr, vecA, vecB) =>
    bias = ef > es ? 1 : -1
    sB = f_pullback_score(c, ef, es, bias)
    sC = vR >= VOL_THRESH_HIGH ? -1.0 : (vR <= VOL_THRESH_LOW ? 1.0 : 0.0)
    // Epsilon 0.0001 prevents division by zero on penny stocks or exotic instruments
    atrNormDisp = a / math.max(c, 0.0001)
    sD = f_trend_regime(ef, es, atrNormDisp)
    sEns = f_ensemble4(sA, sB, sC, sD, wA, wB, wC, wD)
    cutsArr = bins == predBinsN ? qCutsN : qCuts1
    b = f_bin2D(sEns, sD, bins, dim2Bins, cutsArr)
    [pU_t, pF_t, pD_t, nRaw_t] = f_cal_cur3(cnt, up, dn, b, alpha, shrink, kShrinkReg)
    pU = pU_t
    pF = pF_t
    pD = pD_t
    nRaw = nRaw_t
    useCal = f_can_cal3(nRaw)
    if useCal
        zU = f_safe_log(pU)
        zF = f_safe_log(pF)
        zD = f_safe_log(pD)
        [tU_t, tF_t, tD_t] = f_cal_apply(zU, zF, zD, tempArr, vecA, vecB)
        pU := tU_t
        pF := tF_t
        pD := tD_t
    [pU, pF, pD, nRaw]

[pUN1_t, pFN1_t, pDN1_t, nN1_t] = f_get_disp_prob(outScore1, c1, h1, l1, a1, vR1, ef1, es1, wState, wPullback, wRegime, wTrend, cntN1Arr, upN1Arr, dnN1Arr, predBinsN, alphaN, kShrink, tf1State.tempN, tf1State.vecAN, tf1State.vecBN)
[pUN2_t, pFN2_t, pDN2_t, nN2_t] = f_get_disp_prob(outScore2, c2, h2, l2, a2, vR2, ef2, es2, wState, wPullback, wRegime, wTrend, cntN2Arr, upN2Arr, dnN2Arr, predBinsN, alphaN, kShrink, tf2State.tempN, tf2State.vecAN, tf2State.vecBN)
[pUN3_t, pFN3_t, pDN3_t, nN3_t] = f_get_disp_prob(outScore3, c3, h3, l3, a3, vR3, ef3, es3, wState, wPullback, wRegime, wTrend, cntN3Arr, upN3Arr, dnN3Arr, predBinsN, alphaN, kShrink, tf3State.tempN, tf3State.vecAN, tf3State.vecBN)
[pUN4_t, pFN4_t, pDN4_t, nN4_t] = f_get_disp_prob(outScore4, c4, h4, l4, a4, vR4, ef4, es4, wState, wPullback, wRegime, wTrend, cntN4Arr, upN4Arr, dnN4Arr, predBinsN, alphaN, kShrink, tf4State.tempN, tf4State.vecAN, tf4State.vecBN)
[pUN5_t, pFN5_t, pDN5_t, nN5_t] = f_get_disp_prob(outScore5, c5, h5, l5, a5, vR5, ef5, es5, wState, wPullback, wRegime, wTrend, cntN5Arr, upN5Arr, dnN5Arr, predBinsN, alphaN, kShrink, tf5State.tempN, tf5State.vecAN, tf5State.vecBN)
[pUN6_t, pFN6_t, pDN6_t, nN6_t] = f_get_disp_prob(outScore6, c6, h6, l6, a6, vR6, ef6, es6, wState, wPullback, wRegime, wTrend, cntN6Arr, upN6Arr, dnN6Arr, predBinsN, alphaN, kShrink, tf6State.tempN, tf6State.vecAN, tf6State.vecBN)
[pUN7_t, pFN7_t, pDN7_t, nN7_t] = f_get_disp_prob(outScore7, c7, h7, l7, a7, vR7, ef7, es7, wState, wPullback, wRegime, wTrend, cntN7Arr, upN7Arr, dnN7Arr, predBinsN, alphaN, kShrink, tf7State.tempN, tf7State.vecAN, tf7State.vecBN)

[pU11_t, pF11_t, pD11_t, n11p_t] = f_get_disp_prob(outScore1, c1, h1, l1, a1, vR1, ef1, es1, wState, wPullback, wRegime, wTrend, cnt11Arr, up11Arr, dn11Arr, predBins1, alpha1, kShrink, tf1State.temp1, tf1State.vecA1, tf1State.vecB1)
[pU12_t, pF12_t, pD12_t, n12p_t] = f_get_disp_prob(outScore2, c2, h2, l2, a2, vR2, ef2, es2, wState, wPullback, wRegime, wTrend, cnt12Arr, up12Arr, dn12Arr, predBins1, alpha1, kShrink, tf2State.temp1, tf2State.vecA1, tf2State.vecB1)
[pU13_t, pF13_t, pD13_t, n13p_t] = f_get_disp_prob(outScore3, c3, h3, l3, a3, vR3, ef3, es3, wState, wPullback, wRegime, wTrend, cnt13Arr, up13Arr, dn13Arr, predBins1, alpha1, kShrink, tf3State.temp1, tf3State.vecA1, tf3State.vecB1)
[pU14_t, pF14_t, pD14_t, n14p_t] = f_get_disp_prob(outScore4, c4, h4, l4, a4, vR4, ef4, es4, wState, wPullback, wRegime, wTrend, cnt14Arr, up14Arr, dn14Arr, predBins1, alpha1, kShrink, tf4State.temp1, tf4State.vecA1, tf4State.vecB1)
[pU15_t, pF15_t, pD15_t, n15p_t] = f_get_disp_prob(outScore5, c5, h5, l5, a5, vR5, ef5, es5, wState, wPullback, wRegime, wTrend, cnt15Arr, up15Arr, dn15Arr, predBins1, alpha1, kShrink, tf5State.temp1, tf5State.vecA1, tf5State.vecB1)
[pU16_t, pF16_t, pD16_t, n16p_t] = f_get_disp_prob(outScore6, c6, h6, l6, a6, vR6, ef6, es6, wState, wPullback, wRegime, wTrend, cnt16Arr, up16Arr, dn16Arr, predBins1, alpha1, kShrink, tf6State.temp1, tf6State.vecA1, tf6State.vecB1)
[pU17_t, pF17_t, pD17_t, n17p_t] = f_get_disp_prob(outScore7, c7, h7, l7, a7, vR7, ef7, es7, wState, wPullback, wRegime, wTrend, cnt17Arr, up17Arr, dn17Arr, predBins1, alpha1, kShrink, tf7State.temp1, tf7State.vecA1, tf7State.vecB1)

pUN1 := pUN1_t, pFN1 := pFN1_t, pDN1 := pDN1_t, nN1 := nN1_t
pUN2 := pUN2_t, pFN2 := pFN2_t, pDN2 := pDN2_t, nN2 := nN2_t
pUN3 := pUN3_t, pFN3 := pFN3_t, pDN3 := pDN3_t, nN3 := nN3_t
pUN4 := pUN4_t, pFN4 := pFN4_t, pDN4 := pDN4_t, nN4 := nN4_t
pUN5 := pUN5_t, pFN5 := pFN5_t, pDN5 := pDN5_t, nN5 := nN5_t
pUN6 := pUN6_t, pFN6 := pFN6_t, pDN6 := pDN6_t, nN6 := nN6_t
pUN7 := pUN7_t, pFN7 := pFN7_t, pDN7 := pDN7_t, nN7 := nN7_t

pU11 := pU11_t, pF11 := pF11_t, pD11 := pD11_t, n11p := n11p_t
pU12 := pU12_t, pF12 := pF12_t, pD12 := pD12_t, n12p := n12p_t
pU13 := pU13_t, pF13 := pF13_t, pD13 := pD13_t, n13p := n13p_t
pU14 := pU14_t, pF14 := pF14_t, pD14 := pD14_t, n14p := n14p_t
pU15 := pU15_t, pF15 := pF15_t, pD15 := pD15_t, n15p := n15p_t
pU16 := pU16_t, pF16 := pF16_t, pD16 := pD16_t, n16p := n16p_t
pU17 := pU17_t, pF17 := pF17_t, pD17 := pD17_t, n17p := n17p_t

// --- Total resolved samples per TF (across all bins)
// (These totals will usually be identical for (N) and (1) because both get updated from the same resolved events.)
totN1 := f_sum_int_array(cntN1Arr)
totN2 := f_sum_int_array(cntN2Arr)
totN3 := f_sum_int_array(cntN3Arr)
totN4 := f_sum_int_array(cntN4Arr)
totN5 := f_sum_int_array(cntN5Arr)
totN6 := f_sum_int_array(cntN6Arr)
totN7 := f_sum_int_array(cntN7Arr)

tot11 := f_sum_int_array(cnt11Arr)
tot12 := f_sum_int_array(cnt12Arr)
tot13 := f_sum_int_array(cnt13Arr)
tot14 := f_sum_int_array(cnt14Arr)
tot15 := f_sum_int_array(cnt15Arr)
tot16 := f_sum_int_array(cnt16Arr)
tot17 := f_sum_int_array(cnt17Arr)

// calibration â€œenabled for displayâ€ if forecast enabled + we have any resolved samples in that TF
canF1N = enableForecast and (totN1 > 0)
canF2N = enableForecast and (totN2 > 0)
canF3N = enableForecast and (totN3 > 0)
canF4N = enableForecast and (totN4 > 0)
canF5N = enableForecast and (totN5 > 0)
canF6N = enableForecast and (totN6 > 0)
canF7N = enableForecast and (totN7 > 0)

canF11 = enableForecast and (tot11 > 0)
canF12 = enableForecast and (tot12 > 0)
canF13 = enableForecast and (tot13 > 0)
canF14 = enableForecast and (tot14 > 0)
canF15 = enableForecast and (tot15 > 0)
canF16 = enableForecast and (tot16 > 0)
canF17 = enableForecast and (tot17 > 0)


//====================
// Table helpers MUST be global (cannot be defined inside if-block)
//====================
var table gT = na
if na(gT)
    tblCols = 10
    tblRows = 16
    gT := table.new(position.middle_right, tblCols, tblRows, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

f_rowOut(tf, score, tC, mC, lC, rV, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 1, rRow, outSym(score),  text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, rRow, str.tostring(tC) + "/" + str.tostring(mC) + "/" + str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

f_bin_quality(pTop, nBin) =>
    if nBin <= 0
        ["warmup", tblTextDim]
    else if nBin < calMinSamples
        ["warmup", tblTextDim]
    else
        hw = f_ci95_halfwidth(pTop, nBin)
        lbl = na(hw) ? "warmup" : hw <= 0.05 ? "strong" : hw <= 0.10 ? "ok" : "weak"
        col = na(hw) ? tblTextDim : hw <= 0.05 ? color.lime : hw <= 0.10 ? color.yellow : color.orange
        [lbl, col]

f_rowTF(_tf, score, tC, mC, lC, rV,
        pUN, pFN, pDN, nBin,
        rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(_tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 1, rRow, outSym(score),  text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 3, rRow, str.tostring(tC) + "/" + str.tostring(mC) + "/" + str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    enabled = enableForecast
    useCalN = enabled and (nBin >= calMinSamples)
    [pUprio_t, pFprio_t, pDprio_t] = f_prior3(_tf, score)
    pUprio = pUprio_t
    pFprio = pFprio_t
    pDprio = pDprio_t
    pU = useCalN ? pUN : pUprio
    pF = useCalN ? pFN : pFprio
    pD = useCalN ? pDN : pDprio

    maxP = math.max(pU, math.max(pF, pD))
    dirSym = maxP < dirMinProb ? "Â·" : (pU == maxP ? "â–²" : pD == maxP ? "â–¼" : "â– ")
    dirCol = pU == maxP ? color.lime : pD == maxP ? color.red : color.yellow

    table.cell(gT, 5, rRow, dirSym, text_color=dirCol, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 6, rRow, str.tostring(pU * 100, "#.0") + "%", text_color=color.lime, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 7, rRow, str.tostring(pF * 100, "#.0") + "%", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 8, rRow, str.tostring(pD * 100, "#.0") + "%", text_color=color.red, bgcolor=tblCell, text_size=size.tiny)

    [qLbl_t, qCol_t] = f_bin_quality(maxP, nBin)
    qLbl = qLbl_t
    qCol = qCol_t
    nTxt = "n=" + str.tostring(nBin) + " " + qLbl
    table.cell(gT, 9, rRow, nTxt, text_color=qCol, bgcolor=tblCell, text_size=size.tiny)

f_rowFc(tf, pN, nBinN, totN_, canN_, p1, nBin1, tot1_, can1_, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)

    // Chance(N)
    txtChanceN = f_chance_text(tf, pN, nBinN, totN_, canN_)
    colChanceN = f_predColorP(pN, nBinN, canN_, tblText)
    table.cell(gT, 1, rRow, txtChanceN, text_color=colChanceN, bgcolor=tblCell, text_size=size.tiny)

    // Data(N) = bin/total + label + range
    txtDataN = f_data_text(pN, nBinN, totN_, canN_)
    colDataN = f_rel_color(pN, nBinN, totN_, canN_)
    table.cell(gT, 2, rRow, txtDataN, text_color=colDataN, bgcolor=tblCell, text_size=size.tiny)

    // Chance(1)
    txtChance1 = f_chance_text(tf, p1, nBin1, tot1_, can1_)
    colChance1 = f_predColorP(p1, nBin1, can1_, tblText)
    table.cell(gT, 3, rRow, txtChance1, text_color=colChance1, bgcolor=tblCell, text_size=size.tiny)

    // Data(1)
    txtData1 = f_data_text(p1, nBin1, tot1_, can1_)
    colData1 = f_rel_color(p1, nBin1, tot1_, can1_)
    table.cell(gT, 4, rRow, txtData1, text_color=colData1, bgcolor=tblCell, text_size=size.tiny)

f_fmtBrier(stats) =>
    s = array.get(stats, 0)
    c = array.get(stats, 1)
    val = c > 0 ? s / c : na
    txt = na(val) ? "â€”" : str.tostring(val, "#.###")
    col = na(val) ? tblTextDim : val < 0.20 ? color.green : val < 0.25 ? color.lime : val < 0.30 ? color.yellow : color.red
    [txt, col]

f_fmtCnt(stats) =>
    c = array.get(stats, 1)
    [str.tostring(c, "#"), c < 10 ? tblTextDim : tblText]

f_rowRel(tf, statsN, stats1, rRow) =>
    table.cell(gT, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    
    [tBN_t, cBN_t] = f_fmtBrier(statsN)
    tBN = tBN_t
    cBN = cBN_t
    table.cell(gT, 1, rRow, tBN, text_color=cBN, bgcolor=tblCell, text_size=size.tiny)
    
    [tB1_t, cB1_t] = f_fmtBrier(stats1)
    tB1 = tB1_t
    cB1 = cB1_t
    table.cell(gT, 2, rRow, tB1, text_color=cB1, bgcolor=tblCell, text_size=size.tiny)
    
    [tcN_t, ccN_t] = f_fmtCnt(statsN)
    tcN = tcN_t
    ccN = ccN_t
    table.cell(gT, 3, rRow, tcN, text_color=ccN, bgcolor=tblCell, text_size=size.tiny)
    
    [tc1_t, cc1_t] = f_fmtCnt(stats1)
    tc1 = tc1_t
    cc1 = cc1_t
    table.cell(gT, 4, rRow, tc1, text_color=cc1, bgcolor=tblCell, text_size=size.tiny)

// --- Evaluation Helpers
f_eval_get(hid) =>
    float bAvg = na, float lAvg = na
    float ece = na, float mErr = na
    float wS = na, float wL = na
    float drift = na, float nSc = na
    
    TfState st = na
    if hid == 1
        st := tf1State
    else if hid == 2
        st := tf2State
    else if hid == 3
        st := tf3State
    else if hid == 4
        st := tf4State
    else if hid == 5
        st := tf5State
    else if hid == 6
        st := tf6State
    else 
        st := tf7State

    if not na(st)
        // Switch to get arrays based on head (N or 1)
        if evalWhichHead == "N"
            [b0_t, b1_t, e0_t, e1_t, w0_t, w1_t, d0_t, n0_t] = f_eval_stats_one(st.evBrierN, st.evSumBrierN, st.evLogN, st.evSumLogN, st.evYS_N, st.evSumYS_N, st.evYL_N, st.evSumYL_N, st.evCalCntN, st.evCalSumPN, st.evCalSumYN)
            bAvg := b0_t, lAvg := b1_t, ece := e0_t, mErr := e1_t, wS := w0_t, wL := w1_t, drift := d0_t, nSc := n0_t
        else
            [b0_t, b1_t, e0_t, e1_t, w0_t, w1_t, d0_t, n0_t] = f_eval_stats_one(st.evBrier1, st.evSumBrier1, st.evLog1, st.evSumLog1, st.evYS_1, st.evSumYS_1, st.evYL_1, st.evSumYL_1, st.evCalCnt1, st.evCalSumP1, st.evCalSumY1)
            bAvg := b0_t, lAvg := b1_t, ece := e0_t, mErr := e1_t, wS := w0_t, wL := w1_t, drift := d0_t, nSc := n0_t
        
    [bAvg, lAvg, ece, mErr, wS, wL, drift, nSc]

f_rowEval(tbl, tf, hid, rRow) =>
    [bAvg_t, lAvg_t, ece_t, mErr_t, wS_t, wL_t, drift_t, nSc_t] = f_eval_get(hid)
    bAvg = bAvg_t
    lAvg = lAvg_t
    ece = ece_t
    mErr = mErr_t
    wS = wS_t
    wL = wL_t
    drift = drift_t
    nSc = nSc_t
    
    // Label
    table.cell(tbl, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)

    if na(nSc) or nSc == 0
        table.cell(tbl, 1, rRow, "â€”", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
        table.cell(tbl, 2, rRow, "â€”", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
        table.cell(tbl, 3, rRow, "â€”", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
        table.cell(tbl, 4, rRow, "0",   text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    else
        // LogLoss
        // ideal ~ 0.693 for random 50/50. Good < 0.65 ?? 
        // We'll just color based on existence
        llTxt = str.tostring(lAvg, "#.000")
        table.cell(tbl, 1, rRow, llTxt, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

        // ConfErr (pTrue) / Max
        eceT = str.tostring(ece * 100, "#.0")
        maxT = str.tostring(mErr * 100, "#.0")
        comb = eceT + "/" + maxT
        // Color ECE: < 5% is great, <10% ok
        cEce = ece < 0.05 ? color.lime : ece < 0.10 ? color.yellow : color.red
        table.cell(tbl, 2, rRow, comb, text_color=cEce, bgcolor=tblCell, text_size=size.tiny)

        // Drift
        drT = f_ppSigned(drift)
        // positive drift = Short yield > Long yield? 
        // Actually wS - wL. If > 0 => Short doing better.
        // We assume neutral is 0.
        table.cell(tbl, 3, rRow, drT, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
        
        // Count
        table.cell(tbl, 4, rRow, str.tostring(nSc, "#"), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)


//====================
// Table (5 columns) â€” rendered on confirmed bars (stable)
//====================
mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow
c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblText

targetDesc = "Multi-Profile (See Settings). Fast: " + fcTargetF + ", Mid: " + fcTargetM + ", Slow: " + fcTargetS

if showTable and barstate.isconfirmed and barstate.islast
    tblCols = 10
    table.clear(gT, 0, 0, tblCols - 1, 15)

    // Status rows
    table.cell(gT, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(gT, 2, 0, "Decision", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 0, decisionLabel, text_color=decisionColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 4, 0, decisionEdgeTxt, text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 5, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 6, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 7, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 8, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(gT, 9, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 2, volStr,   text_color=c_vol,      bgcolor=tblCell,   text_size=size.tiny)

    table.cell(gT, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 3, strengthStr, text_color=c_strength, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(gT, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    // Outlook header + forecast columns
    table.cell(gT, 0, 8, "Outlook", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 1, 8, "Bias",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 2, 8, "Score",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 3, 8, "T/M/L",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 4, 8, "RSI",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 5, 8, "Dir",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 6, 8, "Up%",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 7, 8, "Flat%",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 8, 8, "Down%",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(gT, 9, 8, "nCur",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    f_rowTF(tfF1, outScore1, t1c, m1c, l1c, r1, pUN1, pFN1, pDN1, nN1, 9)
    f_rowTF(tfF2, outScore2, t2c, m2c, l2c, r2, pUN2, pFN2, pDN2, nN2, 10)
    f_rowTF(tfF3, outScore3, t3c, m3c, l3c, r3, pUN3, pFN3, pDN3, nN3, 11)
    f_rowTF(tfF4, outScore4, t4c, m4c, l4c, r4, pUN4, pFN4, pDN4, nN4, 12)
    f_rowTF(tfF5, outScore5, t5c, m5c, l5c, r5, pUN5, pFN5, pDN5, nN5, 13)
    f_rowTF(tfF6, outScore6, t6c, m6c, l6c, r6, pUN6, pFN6, pDN6, nN6, 14)
    f_rowTF(tfF7, outScore7, t7c, m7c, l7c, r7, pUN7, pFN7, pDN7, nN7, 15)

//====================
// Calibration Diagnostics Panel (Debug)
//====================
var table diagTbl = na
if showDiagPanel and na(diagTbl)
    diagTbl := table.new(position.top_right, 2, 14, bgcolor=color.new(color.black, 85), frame_color=color.gray, frame_width=1, border_color=color.gray, border_width=1)

// Helper to get selected TfState
f_get_diag_state() =>
    diagHorizon == "F1" ? tf1State : diagHorizon == "F2" ? tf2State : diagHorizon == "F3" ? tf3State : diagHorizon == "F4" ? tf4State : diagHorizon == "F5" ? tf5State : diagHorizon == "F6" ? tf6State : tf7State

if showDiagPanel and barstate.islast
    st = f_get_diag_state()

    isBullDiag = f_bias_from_score(diagHorizon == "F1" ? outScore1 : diagHorizon == "F2" ? outScore2 : diagHorizon == "F3" ? outScore3 : diagHorizon == "F4" ? outScore4 : diagHorizon == "F5" ? outScore5 : diagHorizon == "F6" ? outScore6 : outScore7) == 1
    
    // Select model arrays
    cntArr = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.cntN_bull : st.cntN_bear) : st.cntN) : (useBullBearCal ? (isBullDiag ? st.cnt1_bull : st.cnt1_bear) : st.cnt1)
    upArr  = diagModel == "N" ? (useBullBearCal ? (isBullDiag ? st.upN_bull  : st.upN_bear)  : st.upN)  : (useBullBearCal ? (isBullDiag ? st.up1_bull  : st.up1_bear)  : st.up1)
    plattArr = diagModel == "N" ? st.plattN : st.platt1
    brierStats = diagModel == "N" ? st.brierStatsN : st.brierStats1
    llStats = diagModel == "N" ? st.llStatsN : st.llStats1
    
    // Platt params
    plattA = array.get(plattArr, 0)
    plattB = array.get(plattArr, 1)
    
    // Brier/LogLoss
    brierSum = array.get(brierStats, 0)
    brierCnt = array.get(brierStats, 1)
    brierAvg = brierCnt > 0 ? brierSum / brierCnt : na
    
    llSum = array.get(llStats, 0)
    llCnt = array.get(llStats, 1)
    llAvg = llCnt > 0 ? llSum / llCnt : na
    
    // Bin samples (total and per-bin distribution)
    totalSamples = array.sum(cntArr)
    numBins = array.size(cntArr)
    
    // Bin distribution (min/max/avg samples per bin)
    minBin = numBins > 0 ? array.min(cntArr) : 0
    maxBin = numBins > 0 ? array.max(cntArr) : 0
    avgBin = numBins > 0 ? totalSamples / numBins : 0
    
    // Win rate (overall calibrated base rate)
    totalUp = array.sum(upArr)
    baseRate = totalSamples > 0 ? totalUp * 100.0 / totalSamples : 50.0
    
    // Convergence check: Is Platt A stable (should be near 1.0 if well-calibrated)?
    plattStable = (plattA >= 0.7 and plattA <= 1.5) and (plattB >= -0.5 and plattB <= 0.5)
    convStatus = plattStable ? "âœ… Converged" : (plattA < 0.3 or plattA > 3.0) ? "âš ï¸ Unstable" : "ðŸ”„ Adjusting"
    convColor = plattStable ? color.lime : (plattA < 0.3 or plattA > 3.0) ? color.red : color.yellow
    
    // Quality grade
    qualityGrade = na(brierAvg) ? "â€”" : brierAvg < 0.18 ? "A (Excellent)" : brierAvg < 0.22 ? "B (Good)" : brierAvg < 0.25 ? "C (Baseline)" : brierAvg < 0.30 ? "D (Poor)" : "F (No Skill)"
    qualityColor = na(brierAvg) ? color.gray : brierAvg < 0.18 ? color.lime : brierAvg < 0.22 ? color.green : brierAvg < 0.25 ? color.yellow : brierAvg < 0.30 ? color.orange : color.red
    
    // Row 0: Header
    table.cell(diagTbl, 0, 0, "ðŸ”§ Calibration Diagnostics", text_color=color.white, bgcolor=color.new(color.blue, 70), text_size=size.small)
    table.cell(diagTbl, 1, 0, diagHorizon + " / " + diagModel, text_color=color.aqua, bgcolor=color.new(color.blue, 70), text_size=size.small)
    
    // Row 1: Platt A
    table.cell(diagTbl, 0, 1, "Platt A (slope)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 1, str.tostring(plattA, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 2: Platt B
    table.cell(diagTbl, 0, 2, "Platt B (intercept)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 2, str.tostring(plattB, "#.###"), text_color=color.white, text_size=size.tiny)
    
    // Row 3: Convergence status
    table.cell(diagTbl, 0, 3, "SGD Status", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 3, convStatus, text_color=convColor, text_size=size.tiny)
    
    // Row 4: Separator
    table.cell(diagTbl, 0, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 4, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 5: Brier Score
    table.cell(diagTbl, 0, 5, "Brier Score", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 5, na(brierAvg) ? "â€”" : str.tostring(brierAvg, "#.####"), text_color=na(brierAvg) ? color.gray : brierAvg < 0.25 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 6: LogLoss
    table.cell(diagTbl, 0, 6, "LogLoss", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 6, na(llAvg) ? "â€”" : str.tostring(llAvg, "#.####"), text_color=na(llAvg) ? color.gray : llAvg < 0.65 ? color.lime : color.red, text_size=size.tiny)
    
    // Row 7: Quality Grade
    table.cell(diagTbl, 0, 7, "Quality Grade", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 7, qualityGrade, text_color=qualityColor, text_size=size.tiny)
    
    // Row 8: Separator
    table.cell(diagTbl, 0, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 8, "â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray, text_size=size.tiny)
    
    // Row 9: Total samples
    table.cell(diagTbl, 0, 9, "Total Samples", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 9, str.tostring(totalSamples), text_color=totalSamples >= calMinSamples * numBins ? color.lime : color.yellow, text_size=size.tiny)
    
    // Row 10: Bin distribution
    table.cell(diagTbl, 0, 10, "Bin Min/Avg/Max", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 10, str.tostring(minBin) + "/" + str.tostring(avgBin, "#") + "/" + str.tostring(maxBin), text_color=color.white, text_size=size.tiny)
    
    // Row 11: Warmup label (mirrors table behavior)
    warmupLbl = f_samp_label(enableForecast, totalSamples)
    warmupPct = math.min(100, totalSamples * 100.0 / (calMinSamples * numBins))
    warmupTxt = warmupLbl == "off" ? "off" : warmupLbl == "â€¦" ? "â€¦" : warmupLbl + " (" + str.tostring(warmupPct, "#.0") + "%)"
    warmupCol = warmupLbl == "strong" ? color.lime : warmupLbl == "ok" ? color.yellow : warmupLbl == "â€¦" ? color.red : color.gray
    table.cell(diagTbl, 0, 11, "Warmup", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 11, warmupTxt, text_color=warmupCol, text_size=size.tiny)
    
    // Row 12: Base Rate
    table.cell(diagTbl, 0, 12, "Base Rate (Up%)", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 12, str.tostring(baseRate, "#.1") + "%", text_color=math.abs(baseRate - 50) > 15 ? color.orange : color.white, text_size=size.tiny)
    
    // Row 13: Observations count
    table.cell(diagTbl, 0, 13, "Resolutions", text_color=color.gray, text_size=size.tiny)
    table.cell(diagTbl, 1, 13, str.tostring(int(brierCnt)), text_color=color.white, text_size=size.tiny)

//====================
// UT Bot Logic (Overlay, V4 Port)
//====================
utSrc = utUseHA ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead = barmerge.lookahead_off) : close
utXATR = ta.atr(utAtrPeriod)
utNLoss = utKey * utXATR

var float utXATRTrailingStop = 0.0
// Logic replication
utPrevStop = nz(utXATRTrailingStop[1], 0)
utSrc1 = utSrc[1]

if utSrc > utPrevStop and utSrc1 > utPrevStop
    utXATRTrailingStop := math.max(utPrevStop, utSrc - utNLoss)
else if utSrc < utPrevStop and utSrc1 < utPrevStop
    utXATRTrailingStop := math.min(utPrevStop, utSrc + utNLoss)
else if utSrc > utPrevStop
    utXATRTrailingStop := utSrc - utNLoss
else 
    utXATRTrailingStop := utSrc + utNLoss

var int utPos = 0
if utSrc1 < utPrevStop and utSrc > utPrevStop
    utPos := 1
else if utSrc1 > utPrevStop and utSrc < utPrevStop
    utPos := -1
else
    utPos := nz(utPos[1], 0)

utEma = ta.ema(utSrc, 1)
utAbove = ta.crossover(utEma, utXATRTrailingStop)
utBelow = ta.crossover(utXATRTrailingStop, utEma)

utBuy  = utSrc > utXATRTrailingStop and utAbove
utSell = utSrc < utXATRTrailingStop and utBelow

utBarBuy  = utSrc > utXATRTrailingStop
utBarSell = utSrc < utXATRTrailingStop

plotshape(utShow and utBuy,  title = "UT Buy",  text = 'UT Buy',  style = shape.labelup,   location = location.belowbar, color= color.green, textcolor = color.white, size = size.tiny)
plotshape(utShow and utSell, title = "UT Sell", text = 'UT Sell', style = shape.labeldown, location = location.abovebar, color= color.red,   textcolor = color.white, size = size.tiny)

barcolor(utShow and utBarBuy ? color.green : utShow and utBarSell ? color.red : na)

alertcondition(utBuy,  "UT Bot Long",  "UT Bot Long")
alertcondition(utSell, "UT Bot Short", "UT Bot Short")

//====================
// Alerts (bar close)
//====================
alertcondition(buySignal,   title="BUY (bar close)",   message="BUY {{ticker}} @ {{close}}")
alertcondition(exitSignal,  title="EXIT (bar close)",  message="EXIT {{ticker}} @ {{close}}")
alertcondition(shortSignal, title="SHORT (bar close)", message="SHORT {{ticker}} @ {{close}}")
alertcondition(coverSignal, title="COVER (bar close)", message="COVER {{ticker}} @ {{close}}")
