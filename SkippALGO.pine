// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © preuss_steffen

//@version=6
indicator("SkippALGO — Outlook(State) + Forecast(Prob) v6", overlay=true, max_labels_count=500, max_lines_count=500)

//====================
// Inputs — Core / Engine
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose", "TRIG (legacy)"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use (filter / regime)
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// Outlook/MTF RSI length (stable)
rsiStateLen = input.int(14, "State/MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels  = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers   = input.bool(true, "Show SET markers")
showTable        = input.bool(true, "Show Outlook/Forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

//====================
// Inputs — Forecast Calibration Enhancements
//====================
enableForecast = input.bool(true, "Enable Forecast calibration (probabilities)")

fcTarget = input.string("NextBar", "Forecast target",
    options=["NextBar", "KBarReturn", "KBarATR", "PathTPvsSL"])

kBars = input.int(3, "k bars ahead (KBar*)", minval=1, maxval=20)

atrTargetLen = input.int(14, "ATR len (forecast targets)", minval=2)
atrThr = input.float(0.25, "ATR threshold (KBarATR)", step=0.05)

pathH = input.int(6, "Path horizon H bars (PathTPvsSL)", minval=1, maxval=50)
tpATR = input.float(0.50, "TP (ATR)", step=0.05)
slATR = input.float(0.30, "SL (ATR)", step=0.05)
noHitPolicy = input.string("Ignore", "No-hit policy (PathTPvsSL)", options=["Ignore", "Neutral", "Loss"])
pathTiePolicy = input.string("Loss", "Tie policy if TP & SL hit same bar", options=["Loss", "Neutral", "Win"])

predBinsN = input.int(3, "Pred bins (N) stable", minval=2, maxval=9)
predBins1 = input.int(2, "Pred bins (1) reactive", minval=2, maxval=3)

alphaN = input.float(1.0, "Smoothing alpha (N)", minval=0.1, step=0.1)
alpha1 = input.float(0.8, "Smoothing alpha (1)", minval=0.1, step=0.1)

calMinSamples = input.int(40, "Min samples per bin (activate)", minval=5, maxval=1000)

predUpThr = input.float(0.55, "Pred up threshold", minval=0.50, maxval=0.80, step=0.01)
predDnThr = input.float(0.45, "Pred down threshold", minval=0.20, maxval=0.50, step=0.01)

// Per-horizon reset control (Pine inputs cannot be dynamic; map to F1..F7)
resetWhich = input.string("None", "Reset calibration scope", options=["None","All","F1","F2","F3","F4","F5","F6","F7"])
resetNow   = input.bool(false, "Reset selected calibration NOW")

//====================
// Table colors (match your navy + soft-blue frame scheme)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

//====================
// Helpers
//====================
f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  : tf == "5"   ? "5M"  : tf == "15"  ? "15M" :
    tf == "30"  ? "30M" : tf == "60"  ? "1H"  : tf == "240" ? "4H"  :
    tf == "D"   ? "1D"  : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "—" :
    v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") :
    v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") :
    v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") :
    str.tostring(v, "#")

// State score from already-fetched TF series (Outlook)
f_state_score(c, emaF_tf, emaS_tf, r_tf) =>
    trend = emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = c > emaS_tf ? 0.5 : c < emaS_tf ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

f_state_tml(c, emaF_tf, emaS_tf, r_tf) =>
    t = emaF_tf > emaS_tf ? 1 : emaF_tf < emaS_tf ? -1 : 0
    m = r_tf > 55 ? 1 : r_tf < 45 ? -1 : 0
    l = c > emaS_tf ? 1 : c < emaS_tf ? -1 : 0
    [t, m, l]

// Single security call pack for a TF (performance)
f_tf_pack(tf) =>
    request.security(
        syminfo.tickerid,
        tf,
        [time, close, high, low,
         ta.ema(close, emaFastLen),
         ta.ema(close, emaSlowLen),
         ta.rsi(close, rsiStateLen),
         ta.atr(atrTargetLen)],
        barmerge.gaps_off,
        barmerge.lookahead_off
    )

// MTF vote score (single-call per TF inside)
f_score_tf(tf) =>
    [c, ef, es, r] =
        request.security(
            syminfo.tickerid,
            tf,
            [close,
             ta.ema(close, emaFastLen),
             ta.ema(close, emaSlowLen),
             ta.rsi(close, rsiStateLen)],
            barmerge.gaps_off,
            barmerge.lookahead_off
        )
    f_state_score(c, ef, es, r)

// Forecast binning
f_bin(score, bins) =>
    u = (score + 1.0) * 0.5
    b = math.floor(u * bins)
    b < 0 ? 0 : b > (bins - 1) ? (bins - 1) : b

f_bin1(score) =>
    predBins1 == 2 ? (score > 0.0 ? 1 : 0) : f_bin(score, predBins1)

// Probability with smoothing
f_prob(up, n, alpha) =>
    (up + alpha) / (n + 2.0 * alpha)

// Update calibration arrays (mutates arrays in-place)
f_cal_update(cntArr, upArr, bin, isUp) =>
    n0 = array.get(cntArr, bin)
    u0 = array.get(upArr,  bin)
    array.set(cntArr, bin, n0 + 1)
    array.set(upArr,  bin, u0 + (isUp ? 1 : 0))

// Current-bin probability + n
f_cal_cur(cntArr, upArr, bin, alpha) =>
    n = array.get(cntArr, bin)
    u = array.get(upArr,  bin)
    p = n == 0 ? 0.5 : f_prob(u, n, alpha)
    [p, n]

// Forecast symbol/color with sufficiency gating (NO tblText scope issues)
f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "—" : n < calMinSamples ? "…" : pUp > predUpThr ? "▲" : pUp < predDnThr ? "▼" : "−"

f_predColorP(pUp, n, canCal, neutralCol) =>
    not canCal ? color.new(color.white, 70) :
    n < calMinSamples ? color.new(color.white, 60) :
    pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralCol

f_pupText(pUp, n, canCal) =>
    not canCal ? "n0" :
    n < calMinSamples ? ("n" + str.tostring(n)) :
    (str.tostring(pUp * 100.0, "#.0") + "% n" + str.tostring(n))

// Process one TF calibration step on new TF bar (updates queue + resolves matured items)
f_process_tf(newTfBar, scoreNow, entryNow, atrNow, hNow, lNow, cNow,
             cntN, upN, cnt1, up1,
             qBinN, qBin1, qEntry, qAtr, qMaxH, qMinL, qAge) =>

    if newTfBar
        // 1) Age/extremes update for pending items
        sz = array.size(qAge)
        if sz > 0
            for i = 0 to sz - 1
                age = array.get(qAge, i) + 1
                array.set(qAge, i, age)
                mh = math.max(array.get(qMaxH, i), hNow)
                ml = math.min(array.get(qMinL, i), lNow)
                array.set(qMaxH, i, mh)
                array.set(qMinL, i, ml)

        // 2) Resolve items (scan from newest to oldest to allow Path out-of-order resolution)
        sz2 = array.size(qAge)
        if sz2 > 0
            for i = sz2 - 1 to 0
                age_i   = array.get(qAge,   i)
                entry_i = array.get(qEntry, i)
                atr_i   = array.get(qAtr,   i)
                mh_i    = array.get(qMaxH,  i)
                ml_i    = array.get(qMinL,  i)
                bN_i    = array.get(qBinN,  i)
                b1_i    = array.get(qBin1,  i)

                resolved = false
                doUpdate = false
                isUp     = false

                if fcTarget == "NextBar"
                    if age_i >= 1
                        resolved := true
                        doUpdate := true
                        isUp     := cNow > entry_i

                else if fcTarget == "KBarReturn"
                    if age_i >= kBars
                        resolved := true
                        doUpdate := true
                        isUp     := cNow > entry_i

                else if fcTarget == "KBarATR"
                    if age_i >= kBars
                        resolved := true
                        doUpdate := true
                        denom = (na(atr_i) or atr_i == 0.0) ? 1.0 : atr_i
                        retATR = (cNow - entry_i) / denom
                        isUp := retATR >= atrThr

                else // PathTPvsSL
                    tpPx = entry_i + tpATR * atr_i
                    slPx = entry_i - slATR * atr_i
                    winHit  = mh_i >= tpPx
                    lossHit = ml_i <= slPx

                    if winHit or lossHit
                        resolved := true
                        doUpdate := true
                        if winHit and lossHit
                            isUp := pathTiePolicy == "Win" ? true : pathTiePolicy == "Neutral" ? false : false
                            // Neutral tie acts like non-win in binary model (conservative)
                        else
                            isUp := winHit and not lossHit

                    else if age_i >= pathH
                        resolved := true
                        if noHitPolicy == "Loss"
                            doUpdate := true
                            isUp := false
                        else
                            doUpdate := false
                            isUp := false

                if resolved
                    if doUpdate
                        f_cal_update(cntN, upN, bN_i, isUp)
                        f_cal_update(cnt1, up1, b1_i, isUp)

                    // remove from all queues
                    array.remove(qAge,   i)
                    array.remove(qMaxH,  i)
                    array.remove(qMinL,  i)
                    array.remove(qAtr,   i)
                    array.remove(qEntry, i)
                    array.remove(qBinN,  i)
                    array.remove(qBin1,  i)

        // 3) Push new pending item from current state
        bN = f_bin(scoreNow, predBinsN)
        b1 = f_bin1(scoreNow)

        array.push(qBinN,  bN)
        array.push(qBin1,  b1)
        array.push(qEntry, entryNow)
        array.push(qAtr,   atrNow)

        array.push(qMaxH,  entryNow)
        array.push(qMinL,  entryNow)

        array.push(qAge,   0)

// Reset helper (mutates arrays)
f_reset_tf(cntN, upN, cnt1, up1, qBinN, qBin1, qEntry, qAtr, qMaxH, qMinL, qAge) =>
    for i = 0 to predBinsN - 1
        array.set(cntN, i, 0)
        array.set(upN,  i, 0)
    for j = 0 to predBins1 - 1
        array.set(cnt1, j, 0)
        array.set(up1,  j, 0)

    array.clear(qBinN)
    array.clear(qBin1)
    array.clear(qEntry)
    array.clear(qAtr)
    array.clear(qMaxH)
    array.clear(qMinL)
    array.clear(qAge)

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ?
     ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("300"))  ? rsiLenFastTF : // <=5m
      (not na(baseSecs) and baseSecs <= timeframe.in_seconds("3600")) ? rsiLenMidTF  : // <=1h
                                                                        rsiLenSlowTF) :
     rsiLenSlowTF
rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime
atrRank = f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? volRankRaw : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state (drives confidence accuracyScore)
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI (3,2,100) for confidence factor
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chgClose = ta.change(close)  // computed globally every bar (Pine consistency)
crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chgClose, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor =
    crsi < crsiLongPanic ? crsiLongPanicMult :
    crsi > crsiLongOver  ? crsiLongOverMult  :
    (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor =
    crsi < crsiShortExhaust ? crsiShortExhaustMult :
    crsi > crsiShortOver    ? crsiShortOverMult    :
    (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength calc
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)

    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier =
     config == "Standard"      ? 1.00 :
     config == "Pro"           ? 1.05 :
     config == "V2 Essential"  ? 0.95 :
     config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30"))  ? "Short" :
           (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = timeframe.in_seconds(tf)
    not na(base) and not na(other) and other >= base

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown
gateLongNow  = (confidence >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidence >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose      = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose    = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice =
     zoneAnchor == "Entry"    and not na(entryPrice) ? entryPrice :
     zoneAnchor == "VWAP"     ? vwapVal :
     zoneAnchor == "MA200"    ? sma200Val :
     zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine (exits not blocked by cooldown)
//====================
trendFlipUp   = crossEmaF_EmaS_up
trendFlipDown = crossEmaF_EmaS_down
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0            // 0 flat, 1 long, -1 short
var int lastSignalBar = na
var string lastSig = "—"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)
allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias

else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias
else
    buySignal := false
    exitSignal := false
    shortSignal := false
    coverSignal := false

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
        alert("EXIT " + syminfo.ticker + " @ " + str.tostring(close) + " | Confidence: " + str.tostring(confidence * 100, "#.0") + "%", alert.freq_once_per_bar_close)

    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
        alert("COVER " + syminfo.ticker + " @ " + str.tostring(close) + " | Confidence: " + str.tostring(confidence * 100, "#.0") + "%", alert.freq_once_per_bar_close)

    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
        alert("BUY " + syminfo.ticker + " @ " + str.tostring(close) + " | Confidence: " + str.tostring(confidence * 100, "#.0") + "%", alert.freq_once_per_bar_close)

    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"
        alert("SHORT " + syminfo.ticker + " @ " + str.tostring(close) + " | Confidence: " + str.tostring(confidence * 100, "#.0") + "%", alert.freq_once_per_bar_close)

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 25))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Forecast/Outlook data packs (one security call per horizon TF)
//====================
[t1, c1, h1, l1, ef1, es1, r1, a1] = f_tf_pack(tfF1)
[t2, c2, h2, l2, ef2, es2, r2, a2] = f_tf_pack(tfF2)
[t3, c3, h3, l3, ef3, es3, r3, a3] = f_tf_pack(tfF3)
[t4, c4, h4, l4, ef4, es4, r4, a4] = f_tf_pack(tfF4)
[t5, c5, h5, l5, ef5, es5, r5, a5] = f_tf_pack(tfF5)
[t6, c6, h6, l6, ef6, es6, r6, a6] = f_tf_pack(tfF6)
[t7, c7, h7, l7, ef7, es7, r7, a7] = f_tf_pack(tfF7)

// IMPORTANT: ta.change() computed globally every bar (Pine consistency)
newF1 = ta.change(t1)
newF2 = ta.change(t2)
newF3 = ta.change(t3)
newF4 = ta.change(t4)
newF5 = ta.change(t5)
newF6 = ta.change(t6)
newF7 = ta.change(t7)

// Outlook scores + components
outScore1 = f_state_score(c1, ef1, es1, r1)
outScore2 = f_state_score(c2, ef2, es2, r2)
outScore3 = f_state_score(c3, ef3, es3, r3)
outScore4 = f_state_score(c4, ef4, es4, r4)
outScore5 = f_state_score(c5, ef5, es5, r5)
outScore6 = f_state_score(c6, ef6, es6, r6)
outScore7 = f_state_score(c7, ef7, es7, r7)

[t1c, m1c, l1c] = f_state_tml(c1, ef1, es1, r1)
[t2c, m2c, l2c] = f_state_tml(c2, ef2, es2, r2)
[t3c, m3c, l3c] = f_state_tml(c3, ef3, es3, r3)
[t4c, m4c, l4c] = f_state_tml(c4, ef4, es4, r4)
[t5c, m5c, l5c] = f_state_tml(c5, ef5, es5, r5)
[t6c, m6c, l6c] = f_state_tml(c6, ef6, es6, r6)
[t7c, m7c, l7c] = f_state_tml(c7, ef7, es7, r7)

outSym(score) => score > 0.05 ? "▲" : score < -0.05 ? "▼" : "−"
outCol(score) => score > 0.05 ? color.lime : score < -0.05 ? color.red : tblText

//====================
// Calibration storage — per horizon TF (N-bin + 1-bin + pending queues)
//====================
// F1
var int[] cntN1 = array.new_int(predBinsN, 0)
var int[] upN1  = array.new_int(predBinsN, 0)
var int[] cnt11 = array.new_int(predBins1, 0)
var int[] up11  = array.new_int(predBins1, 0)

var int[]   qBinN1 = array.new_int()
var int[]   qBin11 = array.new_int()
var float[] qEntry1 = array.new_float()
var float[] qAtr1   = array.new_float()
var float[] qMaxH1  = array.new_float()
var float[] qMinL1  = array.new_float()
var int[]   qAge1   = array.new_int()

// F2
var int[] cntN2 = array.new_int(predBinsN, 0)
var int[] upN2  = array.new_int(predBinsN, 0)
var int[] cnt12 = array.new_int(predBins1, 0)
var int[] up12  = array.new_int(predBins1, 0)

var int[]   qBinN2 = array.new_int()
var int[]   qBin12 = array.new_int()
var float[] qEntry2 = array.new_float()
var float[] qAtr2   = array.new_float()
var float[] qMaxH2  = array.new_float()
var float[] qMinL2  = array.new_float()
var int[]   qAge2   = array.new_int()

// F3
var int[] cntN3 = array.new_int(predBinsN, 0)
var int[] upN3  = array.new_int(predBinsN, 0)
var int[] cnt13 = array.new_int(predBins1, 0)
var int[] up13  = array.new_int(predBins1, 0)

var int[]   qBinN3 = array.new_int()
var int[]   qBin13 = array.new_int()
var float[] qEntry3 = array.new_float()
var float[] qAtr3   = array.new_float()
var float[] qMaxH3  = array.new_float()
var float[] qMinL3  = array.new_float()
var int[]   qAge3   = array.new_int()

// F4
var int[] cntN4 = array.new_int(predBinsN, 0)
var int[] upN4  = array.new_int(predBinsN, 0)
var int[] cnt14 = array.new_int(predBins1, 0)
var int[] up14  = array.new_int(predBins1, 0)

var int[]   qBinN4 = array.new_int()
var int[]   qBin14 = array.new_int()
var float[] qEntry4 = array.new_float()
var float[] qAtr4   = array.new_float()
var float[] qMaxH4  = array.new_float()
var float[] qMinL4  = array.new_float()
var int[]   qAge4   = array.new_int()

// F5
var int[] cntN5 = array.new_int(predBinsN, 0)
var int[] upN5  = array.new_int(predBinsN, 0)
var int[] cnt15 = array.new_int(predBins1, 0)
var int[] up15  = array.new_int(predBins1, 0)

var int[]   qBinN5 = array.new_int()
var int[]   qBin15 = array.new_int()
var float[] qEntry5 = array.new_float()
var float[] qAtr5   = array.new_float()
var float[] qMaxH5  = array.new_float()
var float[] qMinL5  = array.new_float()
var int[]   qAge5   = array.new_int()

// F6
var int[] cntN6 = array.new_int(predBinsN, 0)
var int[] upN6  = array.new_int(predBinsN, 0)
var int[] cnt16 = array.new_int(predBins1, 0)
var int[] up16  = array.new_int(predBins1, 0)

var int[]   qBinN6 = array.new_int()
var int[]   qBin16 = array.new_int()
var float[] qEntry6 = array.new_float()
var float[] qAtr6   = array.new_float()
var float[] qMaxH6  = array.new_float()
var float[] qMinL6  = array.new_float()
var int[]   qAge6   = array.new_int()

// F7
var int[] cntN7 = array.new_int(predBinsN, 0)
var int[] upN7  = array.new_int(predBinsN, 0)
var int[] cnt17 = array.new_int(predBins1, 0)
var int[] up17  = array.new_int(predBins1, 0)

var int[]   qBinN7 = array.new_int()
var int[]   qBin17 = array.new_int()
var float[] qEntry7 = array.new_float()
var float[] qAtr7   = array.new_float()
var float[] qMaxH7  = array.new_float()
var float[] qMinL7  = array.new_float()
var int[]   qAge7   = array.new_int()

//====================
// Reset handling (rising edge) — per horizon F1..F7
//====================
var bool prevResetNow = false
doReset = resetNow and not prevResetNow
prevResetNow := resetNow

if doReset
    if resetWhich == "All" or resetWhich == "F1"
        f_reset_tf(cntN1, upN1, cnt11, up11, qBinN1, qBin11, qEntry1, qAtr1, qMaxH1, qMinL1, qAge1)
    if resetWhich == "All" or resetWhich == "F2"
        f_reset_tf(cntN2, upN2, cnt12, up12, qBinN2, qBin12, qEntry2, qAtr2, qMaxH2, qMinL2, qAge2)
    if resetWhich == "All" or resetWhich == "F3"
        f_reset_tf(cntN3, upN3, cnt13, up13, qBinN3, qBin13, qEntry3, qAtr3, qMaxH3, qMinL3, qAge3)
    if resetWhich == "All" or resetWhich == "F4"
        f_reset_tf(cntN4, upN4, cnt14, up14, qBinN4, qBin14, qEntry4, qAtr4, qMaxH4, qMinL4, qAge4)
    if resetWhich == "All" or resetWhich == "F5"
        f_reset_tf(cntN5, upN5, cnt15, up15, qBinN5, qBin15, qEntry5, qAtr5, qMaxH5, qMinL5, qAge5)
    if resetWhich == "All" or resetWhich == "F6"
        f_reset_tf(cntN6, upN6, cnt16, up16, qBinN6, qBin16, qEntry6, qAtr6, qMaxH6, qMinL6, qAge6)
    if resetWhich == "All" or resetWhich == "F7"
        f_reset_tf(cntN7, upN7, cnt17, up17, qBinN7, qBin17, qEntry7, qAtr7, qMaxH7, qMinL7, qAge7)

//====================
// Calibration update (bar-close confirmed guard + new TF bar events)
//====================
doCal = enableForecast and barstate.isconfirmed

if doCal
    f_process_tf(newF1, outScore1, c1, a1, h1, l1, c1, cntN1, upN1, cnt11, up11, qBinN1, qBin11, qEntry1, qAtr1, qMaxH1, qMinL1, qAge1)
    f_process_tf(newF2, outScore2, c2, a2, h2, l2, c2, cntN2, upN2, cnt12, up12, qBinN2, qBin12, qEntry2, qAtr2, qMaxH2, qMinL2, qAge2)
    f_process_tf(newF3, outScore3, c3, a3, h3, l3, c3, cntN3, upN3, cnt13, up13, qBinN3, qBin13, qEntry3, qAtr3, qMaxH3, qMinL3, qAge3)
    f_process_tf(newF4, outScore4, c4, a4, h4, l4, c4, cntN4, upN4, cnt14, up14, qBinN4, qBin14, qEntry4, qAtr4, qMaxH4, qMinL4, qAge4)
    f_process_tf(newF5, outScore5, c5, a5, h5, l5, c5, cntN5, upN5, cnt15, up15, qBinN5, qBin15, qEntry5, qAtr5, qMaxH5, qMinL5, qAge5)
    f_process_tf(newF6, outScore6, c6, a6, h6, l6, c6, cntN6, upN6, cnt16, up16, qBinN6, qBin16, qEntry6, qAtr6, qMaxH6, qMinL6, qAge6)
    f_process_tf(newF7, outScore7, c7, a7, h7, l7, c7, cntN7, upN7, cnt17, up17, qBinN7, qBin17, qEntry7, qAtr7, qMaxH7, qMinL7, qAge7)

//====================
// Display values (current-bin probability + n) — N and 1 per horizon
//====================
bN1 = f_bin(outScore1, predBinsN)
bN2 = f_bin(outScore2, predBinsN)
bN3 = f_bin(outScore3, predBinsN)
bN4 = f_bin(outScore4, predBinsN)
bN5 = f_bin(outScore5, predBinsN)
bN6 = f_bin(outScore6, predBinsN)
bN7 = f_bin(outScore7, predBinsN)

b11 = f_bin1(outScore1)
b12 = f_bin1(outScore2)
b13 = f_bin1(outScore3)
b14 = f_bin1(outScore4)
b15 = f_bin1(outScore5)
b16 = f_bin1(outScore6)
b17 = f_bin1(outScore7)

[pN1, nN1] = f_cal_cur(cntN1, upN1, bN1, alphaN)
[pN2, nN2] = f_cal_cur(cntN2, upN2, bN2, alphaN)
[pN3, nN3] = f_cal_cur(cntN3, upN3, bN3, alphaN)
[pN4, nN4] = f_cal_cur(cntN4, upN4, bN4, alphaN)
[pN5, nN5] = f_cal_cur(cntN5, upN5, bN5, alphaN)
[pN6, nN6] = f_cal_cur(cntN6, upN6, bN6, alphaN)
[pN7, nN7] = f_cal_cur(cntN7, upN7, bN7, alphaN)

[p11p, n11p] = f_cal_cur(cnt11, up11, b11, alpha1)
[p12p, n12p] = f_cal_cur(cnt12, up12, b12, alpha1)
[p13p, n13p] = f_cal_cur(cnt13, up13, b13, alpha1)
[p14p, n14p] = f_cal_cur(cnt14, up14, b14, alpha1)
[p15p, n15p] = f_cal_cur(cnt15, up15, b15, alpha1)
[p16p, n16p] = f_cal_cur(cnt16, up16, b16, alpha1)
[p17p, n17p] = f_cal_cur(cnt17, up17, b17, alpha1)

can1N = nN1 > 0
can2N = nN2 > 0
can3N = nN3 > 0
can4N = nN4 > 0
can5N = nN5 > 0
can6N = nN6 > 0
can7N = nN7 > 0

can11 = n11p > 0
can12 = n12p > 0
can13 = n13p > 0
can14 = n14p > 0
can15 = n15p > 0
can16 = n16p > 0
can17 = n17p > 0

//====================
// Table (5 columns) — rendered on confirmed bars (stable)
//====================
var table t = table.new(position.middle_right, 5, 26, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)
strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow
c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblText

// Forecast target descriptor (footer)
targetDesc =
    fcTarget == "NextBar" ? "Target: NextBar (Up if next close > entry)" :
    fcTarget == "KBarReturn" ? ("Target: KBarReturn k=" + str.tostring(kBars)) :
    fcTarget == "KBarATR" ? ("Target: KBarATR k=" + str.tostring(kBars) + " thr=" + str.tostring(atrThr, "#.##") + "ATR") :
    ("Target: PathTPvsSL H=" + str.tostring(pathH) + " TP=" + str.tostring(tpATR, "#.##") + "ATR SL=" + str.tostring(slATR, "#.##") + "ATR NoHit=" + noHitPolicy)

if showTable and barstate.isconfirmed
    table.clear(t, 0, 0, 4, 25)

    // Status block
    table.cell(t, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 2, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 0, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 2, volStr,   text_color=c_vol,      bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 2, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 3, strengthStr,text_color=c_strength, bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 2, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    // Outlook header
    table.cell(t, 0, 8, "Outlook", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 8, "Bias",    text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 8, "Score",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 8, "T/M/L",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 8, "RSI",     text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    // Outlook rows
    rowOut(tf, score, tC, mC, lC, rV, rRow) =>
        table.cell(t, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
        table.cell(t, 1, rRow, outSym(score), text_color=outCol(score), bgcolor=tblCell, text_size=size.tiny)
        table.cell(t, 2, rRow, str.tostring(score, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
        table.cell(t, 3, rRow, str.tostring(tC)+"/"+str.tostring(mC)+"/"+str.tostring(lC), text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
        table.cell(t, 4, rRow, str.tostring(rV, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    rowOut(tfF1, outScore1, t1c, m1c, l1c, r1,  9)
    rowOut(tfF2, outScore2, t2c, m2c, l2c, r2, 10)
    rowOut(tfF3, outScore3, t3c, m3c, l3c, r3, 11)
    rowOut(tfF4, outScore4, t4c, m4c, l4c, r4, 12)
    rowOut(tfF5, outScore5, t5c, m5c, l5c, r5, 13)
    rowOut(tfF6, outScore6, t6c, m6c, l6c, r6, 14)
    rowOut(tfF7, outScore7, t7c, m7c, l7c, r7, 15)

    // Forecast header (5 cols)
    table.cell(t, 0, 16, "Forecast", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 16, "Pred(N)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 16, "Pred(1)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 16, "PUp(N)",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 16, "PUp(1)",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    rowFc(tf, pN, nN, canN, p1, n1, can1, rRow) =>
        table.cell(t, 0, rRow, f_tfLabel(tf), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)

        symN = f_predSymbolP(pN, nN, canN)
        colN = f_predColorP(pN, nN, canN, tblText)
        table.cell(t, 1, rRow, symN, text_color=colN, bgcolor=tblCell, text_size=size.tiny)

        sym1 = f_predSymbolP(p1, n1, can1)
        col1 = f_predColorP(p1, n1, can1, tblText)
        table.cell(t, 2, rRow, sym1, text_color=col1, bgcolor=tblCell, text_size=size.tiny)

        pupNtxt = f_pupText(pN, nN, canN)
        pup1txt = f_pupText(p1, n1, can1)
        table.cell(t, 3, rRow, pupNtxt, text_color=f_predColorP(pN, nN, canN, tblText), bgcolor=tblCell, text_size=size.tiny)
        table.cell(t, 4, rRow, pup1txt, text_color=f_predColorP(p1, n1, can1, tblText), bgcolor=tblCell, text_size=size.tiny)

    rowFc(tfF1, pN1, nN1, can1N, p11p, n11p, can11, 17)
    rowFc(tfF2, pN2, nN2, can2N, p12p, n12p, can12, 18)
    rowFc(tfF3, pN3, nN3, can3N, p13p, n13p, can13, 19)
    rowFc(tfF4, pN4, nN4, can4N, p14p, n14p, can14, 20)
    rowFc(tfF5, pN5, nN5, can5N, p15p, n15p, can15, 21)
    rowFc(tfF6, pN6, nN6, can6N, p16p, n16p, can16, 22)
    rowFc(tfF7, pN7, nN7, can7N, p17p, n17p, can17, 23)

    // Footer rows (semantic clarity + parameters)
    table.cell(t, 0, 24, "Target", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 24, targetDesc, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 24, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 24, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 24, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 25, "Note", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 25, "Outlook=State snapshot (confirmed TF bars). Forecast=Calibrated P(up|state) with n gating.", text_color=tblTextDim, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 25, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 25, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 25, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

//====================
// Alerts (bar close)
//====================
alertcondition(buySignal,   title="BUY (bar close)",   message="BUY {{ticker}} @ {{close}}")
alertcondition(exitSignal,  title="EXIT (bar close)",  message="EXIT {{ticker}} @ {{close}}")
alertcondition(shortSignal, title="SHORT (bar close)", message="SHORT {{ticker}} @ {{close}}")
alertcondition(coverSignal, title="COVER (bar close)", message="COVER {{ticker}} @ {{close}}")// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © preuss_steffen

//@version=6
indicator("SkippALGO — Outlook + Forecast (Calibrated)", overlay=true, max_labels_count=500, max_lines_count=500)

//====================
// Inputs
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose", "TRIG (legacy)"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Horizons shown in table (and used for calibration)
tfF1 = input.timeframe("1",   "Horizon 1")   // 1M
tfF2 = input.timeframe("5",   "Horizon 2")   // 5M
tfF3 = input.timeframe("15",  "Horizon 3")   // 15M
tfF4 = input.timeframe("30",  "Horizon 4")   // 30M
tfF5 = input.timeframe("60",  "Horizon 5")   // 1H
tfF6 = input.timeframe("240", "Horizon 6")   // 4H
tfF7 = input.timeframe("D",   "Horizon 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis (Trend-Continuation friendly)
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn  = input.float(55.0, "RSI long ON",  minval=0.0, maxval=100.0, step=0.5)
rsiLongOff = input.float(50.0, "RSI long OFF", minval=0.0, maxval=100.0, step=0.5)
rsiShortOn = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff= input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// MTF score RSI length (keep stable so MTF acts like regime filter)
rsiMtfLen = input.int(14, "MTF RSI length", minval=2)

// Connors RSI (3,2,100) used as confidence factor
useCrsiFactor     = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo    = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi    = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult  = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust   = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver      = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult  = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels   = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers    = input.bool(true, "Show SET markers")
showTable         = input.bool(true, "Show Outlook + Forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

// Forecast calibration params
predBins          = input.int(3,  "Forecast: bins (N)", minval=2, maxval=10)
calMinSamples     = input.int(50, "Forecast: MinN", minval=10, maxval=500)
alphaSmooth       = input.float(1.0, "Forecast: α (Laplace smoothing)", minval=0.0, maxval=10.0, step=0.25)
predDnThr         = input.float(0.45, "Forecast: Down threshold", minval=0.0, maxval=1.0, step=0.01)
predUpThr         = input.float(0.55, "Forecast: Up threshold",   minval=0.0, maxval=1.0, step=0.01)

// Reset calibration (manual)
resetCal = input.bool(false, "Forecast: Reset calibration now")

//====================
// Helpers
//====================
f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tf_secs(tf) =>
    timeframe.in_seconds(tf)

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = f_tf_secs(tf)
    not na(base) and not na(other) and other >= base

f_tfLabel(tf) =>
    tf == "1"   ? "1M"  :
    tf == "5"   ? "5M"  :
    tf == "15"  ? "15M" :
    tf == "30"  ? "30M" :
    tf == "60"  ? "1H"  :
    tf == "240" ? "4H"  :
    tf == "D"   ? "1D"  : tf

f_fmtVol(v) =>
    na(v) ? "—" :
     v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") :
     v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") :
     v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") :
                         str.tostring(v, "#")

// ====================
// OUTLOOK (STATE) score + components (single-timeframe, no forecasting)
// ====================
f_state_pack() =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)
    r_    = ta.rsi(close, rsiMtfLen)

    trend = emaF_ > emaS_ ? 1.0 : emaF_ < emaS_ ? -1.0 : 0.0
    mom   = r_ > 55 ? 1.0 : r_ < 45 ? -1.0 : 0.0
    loc   = close > emaS_ ? 0.5 : close < emaS_ ? -0.5 : 0.0

    score = f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0
    [score, trend, mom, loc, r_]

f_outSymbol(score) =>
    score > 0.05 ? "▲" : score < -0.05 ? "▼" : "−"

f_outColor(score, tblText) =>
    score > 0.05 ? color.lime : score < -0.05 ? color.red : tblText

f_tml_str(tr, mo, lo) =>
    str.tostring(tr, "#.0") + "/" + str.tostring(mo, "#.0") + "/" + str.tostring(lo, "#.0")

// ====================
// FORECAST (PROB) via calibration on forward outcomes
// ====================
f_bin(score, bins) =>
    s = f_clamp01((score + 1.0) * 0.5)
    b = int(math.floor(s * bins))
    math.min(bins - 1, math.max(0, b))

f_prob_text(pUp, n, canCal) =>
    not canCal ? "n0" : n < calMinSamples ? ("n" + str.tostring(n)) : (str.tostring(pUp * 100.0, "#.0") + "%")

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "—" :
     n < calMinSamples ? "…" :
      pUp > predUpThr ? "▲" :
      pUp < predDnThr ? "▼" : "−"

f_predColorP(pUp, n, canCal, tblText) =>
    not canCal ? color.new(color.white, 70) :
     n < calMinSamples ? color.new(color.white, 60) :
      pUp > predUpThr ? color.lime :
      pUp < predDnThr ? color.red : tblText

f_probTextColor(pUp, n, canCal, tblText) =>
    not canCal ? color.new(color.white, 70) :
     n < calMinSamples ? color.new(color.white, 60) :
      (pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : tblText)

f_calib_update(canCal, prevBinN, prevUpN, prevBin1, prevUp1,
               bins, alpha,
               longCountsN, upCountsN, longCounts1, upCounts1) =>
    if canCal
        if not na(prevBinN) and prevBinN >= 0 and prevBinN < bins
            longCountsN.set(prevBinN, longCountsN.get(prevBinN) + 1)
            if prevUpN == 1
                upCountsN.set(prevBinN, upCountsN.get(prevBinN) + 1)

        if not na(prevBin1) and prevBin1 >= 0 and prevBin1 < bins
            longCounts1.set(prevBin1, longCounts1.get(prevBin1) + 1)
            if prevUp1 == 1
                upCounts1.set(prevBin1, upCounts1.get(prevBin1) + 1)

f_calib_read(canCal, scoreNow, bins, alpha, longCounts, upCounts) =>
    if not canCal
        [0.5, 0, false]
    else
        b = f_bin(scoreNow, bins)
        n = longCounts.get(b)
        u = upCounts.get(b)
        p = (u + alpha) / (n + 2.0 * alpha)
        [p, n, true]

f_tf_pack(tf, bins) =>
    [scoreNow, trNow, moNow, loNow, rsiNow] = request.security(syminfo.tickerid, tf, f_state_pack(), barmerge.gaps_off, barmerge.lookahead_off)

    scorePrevN = request.security(syminfo.tickerid, tf, f_state_pack()[0][bins], barmerge.gaps_off, barmerge.lookahead_off)
    scorePrev1 = request.security(syminfo.tickerid, tf, f_state_pack()[0][1],    barmerge.gaps_off, barmerge.lookahead_off)

    isUp = request.security(syminfo.tickerid, tf, close > close[1] ? 1 : 0, barmerge.gaps_off, barmerge.lookahead_off)

    prevBinN = f_bin(scorePrevN, bins)
    prevBin1 = f_bin(scorePrev1, bins)
    prevUpN  = isUp
    prevUp1  = isUp

    [scoreNow, trNow, moNow, loNow, rsiNow, prevBinN, prevUpN, prevBin1, prevUp1]

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ?
     ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("5"))   ? rsiLenFastTF :
      (not na(baseSecs) and baseSecs <= timeframe.in_seconds("60"))  ? rsiLenMidTF  :
                                                                       rsiLenSlowTF) :
     rsiLenSlowTF

rsiConf = ta.rsi(close, rsiLenUse)

// Crosses (computed every bar)
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime
atrRank = f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? volRankRaw : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias + confidence
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state (drives confidence accuracyScore)
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI (3,2,100) for confidence factor
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

chg = ta.change(close)

crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(chg, crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor =
    crsi < crsiLongPanic ? crsiLongPanicMult :
    crsi > crsiLongOver  ? crsiLongOverMult  :
    (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor =
    crsi < crsiShortExhaust ? crsiShortExhaustMult :
    crsi > crsiShortOver    ? crsiShortOverMult    :
    (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// RSI(7) for Strength table
rsi7 = ta.rsi(close, 7)

// Trust score
f_trust_score(dir, guardrailCount_, volRank_, dataQualityScore_, macroScore_, momOkLong_, momOkShort_) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)
    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong_ : momOkShort_
    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank_ >= volRankHigh ? 0.4 : volRank_ >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount_ * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore_ +
        trustWMacro     * macroScore_
    ) / wSum

    extraPenalty = volRank_ >= volRankHigh ? penaltyRegimeHigh : volRank_ >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

confMultiplier =
     config == "Standard"      ? 1.00 :
     config == "Pro"           ? 1.05 :
     config == "V2 Essential"  ? 0.95 :
     config == "V2 Proficient" ? 1.00 : 1.10

trustRaw   = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidence = f_clamp01(trustRaw * confMultiplier)
confidence := f_clamp01(confidence * (1.0 - ddPenalty))
confidence := f_clamp01(confidence * crsiFactor)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30"))  ? "Short" :
           (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

// Simple MTF vote using OUTLOOK state score (still “outlook”, not forecasting)
f_score_tf(tf) =>
    [s, _, _, _, _] = request.security(syminfo.tickerid, tf, f_state_pack(), barmerge.gaps_off, barmerge.lookahead_off)
    s

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

// Gate requires: Confidence Logic + MTF Vote + Macro + Drawdown
gateLongNow  = (confidence >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidence >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter (avoid entries right before RTH close)
//====================
sessClose     = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose   = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones (anchored)
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice =
     zoneAnchor == "Entry"    and not na(entryPrice) ? entryPrice :
     zoneAnchor == "VWAP"     ? vwapVal :
     zoneAnchor == "MA200"    ? sma200Val :
     zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker (Trend Continuation Setup)
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine
//====================
trendFlipUp   = crossEmaF_EmaS_up
trendFlipDown = crossEmaF_EmaS_down
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "—"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)
allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias
else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias
else
    buySignal := false
    exitSignal := false
    shortSignal := false
    coverSignal := false

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidence, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 88))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Table colors (match your example look)
//====================
tblBg      = color.new(color.rgb(12, 20, 35), 0)
tblHeader  = color.new(color.rgb(12, 20, 35), 0)
tblCell    = color.new(color.rgb(12, 20, 35), 0)
tblFrame   = color.new(color.rgb(100, 130, 200), 50)
tblText    = color.white
tblTextDim = color.new(color.white, 25)
tblTfColor = color.new(color.rgb(220, 220, 255), 0)

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

//====================
// Calibration storage (per horizon)
//====================
makeCountsArray(bins) =>
    array.new_int(bins, 0)

var int binsUse = predBins

var array<int> cntN_1M = makeCountsArray(binsUse)
var array<int> upN_1M  = makeCountsArray(binsUse)
var array<int> cnt1_1M = makeCountsArray(binsUse)
var array<int> up1_1M  = makeCountsArray(binsUse)

var array<int> cntN_5M = makeCountsArray(binsUse)
var array<int> upN_5M  = makeCountsArray(binsUse)
var array<int> cnt1_5M = makeCountsArray(binsUse)
var array<int> up1_5M  = makeCountsArray(binsUse)

var array<int> cntN_15M = makeCountsArray(binsUse)
var array<int> upN_15M  = makeCountsArray(binsUse)
var array<int> cnt1_15M = makeCountsArray(binsUse)
var array<int> up1_15M  = makeCountsArray(binsUse)

var array<int> cntN_30M = makeCountsArray(binsUse)
var array<int> upN_30M  = makeCountsArray(binsUse)
var array<int> cnt1_30M = makeCountsArray(binsUse)
var array<int> up1_30M  = makeCountsArray(binsUse)

var array<int> cntN_1H = makeCountsArray(binsUse)
var array<int> upN_1H  = makeCountsArray(binsUse)
var array<int> cnt1_1H = makeCountsArray(binsUse)
var array<int> up1_1H  = makeCountsArray(binsUse)

var array<int> cntN_4H = makeCountsArray(binsUse)
var array<int> upN_4H  = makeCountsArray(binsUse)
var array<int> cnt1_4H = makeCountsArray(binsUse)
var array<int> up1_4H  = makeCountsArray(binsUse)

var array<int> cntN_1D = makeCountsArray(binsUse)
var array<int> upN_1D  = makeCountsArray(binsUse)
var array<int> cnt1_1D = makeCountsArray(binsUse)
var array<int> up1_1D  = makeCountsArray(binsUse)

// Reset
if resetCal
    for i = 0 to binsUse - 1
        cntN_1M.set(i, 0), upN_1M.set(i, 0), cnt1_1M.set(i, 0), up1_1M.set(i, 0)
        cntN_5M.set(i, 0), upN_5M.set(i, 0), cnt1_5M.set(i, 0), up1_5M.set(i, 0)
        cntN_15M.set(i, 0), upN_15M.set(i, 0), cnt1_15M.set(i, 0), up1_15M.set(i, 0)
        cntN_30M.set(i, 0), upN_30M.set(i, 0), cnt1_30M.set(i, 0), up1_30M.set(i, 0)
        cntN_1H.set(i, 0), upN_1H.set(i, 0), cnt1_1H.set(i, 0), up1_1H.set(i, 0)
        cntN_4H.set(i, 0), upN_4H.set(i, 0), cnt1_4H.set(i, 0), up1_4H.set(i, 0)
        cntN_1D.set(i, 0), upN_1D.set(i, 0), cnt1_1D.set(i, 0), up1_1D.set(i, 0)

//====================
// Compute packs per horizon (OUTLOOK + FORECAST prereqs)
//====================
[sc1, tr1, mo1, lo1, r1, pbN1, puN1, pb11, pu11] = f_tf_pack(tfF1, binsUse)
[sc2, tr2, mo2, lo2, r2, pbN2, puN2, pb12, pu12] = f_tf_pack(tfF2, binsUse)
[sc3, tr3, mo3, lo3, r3, pbN3, puN3, pb13, pu13] = f_tf_pack(tfF3, binsUse)
[sc4, tr4, mo4, lo4, r4, pbN4, puN4, pb14, pu14] = f_tf_pack(tfF4, binsUse)
[sc5, tr5, mo5, lo5, r5, pbN5, puN5, pb15, pu15] = f_tf_pack(tfF5, binsUse)
[sc6, tr6, mo6, lo6, r6, pbN6, puN6, pb16, pu16] = f_tf_pack(tfF6, binsUse)
[sc7, tr7, mo7, lo7, r7, pbN7, puN7, pb17, pu17] = f_tf_pack(tfF7, binsUse)

// Update calibration on confirmed bars only (prevents “empty/unstable” table behavior)
if barstate.isconfirmed
    can1 = not na(sc1)
    can2 = not na(sc2)
    can3 = not na(sc3)
    can4 = not na(sc4)
    can5 = not na(sc5)
    can6 = not na(sc6)
    can7 = not na(sc7)

    f_calib_update(can1, pbN1, puN1, pb11, pu11, binsUse, alphaSmooth, cntN_1M, upN_1M, cnt1_1M, up1_1M)
    f_calib_update(can2, pbN2, puN2, pb12, pu12, binsUse, alphaSmooth, cntN_5M, upN_5M, cnt1_5M, up1_5M)
    f_calib_update(can3, pbN3, puN3, pb13, pu13, binsUse, alphaSmooth, cntN_15M, upN_15M, cnt1_15M, up1_15M)
    f_calib_update(can4, pbN4, puN4, pb14, pu14, binsUse, alphaSmooth, cntN_30M, upN_30M, cnt1_30M, up1_30M)
    f_calib_update(can5, pbN5, puN5, pb15, pu15, binsUse, alphaSmooth, cntN_1H, upN_1H, cnt1_1H, up1_1H)
    f_calib_update(can6, pbN6, puN6, pb16, pu16, binsUse, alphaSmooth, cntN_4H, upN_4H, cnt1_4H, up1_4H)
    f_calib_update(can7, pbN7, puN7, pb17, pu17, binsUse, alphaSmooth, cntN_1D, upN_1D, cnt1_1D, up1_1D)

[pUpN1, nN1, okN1] = f_calib_read(not na(sc1), sc1, binsUse, alphaSmooth, cntN_1M, upN_1M)
[pUp11, n11, ok11] = f_calib_read(not na(sc1), sc1, binsUse, alphaSmooth, cnt1_1M, up1_1M)

[pUpN2, nN2, okN2] = f_calib_read(not na(sc2), sc2, binsUse, alphaSmooth, cntN_5M, upN_5M)
[pUp12, n12, ok12] = f_calib_read(not na(sc2), sc2, binsUse, alphaSmooth, cnt1_5M, up1_5M)

[pUpN3, nN3, okN3] = f_calib_read(not na(sc3), sc3, binsUse, alphaSmooth, cntN_15M, upN_15M)
[pUp13, n13, ok13] = f_calib_read(not na(sc3), sc3, binsUse, alphaSmooth, cnt1_15M, up1_15M)

[pUpN4, nN4, okN4] = f_calib_read(not na(sc4), sc4, binsUse, alphaSmooth, cntN_30M, upN_30M)
[pUp14, n14, ok14] = f_calib_read(not na(sc4), sc4, binsUse, alphaSmooth, cnt1_30M, up1_30M)

[pUpN5, nN5, okN5] = f_calib_read(not na(sc5), sc5, binsUse, alphaSmooth, cntN_1H, upN_1H)
[pUp15, n15, ok15] = f_calib_read(not na(sc5), sc5, binsUse, alphaSmooth, cnt1_1H, up1_1H)

[pUpN6, nN6, okN6] = f_calib_read(not na(sc6), sc6, binsUse, alphaSmooth, cntN_4H, upN_4H)
[pUp16, n16, ok16] = f_calib_read(not na(sc6), sc6, binsUse, alphaSmooth, cnt1_4H, up1_4H)

[pUpN7, nN7, okN7] = f_calib_read(not na(sc7), sc7, binsUse, alphaSmooth, cntN_1D, upN_1D)
[pUp17, n17, ok17] = f_calib_read(not na(sc7), sc7, binsUse, alphaSmooth, cnt1_1D, up1_1D)

//====================
// Table (5 columns) — OUTLOOK + FORECAST blocks, explicitly labeled
//====================
var table t = table.new(position.middle_right, 5, 34, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
confStr = str.tostring(confidence * 100.0, "#.0") + "%"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow

c_conf = f_confColor(confidence)
c_vol  = volAvail ? color.lime : tblText

if showTable and barstate.isconfirmed
    table.clear(t, 0, 0, 4, 33)

    table.cell(t, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 2, 0, "",            text_color=tblText,   bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 3, 0, "",            text_color=tblText,   bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 4, 0, "",            text_color=tblText,   bgcolor=tblCell,   text_size=size.tiny)

    table.cell(t, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 2, volStr,   text_color=c_vol,      bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 2, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 3, strengthStr, text_color=c_strength, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    // ===== OUTLOOK BLOCK =====
    table.cell(t, 0, 8, "OUTLOOK (STATE)", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 8, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 8, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 8, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 8, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    table.cell(t, 0, 9, "TF",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 9, "Bias", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 9, "Score",text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 9, "T/M/L",text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 9, "RSI",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    table.cell(t, 0, 10, f_tfLabel(tfF1), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 10, f_outSymbol(sc1), text_color=f_outColor(sc1, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 10, str.tostring(sc1, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 10, f_tml_str(tr1, mo1, lo1), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 10, str.tostring(r1, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 11, f_tfLabel(tfF2), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 11, f_outSymbol(sc2), text_color=f_outColor(sc2, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 11, str.tostring(sc2, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 11, f_tml_str(tr2, mo2, lo2), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 11, str.tostring(r2, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 12, f_tfLabel(tfF3), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 12, f_outSymbol(sc3), text_color=f_outColor(sc3, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 12, str.tostring(sc3, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 12, f_tml_str(tr3, mo3, lo3), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 12, str.tostring(r3, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 13, f_tfLabel(tfF4), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 13, f_outSymbol(sc4), text_color=f_outColor(sc4, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 13, str.tostring(sc4, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 13, f_tml_str(tr4, mo4, lo4), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 13, str.tostring(r4, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 14, f_tfLabel(tfF5), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 14, f_outSymbol(sc5), text_color=f_outColor(sc5, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 14, str.tostring(sc5, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 14, f_tml_str(tr5, mo5, lo5), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 14, str.tostring(r5, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 15, f_tfLabel(tfF6), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 15, f_outSymbol(sc6), text_color=f_outColor(sc6, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 15, str.tostring(sc6, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 15, f_tml_str(tr6, mo6, lo6), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 15, str.tostring(r6, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 16, f_tfLabel(tfF7), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 16, f_outSymbol(sc7), text_color=f_outColor(sc7, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 16, str.tostring(sc7, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 16, f_tml_str(tr7, mo7, lo7), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 16, str.tostring(r7, "#.0"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    // ===== FORECAST BLOCK =====
    table.cell(t, 0, 18, "FORECAST (PROB)", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 18, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 18, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 18, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 18, "", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    table.cell(t, 0, 19, "TF",      text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 19, "Pred(N)", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 19, "Pred(1)", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 19, "PUp(N)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 19, "PUp(1)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    table.cell(t, 0, 20, f_tfLabel(tfF1), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 20, f_predSymbolP(pUpN1, nN1, okN1), text_color=f_predColorP(pUpN1, nN1, okN1, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 20, f_predSymbolP(pUp11, n11, ok11), text_color=f_predColorP(pUp11, n11, ok11, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 20, f_prob_text(pUpN1, nN1, okN1),   text_color=f_probTextColor(pUpN1, nN1, okN1, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 20, f_prob_text(pUp11, n11, ok11),   text_color=f_probTextColor(pUp11, n11, ok11, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 21, f_tfLabel(tfF2), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 21, f_predSymbolP(pUpN2, nN2, okN2), text_color=f_predColorP(pUpN2, nN2, okN2, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 21, f_predSymbolP(pUp12, n12, ok12), text_color=f_predColorP(pUp12, n12, ok12, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 21, f_prob_text(pUpN2, nN2, okN2),   text_color=f_probTextColor(pUpN2, nN2, okN2, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 21, f_prob_text(pUp12, n12, ok12),   text_color=f_probTextColor(pUp12, n12, ok12, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 22, f_tfLabel(tfF3), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 22, f_predSymbolP(pUpN3, nN3, okN3), text_color=f_predColorP(pUpN3, nN3, okN3, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 22, f_predSymbolP(pUp13, n13, ok13), text_color=f_predColorP(pUp13, n13, ok13, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 22, f_prob_text(pUpN3, nN3, okN3),   text_color=f_probTextColor(pUpN3, nN3, okN3, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 22, f_prob_text(pUp13, n13, ok13),   text_color=f_probTextColor(pUp13, n13, ok13, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 23, f_tfLabel(tfF4), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 23, f_predSymbolP(pUpN4, nN4, okN4), text_color=f_predColorP(pUpN4, nN4, okN4, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 23, f_predSymbolP(pUp14, n14, ok14), text_color=f_predColorP(pUp14, n14, ok14, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 23, f_prob_text(pUpN4, nN4, okN4),   text_color=f_probTextColor(pUpN4, nN4, okN4, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 23, f_prob_text(pUp14, n14, ok14),   text_color=f_probTextColor(pUp14, n14, ok14, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 24, f_tfLabel(tfF5), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 24, f_predSymbolP(pUpN5, nN5, okN5), text_color=f_predColorP(pUpN5, nN5, okN5, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 24, f_predSymbolP(pUp15, n15, ok15), text_color=f_predColorP(pUp15, n15, ok15, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 24, f_prob_text(pUpN5, nN5, okN5),   text_color=f_probTextColor(pUpN5, nN5, okN5, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 24, f_prob_text(pUp15, n15, ok15),   text_color=f_probTextColor(pUp15, n15, ok15, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 25, f_tfLabel(tfF6), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 25, f_predSymbolP(pUpN6, nN6, okN6), text_color=f_predColorP(pUpN6, nN6, okN6, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 25, f_predSymbolP(pUp16, n16, ok16), text_color=f_predColorP(pUp16, n16, ok16, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 25, f_prob_text(pUpN6, nN6, okN6),   text_color=f_probTextColor(pUpN6, nN6, okN6, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 25, f_prob_text(pUp16, n16, ok16),   text_color=f_probTextColor(pUp16, n16, ok16, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 26, f_tfLabel(tfF7), text_color=tblTfColor, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 26, f_predSymbolP(pUpN7, nN7, okN7), text_color=f_predColorP(pUpN7, nN7, okN7, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 26, f_predSymbolP(pUp17, n17, ok17), text_color=f_predColorP(pUp17, n17, ok17, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 26, f_prob_text(pUpN7, nN7, okN7),   text_color=f_probTextColor(pUpN7, nN7, okN7, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 26, f_prob_text(pUp17, n17, ok17),   text_color=f_probTextColor(pUp17, n17, ok17, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 28, "Params", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 28, "N=" + str.tostring(predBins) + "  MinN=" + str.tostring(calMinSamples), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 28, "α=" + str.tostring(alphaSmooth, "#.##"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 28, "Thr", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 28, str.tostring(predDnThr, "#.00") + "/" + str.tostring(predUpThr, "#.00"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 29, "Meaning", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 29, "Outlook = state", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 29, "Forecast = PUp", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 29, "…=insuff", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 29, "n0=no data", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

//====================
// Alerts
//====================
alertcondition(buySignal,   title="BUY (bar close)",   message="BUY {{ticker}} @ {{close}}")
alertcondition(exitSignal,  title="EXIT (bar close)",  message="EXIT {{ticker}} @ {{close}}")
alertcondition(shortSignal, title="SHORT (bar close)", message="SHORT {{ticker}} @ {{close}}")
alertcondition(coverSignal, title="COVER (bar close)", message="COVER {{ticker}} @ {{close}}")
