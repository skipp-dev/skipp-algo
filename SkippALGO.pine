// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © preuss_steffen

//@version=6
indicator("SkippALGO", overlay=true, max_labels_count=500, max_lines_count=500)

//====================
// Inputs
//====================
config = input.string("V2 Alpha", "Configuration", options=["Standard", "Pro", "V2 Essential", "V2 Proficient", "V2 Alpha"])

// Signal engine
engine       = input.string("Trend+Pullback", "Signal engine", options=["Trend+Pullback", "Loose", "TRIG (legacy)"])
enableShorts = input.bool(false, "Enable shorts (SHORT can open short)")
cooldownBars = input.int(6, "Cooldown bars", minval=0)
minTrust     = input.float(0.55, "Min confidence (0..1)", minval=0.0, maxval=1.0, step=0.01)

// MTF use
useMtfConfirm = input.bool(true, "MTF confirmation")
mtfSet        = input.string("Auto", "MTF set", options=["Auto", "Short", "Medium", "Long"])
tfShort1      = input.timeframe("5", "Short TF 1")
tfShort2      = input.timeframe("15", "Short TF 2")
tfShort3      = input.timeframe("30", "Short TF 3")
tfMedium1     = input.timeframe("60", "Medium TF 1")
tfMedium2     = input.timeframe("240", "Medium TF 2")
tfMedium3     = input.timeframe("D", "Medium TF 3")
tfLong1       = input.timeframe("D", "Long TF 1")
tfLong2       = input.timeframe("5D", "Long TF 2")
tfLong3       = input.timeframe("10D", "Long TF 3")

// Forecast horizons (table rows)
tfF1 = input.timeframe("1",   "Forecast 1")   // 1M
tfF2 = input.timeframe("5",   "Forecast 2")   // 5M
tfF3 = input.timeframe("15",  "Forecast 3")   // 15M
tfF4 = input.timeframe("30",  "Forecast 4")   // 30M
tfF5 = input.timeframe("60",  "Forecast 5")   // 1H
tfF6 = input.timeframe("240", "Forecast 6")   // 4H
tfF7 = input.timeframe("D",   "Forecast 7")   // 1D

// Trust-score weighting
trustWAccuracy  = input.float(0.40, "Trust weight: accuracy", minval=0.0, step=0.05)
trustWRegime    = input.float(0.30, "Trust weight: regime", minval=0.0, step=0.05)
trustWGuardrail = input.float(0.20, "Trust weight: guardrails", minval=0.0, step=0.05)
trustWData      = input.float(0.10, "Trust weight: data quality", minval=0.0, step=0.05)
trustWMacro     = input.float(0.10, "Trust weight: macro context", minval=0.0, step=0.05)

penaltyGuardrail  = input.float(0.20, "Penalty per guardrail flag", minval=0.0, step=0.05)
penaltyRegimeHigh = input.float(0.20, "Penalty: high-vol regime", minval=0.0, step=0.05)
penaltyRegimeMed  = input.float(0.10, "Penalty: medium-vol regime", minval=0.0, step=0.05)

volRankMed  = input.float(0.60, "Regime threshold: vol medium", minval=0.0, maxval=1.0, step=0.05)
volRankHigh = input.float(0.80, "Regime threshold: vol high", minval=0.0, maxval=1.0, step=0.05)

gapShockPct   = input.float(0.0125, "Guardrail: gap shock %", minval=0.0, step=0.0025)
rangeShockPct = input.float(0.05,   "Guardrail: range shock %", minval=0.0, step=0.01)

// Macro context
macroPctLen         = input.int(252, "Macro pct-rank lookback", minval=20)
macroPctLenIntraday = input.int(200, "Macro pct-rank intraday fallback", minval=20)
macroGateMode       = input.string("Trust", "Macro context mode", options=["Off", "Trust", "Hard Gate"])
macroLongPctThreshold  = input.float(0.35, "Macro LONG threshold (pct rank)",  minval=0.0, maxval=1.0, step=0.05)
macroShortPctThreshold = input.float(0.65, "Macro SHORT threshold (pct rank)", minval=0.0, maxval=1.0, step=0.05)

// Drawdown-aware haircut
ddLookback     = input.int(120, "Drawdown lookback", minval=20)
ddMild         = input.float(0.10, "Drawdown mild (abs)", minval=0.05, step=0.05)
ddSevere       = input.float(0.30, "Drawdown severe (abs)", minval=0.10, step=0.05)
ddTrustPenalty = input.float(0.20, "Drawdown trust penalty", minval=0.0, maxval=1.0, step=0.05)
ddHardGate     = input.float(0.45, "Drawdown hard gate (abs)", minval=0.0, maxval=0.9, step=0.05)

// Core lengths (trend)
emaFastLen = input.int(21, "EMA fast", minval=1)
emaSlowLen = input.int(55, "EMA slow", minval=1)
atrLen     = input.int(14, "ATR length", minval=1)
volRankLen = input.int(100,"Volatility rank lookback", minval=20)

// Confidence momentum: Adaptive RSI + hysteresis
useAdaptiveRsi = input.bool(true, "Adaptive RSI length by TF (confidence)")
rsiLenFastTF   = input.int(7,  "RSI len (<=5m)", minval=2)
rsiLenMidTF    = input.int(9,  "RSI len (<=1h)", minval=2)
rsiLenSlowTF   = input.int(14, "RSI len (>1h)",  minval=2)

rsiLongOn   = input.float(55.0, "RSI long ON",   minval=0.0, maxval=100.0, step=0.5)
rsiLongOff  = input.float(50.0, "RSI long OFF",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOn  = input.float(45.0, "RSI short ON",  minval=0.0, maxval=100.0, step=0.5)
rsiShortOff = input.float(50.0, "RSI short OFF", minval=0.0, maxval=100.0, step=0.5)

// MTF score RSI length (stable)
rsiMtfLen = input.int(14, "MTF RSI length", minval=2)

// Connors RSI (3,2,100) factor
useCrsiFactor      = input.bool(true, "CRSI factor on confidence")
crsiRsiLen         = input.int(3,   "CRSI: RSI len", minval=2)
crsiStreakRsiLen   = input.int(2,   "CRSI: Streak RSI len", minval=2)
crsiRankLen        = input.int(100, "CRSI: Rank len", minval=20)

crsiLongGoodLo     = input.float(15.0, "CRSI LONG good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodHi     = input.float(55.0, "CRSI LONG good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiLongGoodMult   = input.float(1.10, "CRSI LONG good mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongOver       = input.float(80.0, "CRSI LONG over", minval=0.0, maxval=100.0, step=1.0)
crsiLongOverMult   = input.float(0.85, "CRSI LONG over mult", minval=0.50, maxval=1.50, step=0.01)
crsiLongPanic      = input.float(10.0, "CRSI LONG panic", minval=0.0, maxval=100.0, step=1.0)
crsiLongPanicMult  = input.float(0.90, "CRSI LONG panic mult", minval=0.50, maxval=1.50, step=0.01)

crsiShortGoodLo      = input.float(45.0, "CRSI SHORT good (lo)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodHi      = input.float(85.0, "CRSI SHORT good (hi)", minval=0.0, maxval=100.0, step=1.0)
crsiShortGoodMult    = input.float(1.10, "CRSI SHORT good mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortExhaust     = input.float(20.0, "CRSI SHORT exhaust", minval=0.0, maxval=100.0, step=1.0)
crsiShortExhaustMult = input.float(0.85, "CRSI SHORT exhaust mult", minval=0.50, maxval=1.50, step=0.01)
crsiShortOver        = input.float(90.0, "CRSI SHORT over", minval=0.0, maxval=100.0, step=1.0)
crsiShortOverMult    = input.float(0.90, "CRSI SHORT over mult", minval=0.50, maxval=1.50, step=0.01)

// Zones
showZones  = input.bool(true, "Show zones")
zoneAnchor = input.string("EMA Slow", "Zone anchor", options=["Entry", "EMA Fast", "EMA Slow", "VWAP", "MA200"])
zoneMode   = input.string("Pullback", "Zone mode", options=["Pullback", "Symmetric"])
zoneNeutralMult      = input.float(0.8, "Neutral zone ATR mult", minval=0.1, step=0.1)
zoneAggressiveMult1  = input.float(1.6, "Aggressive zone ATR mult 1", minval=0.2, step=0.1)
zoneAggressiveMult2  = input.float(2.4, "Aggressive zone ATR mult 2", minval=0.4, step=0.1)

// Visual controls
showEntryLabels = input.bool(true, "Show labels (BUY / EXIT / SHORT)")
showSetMarkers  = input.bool(true, "Show SET markers")
showTable       = input.bool(true, "Show forecast table")

// Avoid entries right before close
useRthCloseFilter = input.bool(true, "Avoid last N minutes before RTH close")
rthCloseHour      = input.int(16, "RTH close hour (exchange tz)", minval=0, maxval=23)
rthCloseMinute    = input.int(0,  "RTH close minute", minval=0, maxval=59)
avoidCloseMins    = input.int(10, "Avoid last N minutes", minval=0, maxval=120)

// Forecast calibration + confidence coupling
fwdBars              = input.int(3, "Forecast forward bars (N) per TF", minval=1, maxval=20)
calMinSamples        = input.int(50, "Calibration min samples per bin", minval=5, maxval=500)
calAlpha             = input.float(1.0, "Calibration smoothing alpha", minval=0.0, maxval=10.0, step=0.25)
predUpThr            = input.float(0.55, "Pred threshold UP (p)", minval=0.50, maxval=0.80, step=0.01)
predDnThr            = input.float(0.45, "Pred threshold DOWN (p)", minval=0.20, maxval=0.50, step=0.01)

useForecastConfAdj   = input.bool(true, "Use forecast-calibrated confidence adjust")
forecastConfStrength = input.float(0.20, "Forecast confidence strength", minval=0.0, maxval=0.50, step=0.01)
forecastConfTfPick   = input.string("Auto", "Confidence coupling TF", options=["Auto","F1","F2","F3","F4","F5","F6","F7"])
forecastConfHorizon  = input.string("Blend", "Confidence horizon", options=["N","1","Blend"])

resetCalibration = input.bool(false, "Reset calibration now (toggle)")

//====================
// Helpers
//====================
f_clamp01(x) =>
    math.max(0.0, math.min(1.0, x))

f_pct_rank(x, len) =>
    lo = ta.lowest(x, len)
    hi = ta.highest(x, len)
    hi == lo ? 0.5 : (x - lo) / (hi - lo)

f_tf_secs(tf) =>
    timeframe.in_seconds(tf)

f_is_tf_higher_or_equal(tf) =>
    base  = timeframe.in_seconds(timeframe.period)
    other = f_tf_secs(tf)
    not na(base) and not na(other) and other >= base

f_score_tf(tf) =>
    srcClose = request.security(syminfo.tickerid, tf, close, barmerge.gaps_off, barmerge.lookahead_off)
    emaF_tf  = request.security(syminfo.tickerid, tf, ta.ema(close, emaFastLen), barmerge.gaps_off, barmerge.lookahead_off)
    emaS_tf  = request.security(syminfo.tickerid, tf, ta.ema(close, emaSlowLen), barmerge.gaps_off, barmerge.lookahead_off)
    r_tf     = request.security(syminfo.tickerid, tf, ta.rsi(close, rsiMtfLen),  barmerge.gaps_off, barmerge.lookahead_off)

    trend = emaF_tf > emaS_tf ? 1.0 : emaF_tf < emaS_tf ? -1.0 : 0.0
    mom   = r_tf > 55 ? 1.0 : r_tf < 45 ? -1.0 : 0.0
    loc   = srcClose > emaS_tf ? 0.5 : srcClose < emaS_tf ? -0.5 : 0.0

    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

f_trust_score(dir, guardrailCount, volRank, dataQualityScore, macroScore, momOkLong, momOkShort) =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)

    trendOk = dir == 1 ? (emaF_ > emaS_ and close > emaS_) : (emaF_ < emaS_ and close < emaS_)
    momOk   = dir == 1 ? momOkLong : momOkShort

    accuracyScore = (trendOk ? 0.6 : 0.0) + (momOk ? 0.4 : 0.0)

    regimeScore     = volRank >= volRankHigh ? 0.4 : volRank >= volRankMed ? 0.7 : 1.0
    guardrailScore  = f_clamp01(1.0 - (guardrailCount * penaltyGuardrail))

    wSum = trustWAccuracy + trustWRegime + trustWGuardrail + trustWData + trustWMacro
    wSum := wSum == 0.0 ? 1.0 : wSum

    base = (
        trustWAccuracy  * accuracyScore +
        trustWRegime    * regimeScore +
        trustWGuardrail * guardrailScore +
        trustWData      * dataQualityScore +
        trustWMacro     * macroScore
    ) / wSum

    extraPenalty = volRank >= volRankHigh ? penaltyRegimeHigh : volRank >= volRankMed ? penaltyRegimeMed : 0.0
    f_clamp01(base - extraPenalty)

f_tfLabel(tf) =>
    tf == "1" ? "1M" : tf == "5" ? "5M" : tf == "15" ? "15M" : tf == "30" ? "30M" : tf == "60" ? "1H" : tf == "240" ? "4H" : tf == "D" ? "1D" : tf

f_confColor(val) =>
    val > 0.70 ? color.lime : val <= 0.45 ? color.red : color.yellow

f_fmtVol(v) =>
    na(v) ? "—" :
     v >= 1000000000.0 ? (str.tostring(v / 1000000000.0, "#.###") + "B") :
     v >= 1000000.0    ? (str.tostring(v / 1000000.0, "#.###") + "M") :
     v >= 1000.0       ? (str.tostring(v / 1000.0, "#.###") + "K") :
                         str.tostring(v, "#")

//====================
// Core indicators
//====================
emaF = ta.ema(close, emaFastLen)
emaS = ta.ema(close, emaSlowLen)
atr  = ta.atr(atrLen)

// Adaptive RSI length (for confidence momentum only)
baseSecs = timeframe.in_seconds(timeframe.period)
rsiLenUse = useAdaptiveRsi ?
     ((not na(baseSecs) and baseSecs <= timeframe.in_seconds("5"))  ? rsiLenFastTF :
      (not na(baseSecs) and baseSecs <= timeframe.in_seconds("60")) ? rsiLenMidTF :
                                                                      rsiLenSlowTF) :
     rsiLenSlowTF

rsiConf = ta.rsi(close, rsiLenUse)

// Crosses
crossEmaF_EmaS_up   = ta.crossover(emaF, emaS)
crossEmaF_EmaS_down = ta.crossunder(emaF, emaS)

crossClose_EmaF_up   = ta.crossover(close, emaF)
crossClose_EmaF_down = ta.crossunder(close, emaF)

crossClose_EmaS_up   = ta.crossover(close, emaS)
crossClose_EmaS_down = ta.crossunder(close, emaS)

// Vol regime
atrRank = f_pct_rank(atr / close, volRankLen)

// Guardrails
prevClose = close[1]
gapPct    = (na(prevClose) or prevClose == 0.0) ? 0.0 : math.abs(open - prevClose) / prevClose
rangePct  = close == 0.0 ? 0.0 : (high - low) / close
volShock  = atrRank >= volRankHigh
gapShock  = gapPct >= gapShockPct
rangeShock= rangePct >= rangeShockPct
guardrailCount = (volShock ? 1 : 0) + (gapShock ? 1 : 0) + (rangeShock ? 1 : 0)

// Data quality proxy
volAvail = not na(volume)
volRankRaw = f_pct_rank(volume, volRankLen)
dataQualityScore = volAvail ? volRankRaw : 0.5

// Macro
macroLen = timeframe.isintraday ? math.min(macroPctLen, macroPctLenIntraday) : macroPctLen
macroPct = f_pct_rank(close, macroLen)
macroScoreRaw = f_clamp01(1.0 - macroPct)
macroScore = macroGateMode == "Off" ? 0.5 : macroScoreRaw
macroGateLong  = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct < macroLongPctThreshold)  : true
macroGateShort = macroGateMode == "Hard Gate" ? (not na(macroPct) and macroPct > macroShortPctThreshold) : true

// Drawdown
ddPeak = ta.highest(close, ddLookback)
dd     = ddPeak == 0.0 ? 0.0 : (close - ddPeak) / ddPeak
ddAbs  = math.max(0.0, -dd)
ddSeverity = f_clamp01((ddAbs - ddMild) / math.max(ddSevere - ddMild, 0.0001))
ddPenalty  = ddTrustPenalty * ddSeverity
ddHardGateHit = ddHardGate > 0.0 and ddAbs >= ddHardGate

// Direction bias
bullBias = emaF > emaS
bearBias = emaF < emaS
baseDir  = bullBias ? 1 : bearBias ? -1 : 0
trustDir = baseDir == 0 ? 1 : baseDir

// Momentum hysteresis state
var bool momLongOnState  = false
var bool momShortOnState = false
var bool momStateInit    = false

if not na(rsiConf)
    if not momStateInit
        momLongOnState  := rsiConf > 50.0
        momShortOnState := rsiConf < 50.0
        momStateInit    := true
    else
        if (not momLongOnState) and (rsiConf > rsiLongOn)
            momLongOnState := true
        else if momLongOnState and (rsiConf < rsiLongOff)
            momLongOnState := false

        if (not momShortOnState) and (rsiConf < rsiShortOn)
            momShortOnState := true
        else if momShortOnState and (rsiConf > rsiShortOff)
            momShortOnState := false

// Connors RSI (3,2,100) factor
var float streak = 0.0
if na(close[1])
    streak := 0.0
else
    if close > close[1]
        streak := streak >= 0 ? streak + 1 : 1
    else if close < close[1]
        streak := streak <= 0 ? streak - 1 : -1
    else
        streak := 0.0

crsiRsiPart    = ta.rsi(close,  crsiRsiLen)
crsiStreakPart = ta.rsi(streak, crsiStreakRsiLen)
crsiRankPart   = f_pct_rank(ta.change(close), crsiRankLen) * 100.0
crsi           = (crsiRsiPart + crsiStreakPart + crsiRankPart) / 3.0

longFactor =
    crsi < crsiLongPanic ? crsiLongPanicMult :
    crsi > crsiLongOver  ? crsiLongOverMult  :
    (crsi >= crsiLongGoodLo and crsi <= crsiLongGoodHi) ? crsiLongGoodMult : 1.0

shortFactor =
    crsi < crsiShortExhaust ? crsiShortExhaustMult :
    crsi > crsiShortOver    ? crsiShortOverMult    :
    (crsi >= crsiShortGoodLo and crsi <= crsiShortGoodHi) ? crsiShortGoodMult : 1.0

crsiFactor = (not useCrsiFactor) ? 1.0 : (bullBias ? longFactor : bearBias ? shortFactor : 1.0)

// Strength proxy
rsi7 = ta.rsi(close, 7)

// Base confidence
confMultiplier =
     config == "Standard"      ? 1.00 :
     config == "Pro"           ? 1.05 :
     config == "V2 Essential"  ? 0.95 :
     config == "V2 Proficient" ? 1.00 : 1.10

trustRaw       = f_trust_score(trustDir, guardrailCount, atrRank, dataQualityScore, macroScore, momLongOnState, momShortOnState)
confidenceBase = f_clamp01(trustRaw * confMultiplier)
confidenceBase := f_clamp01(confidenceBase * (1.0 - ddPenalty))
confidenceBase := f_clamp01(confidenceBase * crsiFactor)

//====================
// Forecast stats (TRUE forward targets) + calibrated probs (N-bar and 1-bar)
//====================
CAL_BINS = 11

f_bin(score) =>
    step = 2.0 / CAL_BINS
    idx  = int(math.floor((score + 1.0) / step))
    math.max(0, math.min(CAL_BINS - 1, idx))

f_prob_smoothed(winsArr, totalArr, binIdx, alpha) =>
    int tot = array.get(totalArr, binIdx)
    int win = array.get(winsArr,  binIdx)
    float p = tot <= 0 ? 0.5 : ((win + alpha) / (tot + 2.0 * alpha))
    [p, tot]

f_predSymbolP(pUp, n, canCal) =>
    not canCal ? "—" :
    n < calMinSamples ? "…" :
    pUp > predUpThr ? "▲" :
    pUp < predDnThr ? "▼" : "−"

f_predColorP(pUp, n, canCal, neutralColor) =>
    not canCal ? color.new(color.white, 70) :
    n < calMinSamples ? color.new(color.white, 60) :
    pUp > predUpThr ? color.lime :
    pUp < predDnThr ? color.red : neutralColor

f_probText(pUp, n, canCal) =>
    not canCal ? "N/A" :
    n < calMinSamples ? ("n" + str.tostring(n)) :
    (str.tostring(pUp * 100.0, "#.0") + "%")

f_probTextColor(pUp, n, canCal, neutralColor) =>
    not canCal ? color.new(color.white, 70) :
    n < calMinSamples ? color.new(color.white, 60) :
    (pUp > predUpThr ? color.lime : pUp < predDnThr ? color.red : neutralColor)

// TF-local state score (runs inside TF context)
f_state_score() =>
    emaF_ = ta.ema(close, emaFastLen)
    emaS_ = ta.ema(close, emaSlowLen)
    r_    = ta.rsi(close, rsiMtfLen)
    trend = emaF_ > emaS_ ? 1.0 : emaF_ < emaS_ ? -1.0 : 0.0
    mom   = r_ > 55 ? 1.0 : r_ < 45 ? -1.0 : 0.0
    loc   = close > emaS_ ? 0.5 : close < emaS_ ? -0.5 : 0.0
    f_clamp01((trend + mom + loc + 2.0) / 4.0) * 2.0 - 1.0

// FIXED pack: history references on expression result, not on local var
f_tf_pack_expr() =>
    scoreNow  = f_state_score()
    scorePrevN = f_state_score()[fwdBars]
    scorePrev1 = f_state_score()[1]

    bPrevN = not na(scorePrevN) ? float(f_bin(scorePrevN)) : na
    uPrevN = not na(close[fwdBars]) ? float(close > close[fwdBars] ? 1 : 0) : na

    bPrev1 = not na(scorePrev1) ? float(f_bin(scorePrev1)) : na
    uPrev1 = not na(close[1]) ? float(close > close[1] ? 1 : 0) : na

    [scoreNow, bPrevN, uPrevN, bPrev1, uPrev1]

// Returns: scoreNow, binPrevN, upPrevN, binPrev1, upPrev1
f_tf_pack(tf) =>
    request.security(syminfo.tickerid, tf, f_tf_pack_expr(), barmerge.gaps_off, barmerge.lookahead_off)

// tfChanged computed globally so ta.change executes every bar
f_calib_update(canCal, tfChanged, scoreNow, binPrevN_f, upPrevN_f, binPrev1_f, upPrev1_f, winsN, totalN, wins1, total1, alpha) =>
    if canCal and tfChanged and barstate.isconfirmed
        if not na(binPrevN_f) and not na(upPrevN_f)
            bN = int(binPrevN_f)
            uN = int(upPrevN_f)
            array.set(totalN, bN, array.get(totalN, bN) + 1)
            array.set(winsN,  bN, array.get(winsN,  bN) + uN)
        if not na(binPrev1_f) and not na(upPrev1_f)
            b1 = int(binPrev1_f)
            u1 = int(upPrev1_f)
            array.set(total1, b1, array.get(total1, b1) + 1)
            array.set(wins1,  b1, array.get(wins1,  b1) + u1)

    bNow = f_bin(scoreNow)
    [pN, nN] = f_prob_smoothed(winsN, totalN, bNow, alpha)
    [p1, n1] = f_prob_smoothed(wins1, total1, bNow, alpha)
    [pN, nN, p1, n1]

// Can we calibrate? Only if chart TF <= forecast TF
canCal1 = f_is_tf_higher_or_equal(tfF1)
canCal2 = f_is_tf_higher_or_equal(tfF2)
canCal3 = f_is_tf_higher_or_equal(tfF3)
canCal4 = f_is_tf_higher_or_equal(tfF4)
canCal5 = f_is_tf_higher_or_equal(tfF5)
canCal6 = f_is_tf_higher_or_equal(tfF6)
canCal7 = f_is_tf_higher_or_equal(tfF7)

// TF boundary flags
tfF1_changed = nz(ta.change(time(tfF1)), 0) != 0
tfF2_changed = nz(ta.change(time(tfF2)), 0) != 0
tfF3_changed = nz(ta.change(time(tfF3)), 0) != 0
tfF4_changed = nz(ta.change(time(tfF4)), 0) != 0
tfF5_changed = nz(ta.change(time(tfF5)), 0) != 0
tfF6_changed = nz(ta.change(time(tfF6)), 0) != 0
tfF7_changed = nz(ta.change(time(tfF7)), 0) != 0

// Pull TF packs (1 security call per TF)
[score1, binPrevN1_f, upPrevN1_f, binPrev1_1_f, upPrev1_1_f] = f_tf_pack(tfF1)
[score2, binPrevN2_f, upPrevN2_f, binPrev1_2_f, upPrev1_2_f] = f_tf_pack(tfF2)
[score3, binPrevN3_f, upPrevN3_f, binPrev1_3_f, upPrev1_3_f] = f_tf_pack(tfF3)
[score4, binPrevN4_f, upPrevN4_f, binPrev1_4_f, upPrev1_4_f] = f_tf_pack(tfF4)
[score5, binPrevN5_f, upPrevN5_f, binPrev1_5_f, upPrev1_5_f] = f_tf_pack(tfF5)
[score6, binPrevN6_f, upPrevN6_f, binPrev1_6_f, upPrev1_6_f] = f_tf_pack(tfF6)
[score7, binPrevN7_f, upPrevN7_f, binPrev1_7_f, upPrev1_7_f] = f_tf_pack(tfF7)

// Stats arrays
var winsF1N  = array.new_int(CAL_BINS, 0), totalF1N  = array.new_int(CAL_BINS, 0)
var winsF1_1 = array.new_int(CAL_BINS, 0), totalF1_1 = array.new_int(CAL_BINS, 0)

var winsF2N  = array.new_int(CAL_BINS, 0), totalF2N  = array.new_int(CAL_BINS, 0)
var winsF2_1 = array.new_int(CAL_BINS, 0), totalF2_1 = array.new_int(CAL_BINS, 0)

var winsF3N  = array.new_int(CAL_BINS, 0), totalF3N  = array.new_int(CAL_BINS, 0)
var winsF3_1 = array.new_int(CAL_BINS, 0), totalF3_1 = array.new_int(CAL_BINS, 0)

var winsF4N  = array.new_int(CAL_BINS, 0), totalF4N  = array.new_int(CAL_BINS, 0)
var winsF4_1 = array.new_int(CAL_BINS, 0), totalF4_1 = array.new_int(CAL_BINS, 0)

var winsF5N  = array.new_int(CAL_BINS, 0), totalF5N  = array.new_int(CAL_BINS, 0)
var winsF5_1 = array.new_int(CAL_BINS, 0), totalF5_1 = array.new_int(CAL_BINS, 0)

var winsF6N  = array.new_int(CAL_BINS, 0), totalF6N  = array.new_int(CAL_BINS, 0)
var winsF6_1 = array.new_int(CAL_BINS, 0), totalF6_1 = array.new_int(CAL_BINS, 0)

var winsF7N  = array.new_int(CAL_BINS, 0), totalF7N  = array.new_int(CAL_BINS, 0)
var winsF7_1 = array.new_int(CAL_BINS, 0), totalF7_1 = array.new_int(CAL_BINS, 0)

// Reset logic (edge-trigger)
var bool resetLatch = false
doReset = resetCalibration and not resetLatch

if doReset
    array.fill(winsF1N, 0), array.fill(totalF1N, 0), array.fill(winsF1_1, 0), array.fill(totalF1_1, 0)
    array.fill(winsF2N, 0), array.fill(totalF2N, 0), array.fill(winsF2_1, 0), array.fill(totalF2_1, 0)
    array.fill(winsF3N, 0), array.fill(totalF3N, 0), array.fill(winsF3_1, 0), array.fill(totalF3_1, 0)
    array.fill(winsF4N, 0), array.fill(totalF4N, 0), array.fill(winsF4_1, 0), array.fill(totalF4_1, 0)
    array.fill(winsF5N, 0), array.fill(totalF5N, 0), array.fill(winsF5_1, 0), array.fill(totalF5_1, 0)
    array.fill(winsF6N, 0), array.fill(totalF6N, 0), array.fill(winsF6_1, 0), array.fill(totalF6_1, 0)
    array.fill(winsF7N, 0), array.fill(totalF7N, 0), array.fill(winsF7_1, 0), array.fill(totalF7_1, 0)
    resetLatch := true

if not resetCalibration
    resetLatch := false

// Update stats + current probs
[pUp1N, n1N, pUp1_1, n1_1] = f_calib_update(canCal1, tfF1_changed, score1, binPrevN1_f, upPrevN1_f, binPrev1_1_f, upPrev1_1_f, winsF1N, totalF1N, winsF1_1, totalF1_1, calAlpha)
[pUp2N, n2N, pUp2_1, n2_1] = f_calib_update(canCal2, tfF2_changed, score2, binPrevN2_f, upPrevN2_f, binPrev1_2_f, upPrev1_2_f, winsF2N, totalF2N, winsF2_1, totalF2_1, calAlpha)
[pUp3N, n3N, pUp3_1, n3_1] = f_calib_update(canCal3, tfF3_changed, score3, binPrevN3_f, upPrevN3_f, binPrev1_3_f, upPrev1_3_f, winsF3N, totalF3N, winsF3_1, totalF3_1, calAlpha)
[pUp4N, n4N, pUp4_1, n4_1] = f_calib_update(canCal4, tfF4_changed, score4, binPrevN4_f, upPrevN4_f, binPrev1_4_f, upPrev1_4_f, winsF4N, totalF4N, winsF4_1, totalF4_1, calAlpha)
[pUp5N, n5N, pUp5_1, n5_1] = f_calib_update(canCal5, tfF5_changed, score5, binPrevN5_f, upPrevN5_f, binPrev1_5_f, upPrev1_5_f, winsF5N, totalF5N, winsF5_1, totalF5_1, calAlpha)
[pUp6N, n6N, pUp6_1, n6_1] = f_calib_update(canCal6, tfF6_changed, score6, binPrevN6_f, upPrevN6_f, binPrev1_6_f, upPrev1_6_f, winsF6N, totalF6N, winsF6_1, totalF6_1, calAlpha)
[pUp7N, n7N, pUp7_1, n7_1] = f_calib_update(canCal7, tfF7_changed, score7, binPrevN7_f, upPrevN7_f, binPrev1_7_f, upPrev1_7_f, winsF7N, totalF7N, winsF7_1, totalF7_1, calAlpha)

//====================
// Confidence coupling: choose TF and horizon
//====================
sec1 = timeframe.in_seconds(tfF1)
sec2 = timeframe.in_seconds(tfF2)
sec3 = timeframe.in_seconds(tfF3)
sec4 = timeframe.in_seconds(tfF4)
sec5 = timeframe.in_seconds(tfF5)
sec6 = timeframe.in_seconds(tfF6)
sec7 = timeframe.in_seconds(tfF7)

float pUpConfN = 0.5, pUpConf1 = 0.5
int   nConfN = 0, nConf1 = 0
bool  canCalConf = false
string confTfLabel = "—"

if forecastConfTfPick == "F1"
    confTfLabel := f_tfLabel(tfF1), canCalConf := canCal1, pUpConfN := pUp1N, nConfN := n1N, pUpConf1 := pUp1_1, nConf1 := n1_1
else if forecastConfTfPick == "F2"
    confTfLabel := f_tfLabel(tfF2), canCalConf := canCal2, pUpConfN := pUp2N, nConfN := n2N, pUpConf1 := pUp2_1, nConf1 := n2_1
else if forecastConfTfPick == "F3"
    confTfLabel := f_tfLabel(tfF3), canCalConf := canCal3, pUpConfN := pUp3N, nConfN := n3N, pUpConf1 := pUp3_1, nConf1 := n3_1
else if forecastConfTfPick == "F4"
    confTfLabel := f_tfLabel(tfF4), canCalConf := canCal4, pUpConfN := pUp4N, nConfN := n4N, pUpConf1 := pUp4_1, nConf1 := n4_1
else if forecastConfTfPick == "F5"
    confTfLabel := f_tfLabel(tfF5), canCalConf := canCal5, pUpConfN := pUp5N, nConfN := n5N, pUpConf1 := pUp5_1, nConf1 := n5_1
else if forecastConfTfPick == "F6"
    confTfLabel := f_tfLabel(tfF6), canCalConf := canCal6, pUpConfN := pUp6N, nConfN := n6N, pUpConf1 := pUp6_1, nConf1 := n6_1
else if forecastConfTfPick == "F7"
    confTfLabel := f_tfLabel(tfF7), canCalConf := canCal7, pUpConfN := pUp7N, nConfN := n7N, pUpConf1 := pUp7_1, nConf1 := n7_1
else
    bestSec = 1e18
    if canCal1 and sec1 < bestSec
        bestSec := sec1, confTfLabel := f_tfLabel(tfF1), canCalConf := canCal1, pUpConfN := pUp1N, nConfN := n1N, pUpConf1 := pUp1_1, nConf1 := n1_1
    if canCal2 and sec2 < bestSec
        bestSec := sec2, confTfLabel := f_tfLabel(tfF2), canCalConf := canCal2, pUpConfN := pUp2N, nConfN := n2N, pUpConf1 := pUp2_1, nConf1 := n2_1
    if canCal3 and sec3 < bestSec
        bestSec := sec3, confTfLabel := f_tfLabel(tfF3), canCalConf := canCal3, pUpConfN := pUp3N, nConfN := n3N, pUpConf1 := pUp3_1, nConf1 := n3_1
    if canCal4 and sec4 < bestSec
        bestSec := sec4, confTfLabel := f_tfLabel(tfF4), canCalConf := canCal4, pUpConfN := pUp4N, nConfN := n4N, pUpConf1 := pUp4_1, nConf1 := n4_1
    if canCal5 and sec5 < bestSec
        bestSec := sec5, confTfLabel := f_tfLabel(tfF5), canCalConf := canCal5, pUpConfN := pUp5N, nConfN := n5N, pUpConf1 := pUp5_1, nConf1 := n5_1
    if canCal6 and sec6 < bestSec
        bestSec := sec6, confTfLabel := f_tfLabel(tfF6), canCalConf := canCal6, pUpConfN := pUp6N, nConfN := n6N, pUpConf1 := pUp6_1, nConf1 := n6_1
    if canCal7 and sec7 < bestSec
        bestSec := sec7, confTfLabel := f_tfLabel(tfF7), canCalConf := canCal7, pUpConfN := pUp7N, nConfN := n7N, pUpConf1 := pUp7_1, nConf1 := n7_1

float pUpConf = 0.5
int   nConf   = 0
if forecastConfHorizon == "1"
    pUpConf := pUpConf1
    nConf   := nConf1
else if forecastConfHorizon == "Blend"
    pUpConf := 0.5 * (pUpConfN + pUpConf1)
    nConf   := math.min(nConfN, nConf1)
else
    pUpConf := pUpConfN
    nConf   := nConfN

confidenceLongEff  = confidenceBase
confidenceShortEff = confidenceBase

if useForecastConfAdj and canCalConf and (nConf >= calMinSamples)
    bias = (pUpConf - 0.5) * 2.0
    multLong  = 1.0 + forecastConfStrength * bias
    multShort = 1.0 - forecastConfStrength * bias
    lo = 1.0 - forecastConfStrength
    hi = 1.0 + forecastConfStrength
    multLong  := math.max(lo, math.min(hi, multLong))
    multShort := math.max(lo, math.min(hi, multShort))
    confidenceLongEff  := f_clamp01(confidenceBase * multLong)
    confidenceShortEff := f_clamp01(confidenceBase * multShort)

//====================
// MTF confirmation
//====================
mtfBaseSecs = timeframe.in_seconds(timeframe.period)
autoSet  = (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("30"))  ? "Short" :
           (not na(mtfBaseSecs) and mtfBaseSecs <= timeframe.in_seconds("240")) ? "Medium" : "Long"
setUse   = mtfSet == "Auto" ? autoSet : mtfSet

getVoteScore() =>
    float sum = 0.0
    float cnt = 0.0

    tf1 = setUse == "Short" ? tfShort1 : setUse == "Medium" ? tfMedium1 : tfLong1
    tf2 = setUse == "Short" ? tfShort2 : setUse == "Medium" ? tfMedium2 : tfLong2
    tf3 = setUse == "Short" ? tfShort3 : setUse == "Medium" ? tfMedium3 : tfLong3

    if f_is_tf_higher_or_equal(tf1)
        sum += f_score_tf(tf1)
        cnt += 1
    if f_is_tf_higher_or_equal(tf2)
        sum += f_score_tf(tf2)
        cnt += 1
    if f_is_tf_higher_or_equal(tf3)
        sum += f_score_tf(tf3)
        cnt += 1

    cnt == 0 ? 0.0 : sum / cnt

mtfScore   = useMtfConfirm ? getVoteScore() : 0.0
mtfOkLong  = (not useMtfConfirm) or (mtfScore > 0.05)
mtfOkShort = (not useMtfConfirm) or (mtfScore < -0.05)

gateLongNow  = (confidenceLongEff  >= minTrust) and mtfOkLong  and macroGateLong  and not ddHardGateHit
gateShortNow = (confidenceShortEff >= minTrust) and mtfOkShort and macroGateShort and not ddHardGateHit

//====================
// Close filter
//====================
sessClose     = timestamp(syminfo.timezone, year, month, dayofmonth, rthCloseHour, rthCloseMinute)
minsToClose   = (sessClose - time) / 60000.0
blockNearClose = useRthCloseFilter and timeframe.isintraday and (minsToClose >= 0) and (minsToClose <= avoidCloseMins)

//====================
// Zones
//====================
var float entryPrice = na
vwapVal   = ta.vwap(hlc3)
sma200Val = ta.sma(close, 200)

zoneAnchorPrice =
     zoneAnchor == "Entry"    and not na(entryPrice) ? entryPrice :
     zoneAnchor == "VWAP"     ? vwapVal :
     zoneAnchor == "MA200"    ? sma200Val :
     zoneAnchor == "EMA Fast" ? emaF : emaS

neutralUpper = zoneAnchorPrice + zoneNeutralMult * atr
neutralLower = zoneAnchorPrice - zoneNeutralMult * atr

aggrUpper = zoneMode == "Symmetric" ? (zoneAnchorPrice + zoneAggressiveMult1 * atr) : (zoneAnchorPrice - zoneAggressiveMult1 * atr)
aggrLower = zoneMode == "Symmetric" ? (zoneAnchorPrice - zoneAggressiveMult2 * atr) : (zoneAnchorPrice - zoneAggressiveMult2 * atr)

//====================
// SET marker
//====================
setLong   = bullBias and (crsi < crsiLongGoodHi)
setShort  = bearBias and (crsi > crsiShortGoodLo)
setPulse  = barstate.isconfirmed and (setLong or setShort)

//====================
// Signal engine
//====================
trendFlipUp   = crossEmaF_EmaS_up
trendFlipDown = crossEmaF_EmaS_down
reclaimUp     = bullBias and crossClose_EmaF_up
reclaimDown   = bearBias and crossClose_EmaF_down

breakLong  = crossClose_EmaS_down or trendFlipDown
breakShort = crossClose_EmaS_up   or trendFlipUp

var int pos = 0
var int lastSignalBar = na
var string lastSig = "—"

cooldownOk   = na(lastSignalBar) ? true : (bar_index - lastSignalBar > cooldownBars)
allowEntry   = barstate.isconfirmed and cooldownOk and not blockNearClose
allowExit    = barstate.isconfirmed

buySignal   = false
exitSignal  = false
shortSignal = false
coverSignal = false

if engine == "Trend+Pullback"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and (trendFlipUp or reclaimUp)
        shortSignal := enableShorts and gateShortNow and (trendFlipDown or reclaimDown)
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias
else if engine == "Loose"
    if pos == 0 and allowEntry
        buySignal   := gateLongNow and crossClose_EmaF_up
        shortSignal := enableShorts and gateShortNow and crossClose_EmaF_down
        if buySignal and shortSignal
            buySignal := false
            shortSignal := false
    if pos == 1 and allowExit
        exitSignal := breakLong and bearBias
    if pos == -1 and allowExit
        coverSignal := breakShort and bullBias
else
    buySignal := false
    exitSignal := false
    shortSignal := false
    coverSignal := false

if barstate.isconfirmed
    if exitSignal and pos == 1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "EXIT"
    else if coverSignal and pos == -1
        pos := 0
        entryPrice := na
        lastSignalBar := bar_index
        lastSig := "COVER"
    else if buySignal and pos == 0
        pos := 1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "BUY"
    else if shortSignal and pos == 0
        pos := -1
        entryPrice := close
        lastSignalBar := bar_index
        lastSig := "SHORT"

//====================
// Visuals
//====================
plotshape(showSetMarkers and setPulse, title="SET", style=shape.circle, location=location.belowbar, size=size.tiny, text="SET", textcolor=color.white, color=color.new(color.blue, 0))

if showEntryLabels and buySignal
    label.new(bar_index, low, "BUY\nConf " + str.tostring(confidenceLongEff, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))
if showEntryLabels and shortSignal
    label.new(bar_index, high, "SHORT\nConf " + str.tostring(confidenceShortEff, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and exitSignal
    label.new(bar_index, high, "EXIT\nConf " + str.tostring(confidenceBase, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))
if showEntryLabels and coverSignal
    label.new(bar_index, low, "COVER\nConf " + str.tostring(confidenceBase, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.green, 0))

pNeutralUpper = plot(showZones ? neutralUpper : na, title="Neutral zone upper", linewidth=1, color=color.new(color.blue, 25))
pNeutralLower = plot(showZones ? neutralLower : na, title="Neutral zone lower", linewidth=1, color=color.new(color.blue, 25))
fill(pNeutralUpper, pNeutralLower, color=color.new(color.blue, 90))

pAggUpper = plot(showZones ? aggrUpper : na, title="Aggressive zone upper", linewidth=1, color=color.new(color.orange, 25))
pAggLower = plot(showZones ? aggrLower : na, title="Aggressive zone lower", linewidth=1, color=color.new(color.orange, 88))
fill(pAggUpper, pAggLower, color=color.new(color.orange, 88))

//====================
// Forecast Table (5 columns; same colors as your example)
// TF | Pred(N) | Pred(1) | PUp(N) | PUp(1)
//====================
tblBg      = color.new(color.rgb(7, 16, 28), 72)
tblHeader  = color.new(color.rgb(7, 16, 28), 58)
tblCell    = color.new(color.rgb(7, 16, 28), 72)
tblFrame   = color.new(color.rgb(0, 190, 210), 0)
tblText    = color.new(color.rgb(210, 225, 240), 0)
tblTextDim = color.new(color.rgb(170, 190, 210), 0)

var table t = table.new(position.middle_right, 5, 18, bgcolor=tblBg, frame_color=tblFrame, frame_width=1, border_color=tblFrame, border_width=1)

mtfStr  = useMtfConfirm ? (setUse + " " + str.tostring(mtfScore, format.mintick)) : "OFF"
posStr  = pos == 1 ? "LONG" : pos == -1 ? "SHORT" : "FLAT"
volStr  = f_fmtVol(volume)

strengthVal = rsi7
strengthStr = str.tostring(strengthVal, "#.0")
c_strength  = strengthVal <= 45 ? color.red : strengthVal > 70 ? color.green : color.yellow

c_conf = f_confColor(confidenceBase)
confStr = str.tostring(confidenceBase * 100.0, "#.0") + "%"
confLs  = "L " + str.tostring(confidenceLongEff * 100.0, "#.0") + "% / S " + str.tostring(confidenceShortEff * 100.0, "#.0") + "%"

hLabel = forecastConfHorizon == "N" ? "N" : forecastConfHorizon == "1" ? "1" : "B"
confPickStr = confTfLabel + " " + hLabel + " " + (canCalConf ? (nConf < calMinSamples ? ("n" + str.tostring(nConf)) : (str.tostring(pUpConf * 100.0, "#.0") + "%")) : "N/A")

if showTable
    table.clear(t, 0, 0, 4, 17)

    table.cell(t, 0, 0, "Confidence", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 0, confStr,       text_color=c_conf,    bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 2, 0, confLs,        text_color=tblText,   bgcolor=tblCell,   text_size=size.tiny)
    table.cell(t, 3, 0, "ConfTF",      text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 0, confPickStr,   text_color=tblText,   bgcolor=tblCell,   text_size=size.tiny)

    table.cell(t, 0, 1, "MinTrust", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 1, str.tostring(minTrust, format.mintick), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 1, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 2, "Volume", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 2, volStr, text_color=(volAvail ? color.lime : tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 2, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 3, "Strength", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 3, strengthStr, text_color=c_strength, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 3, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 4, "MTF", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 4, mtfStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 4, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 5, "Pos", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 5, posStr, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 5, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 6, "LastSig", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 6, lastSig, text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 6, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 7, "Time", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 7, str.format_time(time, "yyyy-MM-dd HH:mm"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 7, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 8, "Forecast", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 8, "Pred(N)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 2, 8, "Pred(1)",  text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 3, 8, "PUp(N)",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 8, "PUp(1)",   text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)

    table.cell(t, 0, 9,  f_tfLabel(tfF1), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 9,  f_predSymbolP(pUp1N,  n1N,  canCal1), text_color=f_predColorP(pUp1N,  n1N,  canCal1, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 9,  f_predSymbolP(pUp1_1, n1_1, canCal1), text_color=f_predColorP(pUp1_1, n1_1, canCal1, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 9,  f_probText(pUp1N,  n1N,  canCal1), text_color=f_probTextColor(pUp1N,  n1N,  canCal1, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 9,  f_probText(pUp1_1, n1_1, canCal1), text_color=f_probTextColor(pUp1_1, n1_1, canCal1, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 10, f_tfLabel(tfF2), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 10, f_predSymbolP(pUp2N,  n2N,  canCal2), text_color=f_predColorP(pUp2N,  n2N,  canCal2, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 10, f_predSymbolP(pUp2_1, n2_1, canCal2), text_color=f_predColorP(pUp2_1, n2_1, canCal2, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 10, f_probText(pUp2N,  n2N,  canCal2), text_color=f_probTextColor(pUp2N,  n2N,  canCal2, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 10, f_probText(pUp2_1, n2_1, canCal2), text_color=f_probTextColor(pUp2_1, n2_1, canCal2, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 11, f_tfLabel(tfF3), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 11, f_predSymbolP(pUp3N,  n3N,  canCal3), text_color=f_predColorP(pUp3N,  n3N,  canCal3, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 11, f_predSymbolP(pUp3_1, n3_1, canCal3), text_color=f_predColorP(pUp3_1, n3_1, canCal3, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 11, f_probText(pUp3N,  n3N,  canCal3), text_color=f_probTextColor(pUp3N,  n3N,  canCal3, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 11, f_probText(pUp3_1, n3_1, canCal3), text_color=f_probTextColor(pUp3_1, n3_1, canCal3, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 12, f_tfLabel(tfF4), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 12, f_predSymbolP(pUp4N,  n4N,  canCal4), text_color=f_predColorP(pUp4N,  n4N,  canCal4, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 12, f_predSymbolP(pUp4_1, n4_1, canCal4), text_color=f_predColorP(pUp4_1, n4_1, canCal4, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 12, f_probText(pUp4N,  n4N,  canCal4), text_color=f_probTextColor(pUp4N,  n4N,  canCal4, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 12, f_probText(pUp4_1, n4_1, canCal4), text_color=f_probTextColor(pUp4_1, n4_1, canCal4, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 13, f_tfLabel(tfF5), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 13, f_predSymbolP(pUp5N,  n5N,  canCal5), text_color=f_predColorP(pUp5N,  n5N,  canCal5, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 13, f_predSymbolP(pUp5_1, n5_1, canCal5), text_color=f_predColorP(pUp5_1, n5_1, canCal5, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 13, f_probText(pUp5N,  n5N,  canCal5), text_color=f_probTextColor(pUp5N,  n5N,  canCal5, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 13, f_probText(pUp5_1, n5_1, canCal5), text_color=f_probTextColor(pUp5_1, n5_1, canCal5, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 14, f_tfLabel(tfF6), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 14, f_predSymbolP(pUp6N,  n6N,  canCal6), text_color=f_predColorP(pUp6N,  n6N,  canCal6, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 14, f_predSymbolP(pUp6_1, n6_1, canCal6), text_color=f_predColorP(pUp6_1, n6_1, canCal6, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 14, f_probText(pUp6N,  n6N,  canCal6), text_color=f_probTextColor(pUp6N,  n6N,  canCal6, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 14, f_probText(pUp6_1, n6_1, canCal6), text_color=f_probTextColor(pUp6_1, n6_1, canCal6, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 15, f_tfLabel(tfF7), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 1, 15, f_predSymbolP(pUp7N,  n7N,  canCal7), text_color=f_predColorP(pUp7N,  n7N,  canCal7, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 15, f_predSymbolP(pUp7_1, n7_1, canCal7), text_color=f_predColorP(pUp7_1, n7_1, canCal7, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 15, f_probText(pUp7N,  n7N,  canCal7), text_color=f_probTextColor(pUp7N,  n7N,  canCal7, tblText), bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 15, f_probText(pUp7_1, n7_1, canCal7), text_color=f_probTextColor(pUp7_1, n7_1, canCal7, tblText), bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 16, "Params", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 16, "N=" + str.tostring(fwdBars) + "  MinN=" + str.tostring(calMinSamples), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 16, "α=" + str.tostring(calAlpha, "#.##"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 16, "Thr", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 4, 16, str.tostring(predDnThr, "#.##") + "/" + str.tostring(predUpThr, "#.##"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

    table.cell(t, 0, 17, "Reset", text_color=tblTextDim, bgcolor=tblHeader, text_size=size.tiny)
    table.cell(t, 1, 17, doReset ? "DONE" : (resetCalibration ? "ON" : "OFF"), text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 2, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 3, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)
    table.cell(t, 4, 17, "", text_color=tblText, bgcolor=tblCell, text_size=size.tiny)

//====================
// Alerts
//====================
alertcondition(buySignal,   title="BUY (bar close)",   message="BUY {{ticker}} @ {{close}}")
alertcondition(exitSignal,  title="EXIT (bar close)",  message="EXIT {{ticker}} @ {{close}}")
alertcondition(shortSignal, title="SHORT (bar close)", message="SHORT {{ticker}} @ {{close}}")
alertcondition(coverSignal, title="COVER (bar close)", message="COVER {{ticker}} @ {{close}}")
